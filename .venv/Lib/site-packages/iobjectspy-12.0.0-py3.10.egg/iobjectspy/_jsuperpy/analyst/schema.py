from iobjectspy._jsuperpy._gateway import get_jvm
from iobjectspy._jsuperpy.data import (Datasource,
                                       DatasetVector,
                                       Point2D,
                                       GeoLine,
                                       GeoPoint,
                                       create_mem_datasource)
from iobjectspy._jsuperpy.data._util import (get_input_dataset,
                                             get_output_datasource,
                                             check_output_datasource,
                                             try_close_output_datasource)
from iobjectspy._jsuperpy.enums import *
from iobjectspy._jsuperpy._utils import *
from iobjectspy._jsuperpy._logger import *
from enum import unique

__all__ = ['TopologicalSchemaOrientation', 'NetworkEdge', 'NetworkNode',
           'TopologicalHierarchicalSchema', 'TopologicalTreeSchema',
           'TopologicalOrthogonalSchema', 'build_topological_schema']


@unique
class TopologicalSchemaOrientation(JEnum):
    """
    :var TopologicalSchemaOrientation.LEFTTORIGHT: 图形从左到右的布局走向。逻辑图将从左侧的根结点开始，并在右侧结束。
    :var TopologicalSchemaOrientation.RIGHTTOLEFT: 图形从右到左的布局走向。逻辑图将从右侧的根结点开始，并在左侧结束。
    :var TopologicalSchemaOrientation.TOPTOBOTTOM: 图形从上到下的布局走向。逻辑图将从顶部侧的根结点开始，并在底部结束。
    :var TopologicalSchemaOrientation.BOTTOMTOTOP: 图形从下到上的布局走向。逻辑图将从底部的根结点开始，并在顶部结束。
    """
    LEFTTORIGHT = 0
    RIGHTTOLEFT = 1
    TOPTOBOTTOM = 2
    BOTTOMTOTOP = 3

    @classmethod
    def _get_java_class_type(cls):
        return 'com.supermap.analyst.spatialanalyst.TopologicalSchemaOrientation'


class NetworkEdge:
    """
    网络弧段对象，表示网络关系。由线对象、线对象的唯一标识以及组成线对象首尾两个结点的唯一标识组成。
    """

    def __init__(self, edge_id, from_node_id, to_node_id, edge=None):
        """
        :param int edge_id: 网络弧段线对象ID
        :param int from_node_id: 网络弧段线对象起始点ID
        :param int to_node_id: 网络弧段线对象终止点ID
        :param GeoLine edge: 网络弧段线对象
        """
        self._edge = None
        self._edge_id = None
        self._from_node_id = None
        self._to_node_id = None
        self.set_edge(edge)
        self.set_edge_id(edge_id)
        self.set_from_node_id(from_node_id)
        self.set_to_node_id(to_node_id)

    @property
    def edge(self):
        """GeoLine: 网络关系中，弧段几何对象"""
        return self._edge

    def set_edge(self, value):
        """
        设置弧段的几何对象

        :param GeoLine value: 弧段几何对象
        :return: NetworkEdge
        :rtype: self
        """
        if isinstance(value, GeoLine):
            self._edge = value
        return self

    @property
    def edge_id(self):
        """int: 网络关系中，弧段对象的ID"""
        return self._edge_id

    def set_edge_id(self, value):
        """
        设置弧段对象的ID

        :param int value: 弧段对象ID
        :return: self
        :rtype: NetworkEdgeID
        """
        if value is not None:
            self._edge_id = int(value)
        return self

    @property
    def from_node_id(self):
        """int: 网络关系中，弧段起始点的ID"""
        return self._from_node_id

    def set_from_node_id(self, value):
        """
        设置弧段起始点的ID

        :param int value: 弧段起始点ID
        :return: self
        :rtype: NetworkEdgeID
        """
        if value is not None:
            self._from_node_id = int(value)
        return self

    @property
    def to_node_id(self):
        """int: 网络关系中，弧段终止点ID"""
        return self._to_node_id

    def set_to_node_id(self, value):
        """
        设置弧段终止点的ID

        :param int value: 弧段终止点ID
        :return: self
        :rtype: NetworkEdgeID
        """
        if value is not None:
            self._to_node_id = int(value)
        return self

    @property
    def _jobject(self):
        java_network_edge_id = get_jvm().com.supermap.analyst.spatialanalyst.NetworkEdgeID(int(self.edge_id),
                                                                                           int(self.from_node_id),
                                                                                           int(self.to_node_id))
        return get_jvm().com.supermap.analyst.spatialanalyst.NetworkEdge(oj(self.edge), java_network_edge_id)


class NetworkNode:
    """
    网络弧段关系中结点对象，由表示网络弧段关系中的点对象和结点对象的唯一标识表示。
    """

    def __init__(self, node_id, node):
        """
        :param int node_id: 网络结点ID
        :param GeoPoint node: 网络结点对象
        """
        self._node = None
        self._node_id = None
        self.set_node(node)
        self.set_node_id(node_id)

    @property
    def node(self):
        """GeoPoint: 网络结点对象"""
        return self._node

    def set_node(self, value):
        """
        设置网络结点对象

        :param value: 网络结点对象
        :type value: GeoPoint or Point2D
        :return: self
        :rtype: NetworkNode
        """
        if isinstance(value, GeoPoint):
            self._node = value
        else:
            value = Point2D.make(value)
            if isinstance(value, Point2D):
                self._node = GeoPoint(value)
        return self

    @property
    def node_id(self):
        """int: 网络结点ID"""
        return self._node_id

    def set_node_id(self, value):
        """
        设置网络结点ID

        :param int value: 网络结点ID
        :return: self
        :rtype: NetworkNode
        """
        if value is not None:
            self._node_id = int(value)
        return self

    @property
    def _jobject(self):
        return get_jvm().com.supermap.analyst.spatialanalyst.NetworkNode(oj(self.node), int(self.node_id))


class TopologicalHierarchicalSchema:
    """
    等级拓扑逻辑图。

    等级图适用于类似有向的设施网络中，有明确的源的网络。如下图网络中只有一个源，也就是一个子网中，只有一个入口，其他均为出口，这种网络可以生成等级图：

    .. image: ../image/SourceNetwork.png

    .. image: ../image/HierarchicalSchemaResult.png

    """

    def __init__(self, node_spacing=30.0, rank_node_spacing=50.0, smooth=1,
                 orientation=TopologicalSchemaOrientation.LEFTTORIGHT):
        """

        :param float node_spacing: 拓扑逻辑图结点距离
        :param float rank_node_spacing: 拓扑逻辑图等级之间的距离
        :param int smooth: 光滑系数
        :param orientation: 拓扑逻辑图的布局走向
        :type orientation: TopologicalSchemaOrientation or str
        """
        self._node_spacing = 30
        self._rank_node_spacing = 50
        self._smooth = 1
        self._orientation = TopologicalSchemaOrientation.LEFTTORIGHT
        self.set_node_spacing(node_spacing)
        self.set_rank_node_spacing(rank_node_spacing)
        self.set_smooth(smooth)
        self.set_orientation(orientation)

    @property
    def node_spacing(self):
        """float: 拓扑逻辑图结点距离。默认为 30。"""
        return self._node_spacing

    def set_node_spacing(self, value):
        """
        设置拓扑逻辑图结点距离。

        如下图所示从结点①到结点②的结点距离为dy

        .. image: ../image/HierarchicaPara.png

        :param float value: 拓扑逻辑图结点距离
        :return: self
        :rtype: TopologicalHierarchicalSchema
        """
        if value is not None and float(value) > 0:
            self._node_spacing = float(value)
        return self

    @property
    def rank_node_spacing(self):
        """float: 拓扑逻辑图等级之间的距离。默认为 50。"""
        return self._rank_node_spacing

    def set_rank_node_spacing(self, value):
        """
        设置拓扑逻辑图等级之间的距离。

        如下图所示从结点①到结点②为两个等级，dz即为等级间的距离

        .. image: ../image/HierarchicaPara.png

        :param float value: 拓扑逻辑图等级之间的距离
        :return: self
        :rtype: TopologicalHierarchicalSchema
        """
        if value is not None and float(value) > 0:
            self._rank_node_spacing = float(value)
        return self

    @property
    def smooth(self):
        """int: 光滑系数。默认为 1。"""
        return self._smooth

    def set_smooth(self, value):
        """
        设置光滑系数。如果需要对结果进行光滑处理，可以设置大于1的光滑系数，默认不进行光滑处理，即值为1。

        :param int value: 光滑系数
        :return: self
        :rtype: TopologicalHierarchicalSchema
        """
        if value is not None and int(value) >= 1:
            self._smooth = int(value)
        return self

    @property
    def orientation(self):
        """TopologicalSchemaOrientation: 拓扑逻辑图的布局走向"""
        return self._orientation

    def set_orientation(self, value):
        """
        设置拓扑逻辑图的布局走向，默认为从左到右布局。

        :param value: 拓扑逻辑图的布局走向
        :type value: TopologicalSchemaOrientation or str
        :return: self
        :rtype: TopologicalHierarchicalSchema
        """
        value = make_enum(TopologicalSchemaOrientation, value)
        if value:
            self._orientation = value
        return self

    @property
    def _jobject(self):
        obj = get_jvm().com.supermap.analyst.spatialanalyst.TopologicalHierarchicalSchema()
        if self.node_spacing:
            obj.setNodeSpacing(float(self.node_spacing))
        if self.rank_node_spacing:
            obj.setRankNodeSpacing(float(self.rank_node_spacing))
        if self.smooth:
            obj.setSmooth(int(self.smooth))
        if self.orientation:
            obj.setOrientation(oj(self.orientation))
        return obj


class TopologicalTreeSchema:
    """
    树形拓扑逻辑图。

    树形图和等级图一样。都适用于类似有向的设施网络中，有明确的源的网络。

    在一个子网中，只支持单源或单汇点情形，也就是一个子网中，只能有一个源点，汇点不做要求。也支持只有一个汇点，源点不做要求。

    .. image: ../image/TreeSchemaResult.png

    """

    def __init__(self, node_spacing=30.0, level_spacing=20.0, break_radio=0.5,
                 orientation=TopologicalSchemaOrientation.LEFTTORIGHT):
        """

        :param float node_spacing: 拓扑逻辑图结点距离
        :param float level_spacing: 树形图层级之间的距离
        :param float break_radio: 获取折线打断比例，值域为[0,1]
        :param orientation: 拓扑逻辑图的布局走向
        :type orientation: TopologicalSchemaOrientation or str
        """
        self._node_spacing = 30.0
        self._level_spacing = 20.0
        self._break_radio = break_radio
        self._orientation = TopologicalSchemaOrientation.LEFTTORIGHT
        self.set_node_spacing(node_spacing)
        self.set_level_spacing(level_spacing)
        self.set_break_radio(break_radio)
        self.set_orientation(orientation)

    @property
    def node_spacing(self):
        """float: 拓扑逻辑图结点距离，默认值为30. """
        return self._node_spacing

    def set_node_spacing(self, value):
        """
        设置拓扑逻辑图结点距离。
        如下图所示从结点①到结点②的结点距离为dy

        .. image: ../image/TopologicalTreePara.png

        :param float value: 拓扑逻辑图结点距离
        :return: self
        :rtype: TopologicalTreeSchema
        """
        if value is not None and float(value) > 0:
            self._node_spacing = float(value)
        return self

    @property
    def level_spacing(self):
        """float: 树形图层级之间的距离"""
        return self._level_spacing

    def set_level_spacing(self, value):
        """
        设置树形图层级之间的距离。
        下图所示从结点①到结点②为两个层级，dx即为层级间的距离

        .. image: ../image/TopologicalTreePara.png

        :param float value: 树形图层级之间的距离
        :return: self
        :rtype: TopologicalTreeSchema
        """
        if value is not None and float(value) > 0:
            self._level_spacing = float(value)
        return self

    @property
    def break_radio(self):
        """float: 折线打断比例。默认为 0.5. """
        return self._break_radio

    def set_break_radio(self, value):
        """
        设置折线打断比例。
        如下图所示从结点①到结点②的连接折线，即为要打断的折线，设置打断距离为0.7，得到如图效果

        .. image: ../image/TopologicalTreePara.png

        :param float value: 折线打断比例
        :return: self
        :rtype: TopologicalTreeSchema
        """
        if value is not None and float(value) > 0:
            self._break_radio = float(value)
        return self

    @property
    def orientation(self):
        """TopologicalSchemaOrientation: 拓扑逻辑图的布局走向"""
        return self._orientation

    def set_orientation(self, value):
        """
        设置拓扑逻辑图的布局走向

        :param value: 拓扑逻辑图的布局走向
        :type value: TopologicalSchemaOrientation or str
        :return: self
        :rtype: TopologicalTreeSchema
        """
        value = make_enum(TopologicalSchemaOrientation, value)
        if value:
            self._orientation = value
        return self

    @property
    def _jobject(self):
        obj = get_jvm().com.supermap.analyst.spatialanalyst.TopologicalTreeSchema()
        if self.node_spacing:
            obj.setNodeSpacing(float(self.node_spacing))
        if self.break_radio:
            obj.setBreakRadio(float(self.break_radio))
        if self.level_spacing:
            obj.setLevelSpacing(float(self.level_spacing))
        if self.orientation:
            obj.setOrientation(oj(self.orientation))
        return obj


class TopologicalOrthogonalSchema:
    """
    直角正交拓扑逻辑图。

    直角正交图对数据要求比较少，但要求数据不能有自循环（即在一条网络弧段中，起点等于终点）的弧段。

    .. image: ../image/OrthogonalSchemaResult.png

    """

    def __init__(self, node_spacing=10.0):
        """
        :param float node_spacing: 拓扑逻辑图结点距离
        """
        self._node_spacing = 10.0
        self.set_node_spacing(node_spacing)

    @property
    def node_spacing(self):
        """float: 拓扑逻辑图结点距离"""
        return self._node_spacing

    def set_node_spacing(self, value):
        """
        设置拓扑逻辑图结点之间的距离。默认值为 10 个单位。

        :param float value: 拓扑逻辑图结点距离
        :return: self
        :rtype: TopologicalOrthogonalSchema
        """
        if value is not None and float(value) > 0:
            self._node_spacing = float(value)
        return self

    @property
    def _jobject(self):
        obj = get_jvm().com.supermap.analyst.spatialanalyst.TopologicalOrthogonalSchema()
        if self.node_spacing:
            obj.setNodeSpacing(float(self.node_spacing))
        return obj


def build_topological_schema(schema_param, network_dt_or_edges, network_nodes=None, is_merge=False,
                             tolerance=1.0e-10, out_data=None, out_dataset_name=None):
    """
    构建拓扑逻辑图。

    拓扑逻辑图，是基于网络数据集生成体现自身逻辑结构的示意图，将复杂的网络以一种直观的方式进行表达，简化了网络的表现形式。可应用于电信、交通、管线、
    电力等行业的资源管理，通过拓扑逻辑图查看网络，能够有效评估现有的网络资源分布，预测和规划后续资源的配置等。

    SuperMap 支持根据网络弧段和网络结点表示的网络关系，构建拓扑逻辑图，方便检查网络连通性及获取网络数据的逻辑示意图。

    >>> network_dt = open_datasource('/home/iobjectspy/data/example_data.udbx')['network_schema']

    构建等级图:

    >>> hierarchical_schema_result = build_topological_schema(TopologicalHierarchicalSchema(smooth=3), network_dt)

    构建树形图:

    >>> tree_schema_result = build_topological_schema(TopologicalTreeSchema(), network_dt)

    构建直角正交图:

    >>> orthogonal_schema_result = build_topological_schema(TopologicalOrthogonalSchema(), network_dt)

    通过网络关系构建拓扑图:

    >>> network_edges = list()
    >>> network_edges.append(NetworkEdge(1, 1, 2))
    >>> network_edges.append(NetworkEdge(2, 1, 3))
    >>> network_edges.append(NetworkEdge(3, 2, 4))
    >>> network_edges.append(NetworkEdge(4, 2, 5))
    >>> network_edges.append(NetworkEdge(5, 3, 6))
    >>> network_edges.append(NetworkEdge(6, 3, 7))
    >>> out_ds = create_mem_datasource()
    >>> tree_schema_result_2 = build_topological_schema(TopologicalTreeSchema(), network_edges, out_data=out_ds)

    通过网络弧段和网络结点构建拓扑图：

    >>> edges = []
    >>> nodes = []
    >>> edge_rd = network_dt.get_recordset()
    >>> while edge_rd.has_next():
    >>>     edge_id = edge_rd.get_value('SmEdgeID')
    >>>     f_node = edge_rd.get_value('SmFNode')
    >>>     t_node = edge_rd.get_value('SmTNode')
    >>>     edges.append(NetworkEdge(edge_id, f_node, t_node, edge_rd.get_geometry()))
    >>>     edge_rd.move_next()
    >>> edge_rd.close()
    >>> node_rd = network_dt.child_dataset.get_recordset()
    >>> while node_rd.has_next():
    >>>     node_id = node_rd.get_value('SmNodeID')
    >>>     nodes.append(NetworkNode(node_id, node_rd.get_geometry()))
    >>>     node_rd.move_next()
    >>> node_rd.close()
    >>>
    >>> tree_schema_result_2 = build_topological_schema(TopologicalTreeSchema(), edges, nodes, is_merge=True,
    >>>                                                 tolerance=1.0e-6, out_data=out_ds, out_dataset_name='SchemaRes')
    >>>

    :param schema_param: 拓扑逻辑图参数类对象
    :type schema_param: TopologicalHierarchicalSchema or TopologicalTreeSchema or TopologicalOrthogonalSchema
    :param network_dt_or_edges: 二维网络数据集或者虚拟网络弧段
    :type network_dt_or_edges: DatasetVector or list[NetworkEdge]
    :param network_nodes: 虚拟网络结点，当 :py:attr:`network_dt_or_edges` 为 list[NetworkEdge] 时，可以设置虚拟网络结点对象，以表达
                          完整的网络关系。
                          当不设置 network_nodes 时，可以单独使用 list[NetworkEdge] 同样能表达网络关系。且 NetworkEdge 可以不需要
                          网络弧段空间对象。
    :type network_nodes: list[NetworkNode]
    :param bool is_merge: 是否设置合并空间位置上重复的网络弧段和网络结点对象。网络关系中，如果存在空间位置上的重复弧段和重复结点， 如果设置此参
                          数为 True ，则会提取一份公共的弧段关系构建逻辑图，在构建的拓扑逻辑图也含有空间位置上的重复弧段和结点。如果设置此参数
                          为 False ，则计算拓扑逻辑图时对每条正确的网络拓扑关系都正常处理。
                          只有在设置了有效的 :py:attr:`network_nodes`时，is_merge 才有效。
    :param float tolerance: 节点容限，用于空间计算中节点对象比较。如果 :py:attr:`is_merge` 为 True 才有效
    :param out_data: 存储结果数据的数据源。当 :py:attr:`network_dt_or_edges` 不是网络数据集时，必须设置有效的结果数据源。
    :type out_data: Datasource
    :param str out_dataset_name: 结果数据集名称
    :return: 用于表示拓扑逻辑图的二维网络数据集
    :rtype: DatasetVector
    """
    if not isinstance(schema_param,
                      (TopologicalHierarchicalSchema, TopologicalTreeSchema, TopologicalOrthogonalSchema)):
        raise ValueError(
            'schema_param invalid, required TopologicalHierarchicalSchema, TopologicalTreeSchema or '
            'TopologicalOrthogonalSchema)')

    if isinstance(network_dt_or_edges, (list, tuple)):
        return _build_schema_from_network_relations(schema_param, network_dt_or_edges, network_nodes,
                                                    out_data, out_dataset_name, is_merge, tolerance)
    else:
        return _build_schema_from_network_dataset(schema_param, network_dt_or_edges, out_data, out_dataset_name)


def _build_schema_from_network_relations(schema_param, network_edges, network_nodes, out_data, out_dataset_name,
                                         is_merge, tolerance):
    java_network_nodes = []
    if isinstance(network_nodes, (list, tuple)):
        for item in network_nodes:
            if isinstance(item, NetworkNode):
                java_network_nodes.append(oj(item))

    is_have_network_nodes = False
    if java_network_nodes:
        is_have_network_nodes = True

    java_network_edges = []
    for item in network_edges:
        if isinstance(item, NetworkEdge):
            if is_have_network_nodes:
                java_network_edges.append(oj(item))
            else:
                java_network_edge_id = get_jvm().com.supermap.analyst.spatialanalyst.NetworkEdgeID(item.edge_id,
                                                                                                   item.from_node_id,
                                                                                                   item.to_node_id)
                java_network_edges.append(java_network_edge_id)
    if not java_network_edges:
        raise ValueError('have no valid NetworkEdges')

    out_datasource = get_output_datasource(out_data)
    if not isinstance(out_datasource, Datasource):
        raise ValueError('must set valid output Datasource')
    if out_dataset_name is None:
        dest_name = 'TopologicalSchema'
    else:
        dest_name = out_dataset_name
    dest_name = out_datasource.get_available_dataset_name(dest_name)

    try:
        java_schema = oj(schema_param)
        java_schema.setOutputDatasource(oj(out_datasource))
        java_schema.setOutputDatasetName(str(dest_name))
        if is_have_network_nodes:
            java_result = java_schema.build(
                to_java_array(java_network_edges, get_jvm().com.supermap.analyst.spatialanalyst.NetworkEdge),
                to_java_array(java_network_nodes, get_jvm().com.supermap.analyst.spatialanalyst.NetworkNode),
                bool(is_merge), float(tolerance))
        else:
            java_result = java_schema.build(
                to_java_array(java_network_edges, get_jvm().com.supermap.analyst.spatialanalyst.NetworkEdgeID))
    except:
        import traceback
        log_error(traceback.format_exc())
        java_result = None
    finally:
        if java_result is not None:
            result_dt = out_datasource[dest_name]
        else:
            result_dt = None
        if out_data is not None:
            return try_close_output_datasource(result_dt, out_datasource)
        else:
            return result_dt


def _build_schema_from_network_dataset(schema_param, network_dt, out_data, out_dataset_name):
    network_dt = get_input_dataset(network_dt)
    if not isinstance(network_dt, DatasetVector):
        raise ValueError('network_dt required DatasetVector Network')
    if network_dt.type is not DatasetType.NETWORK:
        raise ValueError('network_dt required DatasetVector Network')

    if out_data is not None:
        out_datasource = get_output_datasource(out_data)
    else:
        out_datasource = network_dt.datasource
    check_output_datasource(out_datasource)
    if out_dataset_name is None:
        dest_name = network_dt.name + '_schema'
    else:
        dest_name = out_dataset_name
    dest_name = out_datasource.get_available_dataset_name(dest_name)

    try:
        java_schema = oj(schema_param)
        java_schema.setOutputDatasource(oj(out_datasource))
        java_schema.setOutputDatasetName(str(dest_name))
        java_result = java_schema.build(oj(network_dt))
    except:
        import traceback
        log_error(traceback.format_exc())
        java_result = None
    finally:
        if java_result is not None:
            result_dt = out_datasource[dest_name]
        else:
            result_dt = None
        if out_data is not None:
            return try_close_output_datasource(result_dt, out_datasource)
        else:
            return result_dt
