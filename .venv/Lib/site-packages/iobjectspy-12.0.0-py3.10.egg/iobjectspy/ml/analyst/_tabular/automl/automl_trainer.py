# !/usr/bin/env python3
# coding=utf-8

import os
import pickle
from collections import OrderedDict

from ..automl.automl_data_loader import AutoMLDataloader
from ....toolkit._toolkit import save_config_to_yaml, get_config_from_yaml


class AutoMLTrainer:
    def __init__(self, output_model_path, output_model_name,mode='Explain',
                 algorithms=None,total_time_limit=3600, eval_metric='auto',config = None):
        from supervised.automl import AutoML
        self.config = config
        self.output_model_path = output_model_path
        self.output_model_name = output_model_name
        self.output_model_paths = os.path.join(output_model_path,output_model_name)
        self.isTraining = False

        if not algorithms is None:
            self.algorithms = algorithms
        else:
            self.algorithms = ['Decision Tree', 'Baseline', 'Linear', 'Random Forest', 'Extra Trees',
                               'LightGBM', 'Xgboost', 'CatBoost', 'Neural Network', 'Nearest Neighbors']

        explain_level = 1
        if mode == 'Explain':
            explain_level = 2

        if self.config is not None:
            self.train_config = get_config_from_yaml(self.config)
        else:
            self.train_config = None
        automl_params = {'ml_task': "auto",
                         'model_time_limit': None,
                         'train_ensemble': True,
                         'stack_models': "auto",
                         'validation_strategy': "auto",
                         'features_selection': "auto",
                         'start_random_models': "auto",
                         'hill_climbing_steps': "auto",
                         'top_models_to_improve': "auto",
                         'boost_on_errors': "auto",
                         'kmeans_features': "auto",
                         'verbose': 1,
                         'random_state': 1234}

        if self.train_config is not None:
           config_model_params = self.train_config.model.model_params.toDict()
           if config_model_params is not None:
               automl_params.update(config_model_params)
               if not isinstance(automl_params['model_time_limit'],int) and automl_params['model_time_limit'].lower() =="none":
                   automl_params['model_time_limit'] = None

        self.mlmodel = AutoML(results_path=self.output_model_paths, mode=mode, algorithms=self.algorithms,
                                    total_time_limit=total_time_limit, golden_features=False,
                                    explain_level=explain_level, eval_metric=eval_metric,**automl_params)

    def train(self, train_data_path, test_size=0.2):
        self.data_config = get_config_from_yaml(train_data_path)
        data_loader = AutoMLDataloader(train_data_path)
        train_x, test_x, train_y, test_y = data_loader.load(test_size=test_size, random_seed=None)
        train_y = train_y.flatten()
        self.test_x = test_x
        self.test_y = test_y.flatten()

        self.mlmodel.fit(train_x, train_y)

        score = self.mlmodel.score(test_x, test_y)
        score_format = '{}'.format(score)
        print('valdata_score: '+score_format)
        self.isTraining = True

        output_model_sdm = os.path.join(self.output_model_paths, self.output_model_name + '.sdm')
        output_model_file = os.path.join(self.output_model_paths, self.output_model_name + '.pkl')
        with open(output_model_file, 'wb') as f:
            pickle.dump(self.mlmodel, f)

        dict_model_sdm = OrderedDict({
            'model_type': 'mljar-supervised',
            'framework': 'mljar-supervised',
            'model_architecture': '',
            'model_categorys': '',
            'model_tag': 'standard',
            'best_model_name':self.mlmodel._best_model._name,
            'score':score_format,
            'model_paths': self.output_model_paths
        })
        save_config_to_yaml(dict_model_sdm, output_model_sdm)

        pass

    def score(self):
        """
        模型得分
        :returns 当为回归模型时，输出R2，当为分类模型时，输出 Accuracy 。
        """
        if self.isTraining:
            return self.mlmodel.score(self.test_x, self.test_y)
        else:
            raise Exception("This method is not available when the model is not Ttaining")