#!/usr/bin/env python3
# coding=utf-8
import os
import pandas as pd
import numpy as np
import tempfile
from tqdm import tqdm


class CreateGraphST_RegressionData(object):
    def __init__(self, input_data,
                 output_dir=None,
                 train_rate=0.7,
                 test_rate=0.2,
                 index_col="0"
                 ):
        self.input_data = input_data
        if output_dir is None or not(os.path.exists(output_dir)):
            print(
                "[WARNING] output_dir is None or not exists..." +
                "using temporal directory location")
            tmpdir = tempfile.mkdtemp()
            output_dir = tmpdir
        self.output_dir = output_dir
        self.train_rate = train_rate
        self.test_rate = test_rate

    def create_training_data(
        self,
        index_col="0",
        period_len=3,
        step_rows=12,
        period_steps=24,
        period_units="D", add_time_in_period=True
    ):
        print("[INFO] Creating training data ...")
        print(
            "[INFO] Using parameters:step_rows={step_rows},period_len={period_len}".format(
                step_rows=step_rows,
                period_len=period_len,
                period_units=period_units))
        input_df = self.input_data
        if isinstance(input_df, str):
            if os.path.exists(input_df):
                print("[INFO] Reading Input DataFrame ...")
                print(
                    "[INFO] Using column {index_col} for time index ...".format(
                        index_col=index_col))
                if index_col.isdigit():
                    index_col = int(index_col)
                input_df = pd.read_csv(input_df, index_col=index_col)
            else:
                print("[ERROR] File not exists!")
                raise ValueError
        if input_df is None:
            raise ValueError
        input_df.index = pd.to_datetime(input_df.index)
        print(input_df.index)
        period_rows = 0
        if period_units == 'D':
            period_rows = step_rows * period_steps
        else:
            raise NotImplementedError
        if period_rows == 0:
            raise ValueError
        x_offsets = np.sort(
            np.concatenate((np.arange(-(step_rows-1), 1, 1),))
        )
        y_offsets = np.sort(np.arange(1, (step_rows+1), 1))
        if period_len > 0:
            period_offsets = np.vstack(
                [y_offsets - period_rows * (pp + 1) for pp in range(period_len)])
            period_offsets = np.transpose(period_offsets, (1, 0)).flatten()
        else:
            period_offsets = np.array([])

        x, y = self._generate_graph_seq2seq2_io_data(
            input_df,
            x_offsets=x_offsets,
            period_offsets=period_offsets,
            y_offsets=y_offsets,
            step_rows=step_rows,
            period_len=period_len,
            period_steps=period_steps,
            add_time_in_period=add_time_in_period
        )
        print("x shape:", x.shape, ", y shape:", y.shape)
        num_samples = x.shape[0]
        num_test = round(num_samples * self.test_rate)
        num_train = round(num_samples * self.train_rate)
        num_val = num_samples - num_test - num_train

        x_train, y_train = x[:num_train], y[:num_train]
        x_val, y_val = (x[num_train: num_train + num_val],
                        y[num_train: num_train + num_val]
                        )
        x_test, y_test = x[-num_test:], y[-num_test:]

        for cat in ["train", "val", "test"]:
            _x, _y = locals()["x_" + cat], locals()["y_" + cat]
            print(cat, "x: ", _x.shape, "y:", _y.shape)
            np.savez_compressed(
                os.path.join(self.output_dir, "%s.npz" % cat),
                x=_x,
                y=_y,
                x_offsets=x_offsets.reshape(list(x_offsets.shape) + [1]),
                y_offsets=y_offsets.reshape(list(y_offsets.shape) + [1]),
            )

    def _generate_graph_seq2seq2_io_data(
            self,
            df, x_offsets, period_offsets, y_offsets,
            step_rows=12, period_len=3, period_steps=24, period_units="D",
            add_time_in_period=True):
        num_samples, num_nodes = df.shape
        data = np.expand_dims(df.values, axis=-1)
        data_list = [data]
        if add_time_in_period:
            print("datetime64[" + period_units + "]")
            time_inp = (df.index.values - df.index.values.astype(
                "datetime64[" + period_units + "]"))/np.timedelta64(1, period_units)
            time_in_period = np.tile(
                time_inp, [
                    1, num_nodes, 1]).transpose(
                (2, 1, 0))
            data_list.append(time_in_period)

        data = np.concatenate(data_list, axis=-1)
        x, y = [], []
        # t is the index of the last observation.
        period_rows = 0
        if period_units == 'D':
            period_rows = step_rows * period_steps
        else:
            raise NotImplementedError

        if period_rows == 0:
            raise ValueError
        if period_len <= 0 or period_offsets.size == 0:
            min_t = abs(min(x_offsets))
        else:
            min_t = int(period_len * period_rows)
            print('period_len={period_len}, period_rows={period_rows}'.format(
                      period_len=period_len, period_rows=period_rows))
        max_t = abs(num_samples - abs(max(y_offsets)))
        for t in tqdm(range(min_t, max_t)):
            if period_len <= 0 or period_offsets.size == 0:
                x_t = data[t + x_offsets, ...]
            else:
                x_t_r = data[t + x_offsets, ...]
                x_t_p = data[t + period_offsets, ...]
                x_t = np.vstack((x_t_r, x_t_p))
            y_t = data[t + y_offsets, ...]
            x.append(x_t)
            y.append(y_t)
        x = np.stack(x, axis=0)
        y = np.stack(y, axis=0)
        return x, y
