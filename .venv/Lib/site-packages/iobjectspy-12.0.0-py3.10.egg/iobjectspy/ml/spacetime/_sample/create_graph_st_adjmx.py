#!/usr/bin/env python3
# coding=utf-8
import os
import pandas as pd
import numpy as np
import queue as Q
import pickle
from math import sin, cos, sqrt, atan2, radians
from scipy import stats
import tempfile


class CreateGraphST_AdjMX(object):
    def __init__(self,  input_pts_coords=None,
                 output_dir=None
                 ):
        self.input_pts_coords = input_pts_coords
        # if output_dir is None or not(os.path.exists(output_dir)) :
        #     print("[WARNING] output_dir is None or not exists...using temporal directory location")
        #     tmpdir = tempfile.mkdtemp()
        #     output_dir = tmpdir
        self.output_dir = output_dir

    def create_adj_matrix_pkl(
        self,
        input_pts_coords,
        output_dir=None,
        id_col="0", long_col="1", lat_col="2",
        dist_file=None, DEBUG=0
    ):

        if input_pts_coords is not None:
            self.input_pts_coords = input_pts_coords

        if dist_file is not None:
            self.dist_file = dist_file

        if output_dir is not None:
            self.output_dir = output_dir

        if isinstance(output_dir,str):
            if not os.path.exists(output_dir):
                os.makedirs(output_dir)
        else:
            print("[ERROR] The type of Output dir is wrong!")

        if isinstance(input_pts_coords, str) and \
        os.path.exists(input_pts_coords):
            print(
                "[INFO] Loading input data {path} for computing adj mat".format(
                    path=input_pts_coords))
            sensor_info = pd.read_csv(input_pts_coords)
            print(
                "[INFO] Shape of Data {shape}".format(
                    shape=sensor_info.shape))

            sensor_name = []
            lat_list = []
            long_list = []
            dist_df = None

            if id_col.isdigit():
                sensor_id_list = sensor_info[sensor_info.columns[int(
                    id_col)]].tolist()
            else:
                sensor_id_list = sensor_info[id_col].tolist()

            if long_col.isdigit():
                long_list = sensor_info[sensor_info.columns
                                        [int(long_col)]].tolist()
            else:
                long_list = sensor_info[long_col].tolist()

            if lat_col.isdigit():
                lat_list = sensor_info[sensor_info.columns[int(
                    lat_col)]].tolist()
            else:
                lat_list = sensor_info[lat_col].tolist()
            if dist_file:
                dist_df = pd.read_csv(dist_file,
                                        dtype={'from': 'str', 'to': 'str'}
                                        )
            sensor_name2id, adj_mx = self._get_adjacency_matrix(
                sensor_id_list, lat_list, long_list, dist_df, 0.1, 2, DEBUG)
            pkl_outputpath = os.path.join(output_dir, 'adj_mat.pkl')
            print("[INFO] Writing adj matrix to {path}".format(
                path=pkl_outputpath
            ))
            if DEBUG:
                print(sensor_name)
                print(sensor_name2id)

            with open(pkl_outputpath, 'wb') as f:
                pickle.dump([sensor_name, sensor_name2id, adj_mx], f,
                            protocol=2
                            )
        else:
            print("[ERROR] Input file path Error!")
            print("[INFO] Value is {value}...".format(value=input_pts_coords))
        print("[INFO] Finishing generate adj matrix!")

    def _get_distance(self, lat_1, lng_1, lat_2, lng_2, DEBUG=0):
        # radius of earth in km
        R = 6373.0

        dlng = radians(lat_2) - radians(lat_1)
        dlat = radians(lng_2) - radians(lng_1)

        x = dlat*cos((lat_1+lat_2)*0.5)

        d = R * sqrt(x**2 + dlng**2)
        return d

    def _kNN(self, sensor_id_list, lat_list, long_list, id, k=2,
             DEBUG=0
             ):
        kNN_PQ = Q.PriorityQueue(maxsize=k)

        nearest_distance = np.inf
        nearest_id = -1
        for _id in sensor_id_list:
            if _id == id:
                continue
            dis = - self._get_distance(lat_list[id], long_list[id],
                                       lat_list[_id], long_list[_id],
                                       )
            if not kNN_PQ.full():
                kNN_PQ.put([dis, _id])
            else:
                temp_data = kNN_PQ.get()
                temp_dis = temp_data[0]
                temp_label = temp_data[1]
                if dis > temp_dis:
                    temp_dis = dis
                    temp_label = _id
                kNN_PQ.put([temp_dis, temp_label])
        return kNN_PQ

    def _get_adjacency_matrix(self,
                              sensor_id_list,
                              lat_list, long_list,
                              dist_df=None, dist_threshold=0.1,
                              k=2, DEBUG=0
                              ):
        sensor_num = len(sensor_id_list)
        dist_mx = np.zeros((sensor_num, sensor_num), dtype=np.float32)
        dist_mx[:] = np.inf
        sensor_name2id = {}
        # Construct the graph using KNN, add edge to k nearest neighors
        sensor_row_idx = list(range(len(sensor_id_list)))
        for idx, id in enumerate(sensor_id_list):
            sensor_name2id[str(id)] = idx

            if dist_df is None:
                knn_pq = self._kNN(sensor_row_idx,
                                   lat_list, long_list, idx, k,
                                   DEBUG)
                knn_list = knn_pq.queue
                for nei in knn_list:
                    dist_mx[idx, nei[1]] = 1
                    dist_mx[idx][idx] = 1

        if dist_df is not None:
            print("[INFO] Reading external distance files...")
            # Files cells in the matrix with distances.
            for row in dist_df.values:
                if str(int(row[0])) not in sensor_name2id or str(int(row[1])) not in sensor_name2id:
                    continue
                dist_mx[sensor_name2id[str(int(row[0]))],
                        sensor_name2id[str(int(row[1]))]] = row[2]
            # Calculates the standard deviation as theta.

            distances = dist_mx[~np.isinf(dist_mx)].flatten()
            std = distances.std()
            adj_mx = np.exp(-np.square(dist_mx / std))
            # Make the adjacent matrix symmetric by taking the max.
            # adj_mx = np.maximum.reduce([adj_mx, adj_mx.T])

            # Sets entries that lower than a distance threshold to zero for
            # sparsity
            adj_mx[adj_mx < dist_threshold] = 0

        if dist_df is None:
            adj_mx = dist_mx
        if DEBUG != 0:
            print("dist_mx=", stats.describe(dist_mx))
        return sensor_name2id, adj_mx
