import torch.nn as nn
from .modules import Flatten, Activation, CBAM
import torch
import torch.nn.functional as F
class SegmentationHead(nn.Sequential):

    def __init__(self, in_channels, out_channels, kernel_size=3, activation=None, upsampling=1):
        super(SegmentationHead, self).__init__()
        self.conv2d = nn.Conv2d(in_channels, out_channels, kernel_size=kernel_size, padding=kernel_size // 2)
        self.upsampling = nn.UpsamplingBilinear2d(scale_factor=upsampling) if upsampling > 1 else nn.Identity()
        self.activation = Activation(activation)
    def forward(self, x):
        x = self.conv2d(x)
        x = self.upsampling(x)
        x = self.activation(x)
        return x

class SegmentationHead_SiameCD_Distance(nn.Module):

    def __init__(self, in_channels, out_channels, kernel_size=3, activation=None, upsampling=1):
        super(SegmentationHead_SiameCD_Distance, self).__init__()
        self.upsampling = nn.UpsamplingBilinear2d(scale_factor=upsampling) if upsampling > 1 else nn.Identity()
        self.cbam0 = CBAM(in_channels, 8, 7)
        self.cbam1 = CBAM(in_channels, 8, 7)
    def forward(self, x):
        dist = F.pairwise_distance(self.cbam0(x[0]).permute(0, 2, 3, 1), self.cbam1(x[1]).permute(0, 2, 3, 1), keepdim=True)
        dist = dist.permute(0, 3, 1, 2).contiguous()
        dist = F.interpolate(dist, scale_factor=4, mode='bilinear', align_corners=True)#self.upsampling(dist)
        return dist

class SegmentationHead_SiameCD(nn.Module):

    def __init__(self, in_channels, out_channels, kernel_size=3, activation=None, upsampling=1):
        super(SegmentationHead_SiameCD, self).__init__()
        self.seg_head = nn.Sequential(
                nn.Conv2d(in_channels, in_channels, kernel_size=3, stride=1, padding=1),
                nn.BatchNorm2d(in_channels),
                nn.ReLU(),
                nn.Dropout2d(0.05),
                nn.Conv2d(in_channels, out_channels, kernel_size=1, stride=1, padding=0, bias=True)
            )
        self.upsampling = nn.UpsamplingBilinear2d(scale_factor=upsampling) if upsampling > 1 else nn.Identity()
        self.activation = Activation(activation)
    def forward(self, x):
        x = torch.abs(x[0] - x[1])
        x = self.seg_head(x)
        x = self.upsampling(x)
        x = self.activation(x)
        return x

class SegmentationHead_SiameConcatCD(nn.Module):
    def __init__(self, in_channels, out_channels, kernel_size=3, activation=None, upsampling=1):
        super(SegmentationHead_SiameConcatCD, self).__init__()
        self.seg_head = nn.Sequential(
                nn.Conv2d(in_channels*2, in_channels, kernel_size=kernel_size, stride=1, padding=kernel_size//2),
                nn.BatchNorm2d(in_channels),
                nn.ReLU(),
                nn.Conv2d(in_channels, in_channels, kernel_size=kernel_size, stride=1, padding=kernel_size//2),
                nn.BatchNorm2d(in_channels),
                nn.ReLU(),
                nn.Dropout2d(0.05),
                nn.Conv2d(in_channels, out_channels, kernel_size=1, stride=1, padding=0, bias=True)
            )
        self.upsampling = nn.UpsamplingBilinear2d(scale_factor=upsampling) if upsampling > 1 else nn.Identity()
        self.activation = Activation(activation)
    def forward(self, x):
        x = torch.cat(x, 1)
        x = self.seg_head(x)
        x = self.upsampling(x)
        x = self.activation(x)
        return x

class SegmentationHead_SiameAddCD(nn.Module):
    def __init__(self, in_channels, out_channels, kernel_size=3, activation=None, upsampling=1):
        super(SegmentationHead_SiameAddCD, self).__init__()
        self.seg_head = nn.Sequential(
                nn.Conv2d(in_channels, in_channels, kernel_size=kernel_size, stride=1, padding=kernel_size//2),
                nn.BatchNorm2d(in_channels),
                nn.ReLU(),
                nn.Conv2d(in_channels, in_channels, kernel_size=kernel_size, stride=1, padding=kernel_size//2),
                nn.BatchNorm2d(in_channels),
                nn.ReLU(),
                nn.Dropout2d(0.05),
                nn.Conv2d(in_channels, out_channels, kernel_size=1, stride=1, padding=0, bias=True)
            )
        self.upsampling = nn.UpsamplingBilinear2d(scale_factor=upsampling) if upsampling > 1 else nn.Identity()
        self.activation = Activation(activation)
    def forward(self, x):
        x = x[0] + x[1]
        x = self.seg_head(x)
        x = self.upsampling(x)
        x = self.activation(x)
        return x

class ClassificationHead(nn.Sequential):

    def __init__(self, in_channels, classes, pooling="avg", dropout=0.2, activation=None):
        if pooling not in ("max", "avg"):
            raise ValueError("Pooling should be one of ('max', 'avg'), got {}.".format(pooling))
        pool = nn.AdaptiveAvgPool2d(1) if pooling == 'avg' else nn.AdaptiveMaxPool2d(1)
        flatten = Flatten()
        dropout = nn.Dropout(p=dropout, inplace=True) if dropout else nn.Identity()
        linear = nn.Linear(in_channels, classes, bias=True)
        activation = Activation(activation)
        super().__init__(pool, flatten, dropout, linear, activation)

class SemanticInferenceHead(nn.Module):
    def __init__(self,):
        super(SemanticInferenceHead, self).__init__()
        self.linear = nn.Linear(1, 1, bias=True)
    def forward(self, x):
        mask_cls = F.softmax(x[-2], dim=-1)[..., :-1]      ### 和官网有误，  F.softmax(mask_cls, dim=-1)[...,:-1]
        mask_pred = x[-1].sigmoid()
        semseg = torch.einsum("bqc,bqhw->bchw", mask_cls, mask_pred)
        if len(x) == 3:
            return tuple((x[0], semseg))
        else:
            return semseg
