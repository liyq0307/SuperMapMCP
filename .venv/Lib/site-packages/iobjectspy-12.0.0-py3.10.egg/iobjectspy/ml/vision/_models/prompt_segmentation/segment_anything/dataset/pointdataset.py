import gc
import json
import os
import tempfile

import cv2
import numpy as np
import rasterio
import shapely
import torch
import tqdm
from rasterio.windows import Window
from shapely.geometry import Point
from tqdm import tqdm

from iobjectspy import (Datasource, open_datasource, raster_to_vector, import_tif, create_buffer, dissolve,
                        clip_vector, GeoRegion, Geometry, Rectangle)
from iobjectspy._jsuperpy.data._util import DatasetType
from ._base_.dataset import SamDataset
from .processor import Samprocessor
from ...segment_anything.utils import resolve_topo_overlaperror
from ...utils import (
    transform_image,
    comput_tile_corner_coor,
    pixel_dis2geo_dis,
    save_udbx_masks,
)


class SamPointDataset(SamDataset):
    def __init__(self, sam, datapath, promptdata, tilesize, offset, point_num, **kwargs):
        super().__init__(sam, datapath, promptdata, tilesize, offset)
        self.point_num = point_num
        self.sample_func = kwargs.get('sample_method')
        self.is_save_topo = kwargs.get('is_save_topo', False)
        self.save_intermediate_datasets = kwargs.get('save_intermediate_datasets', False)

        sam_input_image_size = sam.image_encoder.img_size
        self.processor = Samprocessor(sam_input_image_size, self.sample_func)

        self.sampling_data()

    def __len__(self):
        return len(self.samples)

    def __getitem__(self, idx):
        tile_item = self.samples[idx]
        tile_corner = comput_tile_corner_coor(self.ori_image_size, self.rectangle_size,
                                              self.tilesize, self.offset, tile_item)
        with rasterio.open(self.datapath) as src:
            window = Window(tile_corner[0], tile_corner[1], self.tilesize, self.tilesize)
            image = src.read(window=window)
            image_size = image.shape[1:]
            tile_rgb = transform_image(image)

        tile_promptdata = self.promptdata[tile_corner[1]:tile_corner[3], tile_corner[0]:tile_corner[2]]
        if tile_promptdata.shape != tile_rgb.shape[:2]:
            tile_promptdata = np.resize(tile_promptdata, tile_rgb.shape[:2])

        inputs = self.processor(tile_rgb, image_size,
                                tile_corner=tile_corner,
                                prompt=tile_promptdata,
                                point_num=self.point_num)
        inputs["tile_corner"] = torch.tensor(tile_corner)

        return inputs, idx

    def sampling_data(self):
        for i, tile_item in enumerate(tqdm(self.tile_list, desc='Sampling tile datas')):
            tile_corner = comput_tile_corner_coor(self.ori_image_size, self.rectangle_size,
                                                  self.tilesize, self.offset, tile_item)
            with rasterio.open(self.datapath) as src:
                window = Window(tile_corner[0], tile_corner[1], self.tilesize, self.tilesize)
                image = src.read(window=window)
                tile_rgb = transform_image(image)

            tile_promptdata = self.promptdata[tile_corner[1]:tile_corner[3], tile_corner[0]:tile_corner[2]]
            if tile_promptdata.shape != tile_rgb.shape[:2]:
                tile_promptdata = np.resize(tile_promptdata, tile_rgb.shape[:2])

            count_zero = np.sum(tile_promptdata == 0)
            if count_zero <= self.point_num:
                continue
            else:
                self.samples.append(tile_item)

    def _morph_process(self, binary_image, kernel, iterations=5):
        """
        对二值图像进行形态学处理

        Parameters:
            binary_image: 输入的二值图像
            kernel: 形态学操作的核
            iterations: 膨胀和腐蚀的迭代次数

        Returns:
            markers_binary: 处理后的二值图像
        """
        # 1. 噪声去除：使用开运算去除小的噪声点
        # 开运算 = 先腐蚀后膨胀，可以去除小的亮点
        opening = cv2.morphologyEx(binary_image, cv2.MORPH_OPEN, kernel, iterations=2)

        # 2. 确定背景区域：使用膨胀
        # 膨胀操作会扩大前景区域，未被扩大的区域可以确定为背景
        sure_bg = cv2.dilate(opening, kernel, iterations=iterations)

        # 3. 确定前景区域：使用腐蚀
        # 腐蚀操作会缩小前景区域，剩下的区域可以确定为前景
        sure_fg = cv2.erode(opening, kernel, iterations=iterations)

        # 4. 计算距离变换
        # 使用L1距离可以提高计算效率，对于二值图像来说足够了
        distance_transform = cv2.distanceTransform(binary_image, cv2.DIST_L1, 3)

        # 5. 根据距离变换结果确定前景区域
        # 使用自适应阈值：距离变换最大值的20%
        threshold = 0.2 * distance_transform.max()
        _, sure_dist_fg = cv2.threshold(distance_transform, threshold, 255, cv2.THRESH_BINARY)
        sure_dist_fg = np.uint8(sure_dist_fg)

        # 6. 标记连通区域
        # 获取前景区域的连通组件
        num_labels, markers = cv2.connectedComponents(sure_fg)

        # 7. 处理未知区域
        # 未知区域 = 背景区域 - 距离变换确定的前景区域
        unknown_dist = cv2.subtract(sure_bg, sure_dist_fg)

        # 8. 调整标记
        # 将所有标签值加1（保证背景不是0）
        markers = markers + 1
        # 将未知区域标记为0
        markers[unknown_dist == 255] = 0

        # 9. 生成最终的二值图像
        # 将标记为1的区域设为背景（0），其他区域设为前景（255）
        markers_binary = np.where(markers == 1, 0, 255).astype(np.uint8)

        return markers_binary

    def _morph_process_block(self, binary_image, kernel, iterations=5, block_size=1000):
        """
        使用分块处理的方式进行图像形态学处理
        """
        h, w = binary_image.shape
        pad_size = kernel.shape[0] * (iterations + 1)

        # 计算总块数用于进度显示
        total_blocks = ((h - 1) // block_size + 1) * ((w - 1) // block_size + 1)

        # 使用内存映射创建输出数组
        temp_file = os.path.join(tempfile.gettempdir(), 'temp_markers_binary.npy')
        markers_binary = np.memmap(temp_file, dtype=np.uint8, mode='w+', shape=(h, w))

        try:
            with tqdm(total=total_blocks, desc="Processing morphology") as pbar:
                for i in range(0, h, block_size):
                    for j in range(0, w, block_size):
                        i_end = min(i + block_size, h)
                        j_end = min(j + block_size, w)

                        # 获取带padding的块
                        i_start_pad = max(0, i - pad_size)
                        j_start_pad = max(0, j - pad_size)
                        i_end_pad = min(h, i_end + pad_size)
                        j_end_pad = min(w, j_end + pad_size)

                        current_block = binary_image[i_start_pad:i_end_pad, j_start_pad:j_end_pad]

                        block_binary = self._morph_process(current_block, kernel, iterations)

                        # 将结果复制到对应位置
                        pad_i_start = i - i_start_pad
                        pad_j_start = j - j_start_pad
                        result_slice = slice(pad_i_start, pad_i_start + (i_end - i)), \
                            slice(pad_j_start, pad_j_start + (j_end - j))

                        markers_binary[i:i_end, j:j_end] = block_binary[result_slice]

                        # 更新进度条
                        pbar.update(1)

                        # 清理内存
                        del block_binary

                    # 定期进行垃圾回收
                    if i % (block_size * 10) == 0:
                        gc.collect()

                # 确保数据写入磁盘
                markers_binary.flush()

            return markers_binary

        except Exception as e:
            # 清理临时文件
            if isinstance(markers_binary, np.memmap):
                try:
                    markers_binary._mmap.close()
                    os.unlink(temp_file)
                except Exception as e:
                    print("error message:", e)
                    pass

            raise e

    def _process_without_morph(self, binary_image, kernel):
        markers = cv2.morphologyEx(binary_image, cv2.MORPH_OPEN, kernel, iterations=2)
        markers_binary = np.where(markers == 0, 0, 255).astype(np.uint8)
        if markers_binary.shape != binary_image.shape:
            raise ValueError("Result shape does not match input shape")
        return markers_binary

    def _process_block_without_morph(self, binary_image, kernel, block_size=1000):
        """
        分块处理非形态学操作
        """
        h, w = binary_image.shape

        # 计算总块数用于进度显示
        total_blocks = ((h - 1) // block_size + 1) * ((w - 1) // block_size + 1)

        # 创建内存映射输出数组
        temp_file = os.path.join(tempfile.gettempdir(), 'temp_markers.npy')
        markers_binary = np.memmap(temp_file, dtype=np.uint8, mode='w+', shape=(h, w))

        try:
            with tqdm(total=total_blocks, desc="Processing blocks") as pbar:
                for i in range(0, h, block_size):
                    for j in range(0, w, block_size):
                        i_end = min(i + block_size, h)
                        j_end = min(j + block_size, w)

                        # 处理当前块
                        block = binary_image[i:i_end, j:j_end]
                        markers_block = cv2.morphologyEx(block, cv2.MORPH_OPEN, kernel, iterations=2)

                        # 直接在块上进行操作并写入结果
                        markers_binary[i:i_end, j:j_end] = np.where(
                            markers_block == 0,
                            np.uint8(0),
                            np.uint8(255)
                        )

                        # 更新进度条
                        pbar.update(1)

                        # 清理内存
                        del block, markers_block

                    # 定期进行垃圾回收
                    if i % (block_size * 10) == 0:
                        gc.collect()

                markers_binary.flush()
                return markers_binary

        except Exception as e:
            # 清理临时文件
            if isinstance(markers_binary, np.memmap):
                temp_path = markers_binary.filename
                del markers_binary
                try:
                    os.unlink(temp_path)
                except Exception as cleanup_error:
                    print(f"Error during cleanup: {cleanup_error}")
                    pass
            print(f"Error during processing: {e}")
            raise e

    def _create_morphological_kernel(self, kernel_size):
        """创建形态学操作的核"""
        return cv2.getStructuringElement(cv2.MORPH_RECT, (kernel_size, kernel_size))

    def _process_binary_image(self, binary_image, kernel, morph_process, iterations):
        """处理二值图像"""
        if morph_process:
            try:
                markers_binary = self._morph_process(binary_image, kernel, iterations=iterations)
            except cv2.error as e:
                markers_binary = self._morph_process_block(binary_image, kernel, iterations=iterations, block_size=1000)
        else:
            try:
                markers_binary = self._process_without_morph(binary_image, kernel)
            except Exception as e:
                markers_binary = self._process_block_without_morph(binary_image, kernel, block_size=1024)

        return markers_binary

    def _save_temp_tiff(self, markers_binary, profile):
        """保存临时TIFF文件"""
        with tempfile.NamedTemporaryFile(suffix='.tif', delete=False) as temp_file:
            temp_tif_path = temp_file.name
            with rasterio.open(temp_tif_path, 'w', **profile) as dst:
                dst.write(markers_binary, 1)
        return temp_tif_path

    def _get_datasource(self, outpath):
        """获取数据源"""
        if isinstance(outpath, str):
            return open_datasource(outpath)
        elif isinstance(outpath, Datasource):
            return outpath
        raise TypeError('Only support str and Datasource types.')

    def _calculate_geo_distance(self, profile, iterations):
        """计算地理距离"""
        resolution = profile.data['transform'][0]
        if self.coordinate == 'geographic':
            return pixel_dis2geo_dis(resolution, iterations)

        return iterations * resolution

    def _process_vector_data(self, ds_, temp_r2v, src_bounds, outname,
                             morph_process, geo_dis, resolution):
        """处理矢量数据"""
        clip_region = GeoRegion(Rectangle(src_bounds.left, src_bounds.bottom,
                                          src_bounds.right, src_bounds.top))

        if morph_process:
            ds_vector = dissolve(temp_r2v, 'SINGLE', 'SmUserID',
                                 tolerance=resolution)
            buffer_vector = create_buffer(ds_vector, geo_dis, geo_dis,
                                          unit='Meter', segment=4,
                                          out_data=ds_,
                                          out_dataset_name=outname + '_buffer_after')
            clip_vectordata = clip_vector(buffer_vector,
                                          clip_region=clip_region,
                                          is_erase_source=False,
                                          out_dataset_name=outname)
            ds_.delete(ds_vector.name)
            ds_.delete(buffer_vector.name)
        else:
            clip_vectordata = clip_vector(temp_r2v,
                                          clip_region=clip_region,
                                          is_erase_source=False,
                                          out_dataset_name=outname)

        return clip_vectordata

    def _save_sample_points(self, ds_, sample_points_list, outname):
        """保存采样点"""
        points = np.concatenate(sample_points_list, axis=0).reshape(-1, 2)
        points_process = []

        for x, y in tqdm(points, desc='Transform point...', leave=False):
            point_ = self.affine_transform * (x, y)
            point = Point(point_)
            region_geojson = json.dumps(shapely.geometry.mapping(point))
            region_shp = Geometry.from_geojson(region_geojson)
            points_process.append(region_shp)

        save_udbx_masks(ds_, outname + "_sample", points_process, "POINT")

    def write2dataset(self, sample_points_list, binary_image, outpath, outname,
                      src_bounds, profile, morph_process, morph_process_kernel,
                      iterations=5):
        """主方法"""
        # 1. 创建核并处理图像
        kernel = self._create_morphological_kernel(morph_process_kernel if morph_process_kernel == 5 else 3)
        markers_binary = self._process_binary_image(binary_image, kernel, morph_process, iterations)

        # 2. 保存临时文件
        temp_tif_path = self._save_temp_tiff(markers_binary, profile)
        ds_ = self._get_datasource(outpath)

        # 3. 导入TIF并转换为矢量
        ds_tif = import_tif(temp_tif_path, outpath, out_dataset_name=outname + '_raster')[0]
        os.remove(temp_tif_path)

        ds_tif_ = ds_.get_dataset(ds_tif)
        temp_r2v = raster_to_vector(ds_tif_, 'grid_value',
                                    out_dataset_type=DatasetType.REGION,
                                    back_or_no_value=0, out_data=outpath,
                                    out_dataset_name=outname + '_buffer_before')

        # 4. 计算地理距离并处理矢量数据
        geo_dis = self._calculate_geo_distance(profile, iterations)
        clip_vectordata = self._process_vector_data(ds_, temp_r2v, src_bounds,
                                                    outname, morph_process,
                                                    geo_dis, profile.data['transform'][0])

        # 5. 处理中间结果
        if self.save_intermediate_datasets:
            self._save_sample_points(ds_, sample_points_list, outname)
        else:
            ds_.delete(ds_tif)
            ds_.delete(temp_r2v.name)

        # 6. 解决拓扑错误
        topo_result = resolve_topo_overlaperror(ds_, clip_vectordata, profile.data['transform'][0])
        if not self.is_save_topo:
            ds_.delete(topo_result.name)

        return clip_vectordata.name
