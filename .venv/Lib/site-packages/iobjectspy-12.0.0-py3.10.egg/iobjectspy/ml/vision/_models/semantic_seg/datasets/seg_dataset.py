import os
import warnings

import cv2
import numpy as np
import rasterio
from PIL import Image

from . import transform
from .base_dataset import BaseDataset


def list_xy_file_from_csv(csv_path):
    """
    通过txt文件列出image，mask所有文件完整路径
    :param csv_path: 文件名字csv路径
    :return:
    """
    x_filenames = []
    y_filenames = []
    with open(csv_path, 'r', encoding='utf-8') as f:
        for line in f:
            files = line.strip().split(',')
            x_filenames.append(files[0])
            y_filenames.append(files[1])
    return x_filenames, y_filenames


class SegDataset(BaseDataset):
    """CamVid Dataset. Read images, apply augmentation and preprocessing transformations.

    Args:
        images_dir (str): path to images folder
        masks_dir (str): path to segmentation masks folder
        class_values (list): values of classes to extract from segmentation mask
        augmentation (albumentations.Compose): data transfromation pipeline
            (e.g. flip, scale, etc.)
        preprocessing (albumentations.Compose): data preprocessing
            (e.g. noralization, shape manipulation, etc.)

    """

    def __init__(
            self,
            sda_path,
            data_split='train',
            augmentation=True,
            train_size=None,
            mean=[0.485, 0.456, 0.406],
            std=[0.229, 0.224, 0.225],
            ignore_label=255,
            **kwargs
    ):
        super().__init__(sda_path, data_split, augmentation,
                         train_size, mean, std, ignore_label, **kwargs)

    def load_data(self):
        valid_splits = {'train', 'val', 'trainval'}

        if self.data_split not in valid_splits:
            raise ValueError(f"Invalid data_split. Expected one of: {valid_splits}")

        csv_path = os.path.join(self.base_dir, 'csv_path', f'{self.data_split}.csv')
        self.image_paths, self.mask_paths = list_xy_file_from_csv(csv_path)

    def compose_transforms(self):
        if self.augmentation:
            if self.aug_offline:
                transforms_pipline = transform.Compose([
                    transform.Resize(scale_range=[0.5, 2.0]),
                    transform.RandomCrop(self.train_size),
                    transform.PhotoMetricDistortion(),
                    transform.Normalize(mean=self.mean, std=self.std),
                    transform.ToTensor(),
                    transform.Padding(self.train_size,
                                      ignore_label=self.ignore_label,
                                      data_type='tensor')])
            else:
                transforms_pipline = transform.Compose([
                    transform.Resize(scale_range=[0.5, 2.0]),
                    transform.RandomCrop(self.train_size),
                    transform.RandomHorizontalFlip(0.5),
                    transform.RandomVerticalFlip(0.5),
                    # transform.RandomTranspose(0.5),
                    transform.PhotoMetricDistortion(),
                    transform.RandomRotation90(0.5),
                    transform.RandomGaussianBlur(0.2),
                    # transform.RandomRotation(0.5, mean=mean, angle_upper=15, ignore_label=ignore_label),
                    transform.RandomRotationMirror(0.3, angle_upper=15),
                    transform.Normalize(mean=self.mean, std=self.std),
                    transform.ToTensor(),
                    transform.Padding(self.train_size,
                                      ignore_label=self.ignore_label,
                                      data_type='tensor')])
        else:
            transforms_pipline = transform.Compose([
                transform.Resize_val(self.train_size),
                transform.Normalize(mean=self.mean, std=self.std),
                transform.ToTensor(),
                transform.Padding(self.train_size,
                                  ignore_label=self.ignore_label,
                                  data_type='tensor')])
        return transforms_pipline

    def __getitem__(self, idx):
        image_path = self.image_paths[idx]
        mask_path = self.mask_paths[idx]
        # read data
        if image_path.endswith(('tif', 'img')):
            with warnings.catch_warnings():
                warnings.simplefilter("ignore")
                image = rasterio.open(image_path).read()[:self.x_bandnum, ...]
            image = np.transpose(image, (1, 2, 0))
            if self.x_bandnum == 3:
                image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)
        else:
            image = cv2.imdecode(np.fromfile(image_path, dtype=np.uint8), -1)[:, :, 0:3]

        mask = np.array(Image.open(mask_path)) \
            if mask_path.strip().endswith('png') else cv2.imread(mask_path, 0)
        image = [image]
        image, mask = self.transform(image, mask)

        return image[0], mask

    def __len__(self):
        return len(self.image_paths)
