#!/usr/bin/env python
# encoding: utf-8

import os
import glob
import yaml
import torch
import numpy as np
from mmengine.config import Config
from mmdet.apis import DetInferencer, init_detector, inference_detector
from mmrotate.utils import register_all_modules
from mmrotate.structures.bbox.box_converters import rbox2qbox
from iobjectspy.ml.vision._models.object_detection._torch_models.ob_inference_base import ODEstimation
from iobjectspy.ml.vision._models.instance_segmentation._torch_models.inference_mmdet import AsyncMmdetEstimation
"""
影像数据旋转框目标检测
"""


class MmrotateEstimation(ODEstimation):
    def load_model(self):
        # register_all_modules()
        with open(self.config, encoding='utf-8') as f:
            config_dict = yaml.load(f, Loader=yaml.FullLoader)

        self.class_names = [str(i) for i in config_dict['model']['categorys']]
        self.tile_size = config_dict['model']['blocksize']
        self.tile_offset_size = config_dict['model']['tile_offset']
        self.development_kit = config_dict['development_kit']

        model_name = os.path.basename(self.config).split('.')[0] + '.pth'
        model_name = os.path.abspath(os.path.join(self.config, os.path.pardir, model_name))

        base_dir = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
        total_config_path_new = os.path.join(base_dir, 'object_detection', '_mmdet', "configs")
        mm_config_path = os.path.join(total_config_path_new, config_dict['model_architecture'],
                                      config_dict['config_file'] + '.py')

        cfg = Config.fromfile(mm_config_path)
        cfg.model.test_cfg.rcnn.score_thr = self.score_thresh
        cfg.model.test_cfg.rcnn.nms.iou_threshold = self.nms_thresh
        cfg.model.roi_head.bbox_head[0].num_classes = len(self.class_names)
        cfg.model.roi_head.bbox_head[1].num_classes = len(self.class_names)

        if len(self.gpus) > 1:
            self.inferencer = AsyncMmdetEstimation(cfg, model_name, self.device)
        else:
            self.inferencer = init_detector(cfg, model_name, palette='coco', device=self.device)


    def return_inference_result(self, ds, all_boxes, block_xmin, block_ymin, block, infer_region):

        if len(self.gpus) > 1:
            results_origin = self.inferencer(block)
        else:
            results_origin = inference_detector(self.inferencer, block)
            # self.draw_and_save_rotated_boxes(block, results_origin.pred_instances.bboxes.cpu(),
            #                                  f'D:/TestExperiment/mmrotate/middle_results/temp{self.i}.png')
            # self.i += 1
        all_boxes = self._det2str(results_origin, block_xmin, block_ymin, infer_region)

        return all_boxes

    def _det2str(self, results_origin, block_xmin, block_ymin, infer_region):
        results_convert = []
        if hasattr(results_origin, 'pred_instances'):
            results_convert_bboxes_rbox = (results_origin.pred_instances.bboxes.cpu()).tolist()
            results_convert_bboxes_qbox = (rbox2qbox(results_origin.pred_instances.bboxes.cpu())).tolist()
            results_convert_labels = (results_origin.pred_instances.labels.cpu()).tolist()
            results_convert_scores = (results_origin.pred_instances.scores.cpu()).tolist()
        else:
            results_convert_bboxes_rbox = results_origin['predictions'][0]['bboxes']
            results_convert_bboxes_qbox = (rbox2qbox(torch.tensor(results_origin['predictions'][0]['bboxes']))).tolist()
            results_convert_scores = results_origin['predictions'][0]['scores']
            results_convert_labels = results_origin['predictions'][0]['labels']
        if len(results_convert_labels) != 0:
            if infer_region is None:
                for i in range(len(results_convert_labels)):
                    result_temp = []
                    bbox = results_convert_bboxes_qbox[i]
                    bbox = [bbox[0]+block_xmin, bbox[1]+block_ymin,
                            bbox[2]+block_xmin, bbox[3]+block_ymin,
                            bbox[4]+block_xmin, bbox[5]+block_ymin,
                            bbox[6]+block_xmin, bbox[7]+block_ymin]
                    score = results_convert_scores[i]
                    label = results_convert_labels[i]
                    label2name = self.class_names[label]
                    result_temp.append(bbox)
                    result_temp.append(score)
                    result_temp.append(label2name)
                    results_convert.append(result_temp)
            else:
                for i in range(len(results_convert_labels)):
                    result_temp = []
                    bbox = results_convert_bboxes_rbox[i]
                    bbox[0], bbox[1] = bbox[0]+block_xmin, bbox[1]+block_ymin,

                    score = results_convert_scores[i]
                    label = results_convert_labels[i]
                    label2name = self.class_names[label]
                    result_temp.append(bbox)
                    result_temp.append(score)
                    result_temp.append(label2name)
                    results_convert.append(result_temp)
        return results_convert

    def draw_and_save_rotated_boxes(self, img_array, bbox_tensor, output_path):
        from PIL import Image, ImageDraw
        import math
        """
        在图像上绘制旋转框并保存到本地。

        参数:
        img_array (np.ndarray): 图像数组，维度为whc。
        bbox_tensor (torch.Tensor): 旋转框信息张量，维度为nums x 5。
        output_path (str): 输出图像的路径。

        返回:
        None
        """
        # 将PyTorch张量转换为NumPy数组
        bbox_array = bbox_tensor.numpy()

        # 将NumPy数组转换为PIL图像
        img_pil = Image.fromarray(img_array)

        # 创建一个ImageDraw对象
        draw = ImageDraw.Draw(img_pil)

        # 遍历每个旋转框
        for box in bbox_array:
            x, y, w, h, angle = box
            angle_rad = math.radians(angle)  # 将角度从度转换为弧度

            # 计算框的四个角点
            corners = [
                (-w / 2, -h / 2),
                (w / 2, -h / 2),
                (w / 2, h / 2),
                (-w / 2, h / 2)
            ]

            # 将角点平移到中心点位置，并旋转
            rotated_corners = []
            for corner in corners:
                new_x = x + math.cos(angle_rad) * corner[0] - math.sin(angle_rad) * corner[1]
                new_y = y + math.sin(angle_rad) * corner[0] + math.cos(angle_rad) * corner[1]
                rotated_corners.append((new_x, new_y))

            # 绘制旋转框
            draw.polygon(rotated_corners, fill=None, outline=(255, 0, 0), width=2)

        # 保存图片到本地
        img_pil.save(output_path)

        print(f"Image saved to {output_path}")