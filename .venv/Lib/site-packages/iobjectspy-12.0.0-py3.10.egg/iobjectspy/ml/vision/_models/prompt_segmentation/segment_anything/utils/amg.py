# Copyright (c) Meta Platforms, Inc. and affiliates.
# All rights reserved.

# This source code is licensed under the license found in the
# LICENSE file in the root directory of this source tree.

from copy import deepcopy
from typing import Any, Dict, ItemsView, List

import numpy as np
import torch


class BatchMaskData:
    """
    A structure for storing masks and their related data in batched format.
    Implements basic filtering and concatenation.
    """

    def __init__(self, **kwargs) -> None:
        for v in kwargs.values():
            assert isinstance(
                v, (list, np.ndarray, torch.Tensor)
            ), "MaskData only supports list, numpy arrays, and torch tensors."
        if len(kwargs.values()) == 0:
            self._stats = dict(**kwargs)
        else:
            # idx = kwargs["image_idx"]
            bs = kwargs["masks"].shape[0]
            # masks = {int(idx[b]): kwargs["masks"][b:b+1, :, :, :] for b in range(bs)}
            masks = {b: kwargs["masks"][b:b + 1, :, :, :] for b in range(bs)}
            iou_preds = {b: kwargs["iou_preds"][b:b + 1, :] for b in range(bs)}
            self._stats = dict(masks=masks, iou_preds=iou_preds)

    def __setitem__(self, key: str, item: Any) -> None:
        assert isinstance(
            item, (list, dict, np.ndarray, torch.Tensor)
        ), "MaskData only supports list, dict, numpy arrays, and torch tensors."
        self._stats[key] = item

    def __delitem__(self, key: str) -> None:
        del self._stats[key]

    def __getitem__(self, key: str) -> Any:
        return self._stats[key]

    def items(self) -> ItemsView[str, Any]:
        return self._stats.items()

    def filter(self, keep: torch.Tensor) -> None:
        for k, v in self._stats.items():
            for k_, v_ in v.items():
                if v_ is None:
                    self._stats[k][k_] = None
                elif isinstance(v_, torch.Tensor):
                    self._stats[k][k_] = v_[torch.as_tensor(keep[k_], device=v_.device)]
                elif isinstance(v_, np.ndarray):
                    self._stats[k][k_] = v_[keep[k_].detach().cpu().numpy()]
                elif isinstance(v_, list) and keep[k_].dtype == torch.bool:
                    self._stats[k][k_] = [a for i, a in enumerate(v) if keep[k_][i]]
                elif isinstance(v_, list):
                    self._stats[k][k_] = [v_[i] for i in keep[k_]]
                else:
                    raise TypeError(f"BatchMaskData key {k} has an unsupported type {type(v)}.")

    def cat(self, new_stats: "BatchMaskData") -> None:
        for k, v in new_stats.items():
            if k not in self._stats or self._stats[k] is None:
                self._stats[k] = deepcopy(v)
            elif isinstance(v, torch.Tensor):
                self._stats[k] = torch.cat([self._stats[k], v], dim=0)
            elif isinstance(v, np.ndarray):
                self._stats[k] = np.concatenate([self._stats[k], v], axis=0)
            elif isinstance(v, list):
                self._stats[k] = self._stats[k] + deepcopy(v)
            elif isinstance(v, dict):
                for kk, vv in v.items():
                    self._stats[k][kk] = torch.cat((self._stats[k][kk], deepcopy(vv)), dim=0)
            else:
                raise TypeError(f"MaskData key {k} has an unsupported type {type(v)}.")

    def to_numpy(self) -> None:
        for k, v in self._stats.items():
            if isinstance(v, torch.Tensor):
                self._stats[k] = v.detach().cpu().numpy()


def mask_to_rle_pytorch(tensor: dict or torch.Tensor) -> List[Dict[str, Any]]:
    """
    Encodes masks to an uncompressed RLE, in the format expected by
    pycoco tools.
    """
    # Put in fortran order and flatten h,w
    if isinstance(tensor, torch.Tensor):
        b, h, w = tensor.shape
        tensor = tensor.permute(0, 2, 1).flatten(1)

        # Compute change indices
        diff = tensor[:, 1:] ^ tensor[:, :-1]
        change_indices = diff.nonzero()

        # Encode run length
        out = []
        for i in range(b):
            cur_idxs = change_indices[change_indices[:, 0] == i, 1]
            cur_idxs = torch.cat(
                [
                    torch.tensor([0], dtype=cur_idxs.dtype, device=cur_idxs.device),
                    cur_idxs + 1,
                    torch.tensor([h * w], dtype=cur_idxs.dtype, device=cur_idxs.device),
                ]
            )
            btw_idxs = cur_idxs[1:] - cur_idxs[:-1]
            counts = [] if tensor[i, 0] == 0 else [0]
            counts.extend(btw_idxs.detach().cpu().tolist())
            out.append({"size": [h, w], "counts": counts})
    elif isinstance(tensor, dict):
        out = dict()
        for k, tensor_ in tensor.items():
            out[k] = []
            b, h, w = tensor_.shape
            tensor_ = tensor_.permute(0, 2, 1).flatten(1)

            # Compute change indices
            diff = tensor_[:, 1:] ^ tensor_[:, :-1]
            change_indices = diff.nonzero()

            # Encode run length
            for i in range(b):
                cur_idxs = change_indices[change_indices[:, 0] == i, 1]
                cur_idxs = torch.cat(
                    [
                        torch.tensor([0], dtype=cur_idxs.dtype, device=cur_idxs.device),
                        cur_idxs + 1,
                        torch.tensor([h * w], dtype=cur_idxs.dtype, device=cur_idxs.device),
                    ]
                )
                btw_idxs = cur_idxs[1:] - cur_idxs[:-1]
                counts = [] if tensor_[i, 0] == 0 else [0]
                counts.extend(btw_idxs.detach().cpu().tolist())
                out[k].append({"size": [h, w], "counts": counts})
    return out


def rle_to_mask(rle: Dict[str, Any]) -> np.ndarray:
    """Compute a binary mask from an uncompressed RLE."""
    h, w = rle["size"]
    mask = np.empty(h * w, dtype=bool)
    idx = 0
    parity = False
    for count in rle["counts"]:
        mask[idx: idx + count] = parity
        idx += count
        parity ^= True
    mask = mask.reshape(w, h)
    return mask.transpose()  # Put in C order


def batch_calculate_stability_score(
        masks, mask_threshold: float, threshold_offset: float
) -> torch.Tensor:
    """
    Computes the stability score for a batch of masks. The stability
    score is the IoU between the binary masks obtained by thresholding
    the predicted mask logits at high and low values.
    """
    # One mask is always contained inside the other.
    # Save memory by preventing unnecessary cast to torch.int64
    keep_mask = {}
    for k, v in masks.items():
        intersections = (
            (v > (mask_threshold + threshold_offset))
            .sum(-1, dtype=torch.int16)
            .sum(-1, dtype=torch.int32)
        )
        unions = (
            (v > (mask_threshold - threshold_offset))
            .sum(-1, dtype=torch.int16)
            .sum(-1, dtype=torch.int32)
        )
        keep_mask[k] = intersections / unions
    return keep_mask


def build_point_grid(n_per_side: int) -> np.ndarray:
    """Generates a 2D grid of points evenly spaced in [0,1]x[0,1]."""
    offset = 1 / (2 * n_per_side)
    points_one_side = np.linspace(offset, 1 - offset, n_per_side)
    points_x = np.tile(points_one_side[None, :], (n_per_side, 1))
    points_y = np.tile(points_one_side[:, None], (1, n_per_side))
    points = np.stack([points_x, points_y], axis=-1).reshape(-1, 2)
    return points


def batchedimage_mask_to_box(masks: torch.Tensor) -> torch.Tensor:
    """
    Calculates boxes in XYXY format around masks. Return [0,0,0,0] for
    an empty mask. For input shape C1xC2x...xHxW, the output shape is C1xC2x...x4.
    """
    # torch.max below raises an error on empty inputs, just skip in this case
    boxes = dict()
    for k, v_masks in masks.items():
        if torch.numel(v_masks) == 0:
            boxes[k] = torch.zeros(*v_masks.shape[:-2], 4, device=v_masks.device)
            continue
        # Normalize shape to CxHxW
        shape = v_masks.shape
        h, w = shape[-2:]
        if len(shape) > 2:
            v_masks = v_masks.flatten(0, -3)
        else:
            v_masks = v_masks.unsqueeze(0)

        # Get top and bottom edges
        in_height, _ = torch.max(v_masks, dim=-1)
        in_height_coords = in_height * torch.arange(h, device=in_height.device)[None, :]
        bottom_edges, _ = torch.max(in_height_coords, dim=-1)
        in_height_coords = in_height_coords + h * (~in_height)
        top_edges, _ = torch.min(in_height_coords, dim=-1)

        # Get left and right edges
        in_width, _ = torch.max(v_masks, dim=-2)
        in_width_coords = in_width * torch.arange(w, device=in_width.device)[None, :]
        right_edges, _ = torch.max(in_width_coords, dim=-1)
        in_width_coords = in_width_coords + w * (~in_width)
        left_edges, _ = torch.min(in_width_coords, dim=-1)

        # If the mask is empty the right edge will be to the left of the left edge.
        # Replace these boxes with [0, 0, 0, 0]
        empty_filter = (right_edges < left_edges) | (bottom_edges < top_edges)
        out = torch.stack([left_edges, top_edges, right_edges, bottom_edges], dim=-1)
        out = out * (~empty_filter).unsqueeze(-1)

        # Return to original shape
        if len(shape) > 2:
            boxes[k] = out.reshape(*shape[:-2], 4)
        else:
            boxes[k] = out[0]

    return boxes


def uncrop_boxes_xyxy(boxes: torch.Tensor, crop_box: List[int]) -> torch.Tensor:
    x0, y0, _, _ = crop_box
    offset = torch.tensor([[x0, y0, x0, y0]], device=boxes.device)
    # Check if boxes has a channel dimension
    if len(boxes.shape) == 3:
        offset = offset.unsqueeze(1)
    return boxes + offset


def batch_is_box_near_tile_edge(
        boxes, crop_box: List[int], orig_box: List[int], atol: float = 20.0
) -> torch.Tensor:
    """Filter masks at the edge of a crop."""
    keep_mask = {}
    for k, boxe in boxes.items():
        crop_box_torch = torch.as_tensor(crop_box, dtype=torch.float, device=boxe.device)
        orig_box_torch = torch.as_tensor(orig_box, dtype=torch.float, device=boxe.device)
        boxe = uncrop_boxes_xyxy(boxe, crop_box).float()
        near_crop_edge = torch.isclose(boxe, crop_box_torch[None, :], atol=atol, rtol=0)
        near_image_edge = torch.isclose(boxe, orig_box_torch[None, :], atol=atol, rtol=0)
        near_crop_edge = torch.logical_and(near_crop_edge, ~near_image_edge)
        keep_mask[k] = ~torch.any(near_crop_edge, dim=1)
    return keep_mask
