import torch
from . import initialization as init

class SegmentationModel(torch.nn.Module):

    def initialize(self):
        # if not self.siame_encoder:
        #     init.initialize_decoder(self.decoder)
        #     init.initialize_head(self.segmentation_head)
        if self.classification_head is not None:
            init.initialize_head(self.classification_head)
    def forward(self, x, y=None):
        """Sequentially pass `x` trough model`s encoder, decoder and heads"""
        return self.base_forward(x, y)
    def base_forward(self, x, y):
        """Sequentially pass `x` trough model`s encoder, decoder and heads"""
        if self.siame_encoder:
            if not (isinstance(x, list) or isinstance(x, tuple)):
                x = torch.chunk(x, 2, 1)
            features1 = self.encoder(x[0])
            features2 = self.encoder(x[1])
            features = [features1[-4:], features2[-4:]]
            out = self.decoder(*features)
            out = self.segmentation_head(out)
        else:
            features = list(self.encoder(x))
            if not y == None:
                features[0] = y
            decoder_output = self.decoder(*features)
            out = self.segmentation_head(decoder_output)
            if self.classification_head is not None:
                labels = self.classification_head(features[-1])
                return out, labels
        return out


    def predict(self, x):
        """Inference method. Switch model to `eval` mode, call `.forward(x)` with `torch.no_grad()`

        Args:
            x: 4D torch tensor with shape (batch_size, channels, height, width)

        Return:
            prediction: 4D torch tensor with shape (batch_size, classes, height, width)

        """
        if self.training:
            self.eval()

        with torch.no_grad():
            x = self.forward(x)

        return x

