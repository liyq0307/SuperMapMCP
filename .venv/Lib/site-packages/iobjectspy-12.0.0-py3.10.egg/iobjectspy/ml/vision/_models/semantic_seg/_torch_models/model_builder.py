"""
xxx_torch 调用的实例化网络方法
"""


def build_torch_seg_model(in_channels, classes, backbone_name='vgg19', encoder_weights='imagenet', net_type='unet',
                          activation=None, head_merge_method="subtract", **kwargs):
    """
    :param in_channels: 输入图像通道数
    :param classes: 类别数量
    :param backbone_name: 主干网络 vgg19 resnet18 resnet50 resnext50
    :param encoder_weights:  str imagenet
    :param net_type:  暂时只支持fpn,deeplabv3plus
    :param activation:
    :param head_merge_method:
    :return: pytorch.model
    """

    if net_type == 'fpn':
        from .fpn import FPN
        model = FPN(encoder_name=backbone_name, in_channels=in_channels, classes=classes,
                    encoder_weights=encoder_weights, activation=activation)
    elif net_type == 'upernet':
        from .upernet import UPerNet
        model = UPerNet(encoder_name=backbone_name, in_channels=in_channels, classes=classes,
                        encoder_weights=encoder_weights, activation=activation)
    elif net_type == 'deeplabv3plus':
        from .deeplabv3p import DeepLabV3Plus
        model = DeepLabV3Plus(encoder_name=backbone_name, encoder_weights=encoder_weights, in_channels=in_channels,
                              classes=classes, activation=activation)
    elif net_type == 'dlinknet':
        from .dlinknet import DLinknet
        model = DLinknet(encoder_name=backbone_name, encoder_weights=encoder_weights, in_channels=in_channels,
                         classes=classes, activation=activation)
    elif net_type == 'unet':
        from .unet import Unet
        model = Unet(encoder_name=backbone_name, encoder_weights=encoder_weights, in_channels=in_channels,
                     classes=classes, activation=activation)
    elif net_type == 'sfnet':
        from .sfnet import SFNet
        model = SFNet(encoder_name=backbone_name, encoder_weights=encoder_weights, in_channels=in_channels,
                      classes=classes, activation=activation, siame_encoder=False)
    elif net_type == 'segformer':
        from .segformer import SegFormer
        model = SegFormer(encoder_name=backbone_name, encoder_weights=encoder_weights, in_channels=in_channels,
                          classes=classes, activation=activation, siame_encoder=False)
    elif net_type == 'mask2former':
        from .mask2former import Mask2Former
        model = Mask2Former(encoder_name=backbone_name, encoder_weights=encoder_weights, in_channels=in_channels,
                            classes=classes)
    elif net_type == 'siamsfnet':
        from .sfnet import SFNet
        model = SFNet(encoder_name=backbone_name, encoder_weights=encoder_weights, in_channels=in_channels,
                      classes=classes, activation=activation, head_merge_method=head_merge_method)
    elif net_type == 'siamsegformer':
        from .segformer import SegFormer
        model = SegFormer(encoder_name=backbone_name, encoder_weights=encoder_weights, in_channels=in_channels,
                          classes=classes, activation=activation, head_merge_method=head_merge_method)
    elif net_type == 'dsamnet':
        from .dsamnet import DSAMNet
        model = DSAMNet(encoder_name=backbone_name, encoder_weights=encoder_weights, in_channels=in_channels,
                        classes=classes, activation=activation)
    elif net_type == 'sam':
        from .sam import Sam
        model = Sam(encoder_name=backbone_name, encoder_weights=encoder_weights, in_channels=in_channels,
                    classes=classes, activation=activation)
    else:
        raise ValueError('Input train model structure is not supported!')

    return model
