import math
import math
import time
import warnings
from typing import List, Tuple

import numpy as np
import pycocotools.mask as mask_util
import rasterio
import torch
from rasterio.plot import reshape_as_image

from iobjectspy import DatasetType, FieldInfo, FieldType, Feature
from iobjectspy._jsuperpy.data._util import DatasetType, FieldType
from iobjectspy.ml.toolkit._toolkit import bounds_transform_coord


def np_to_tensor(array, device=None):
    tensor = torch.from_numpy(array)
    if device:
        tensor = tensor.unsqueeze(0).unsqueeze(0).to(device)
    else:
        tensor = tensor.unsqueeze(0).unsqueeze(0)
    return tensor


def count_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        print(f"函数{func.__name__}耗时{time.time() - start_time}s!")
        return result

    return wrapper


def transform_image(img):
    """
    创建一个新ndarray保存图像并转换格式
    :param img: ndarray图像
    :return:    新的BGR格式ndarray图像
    """
    image = np.zeros([3, img.shape[1], img.shape[2]], dtype=np.uint8)
    image[:, :img.shape[1], :img.shape[2]] = img[:3, :, :]
    image = reshape_as_image(image)
    # image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)

    return image


def count_tile(image_size: Tuple, block_size: int, tile_offset: int):
    """
    计算所有tile的索引
    :param image_size:  影像大小
    :param block_size:  tile大小
    :param tile_offset: tile重叠面积
    :return:            tile的数量，对应的是第几行几列的tile
    """
    offset = block_size - tile_offset
    img_width, img_height = image_size[0], image_size[1]
    num_width_block = int(img_width // offset + 1)  # 每一行的块数
    num_height_block = int(img_height // offset + 1)  # 每一列的块数

    x_range = np.arange(num_width_block)
    y_range = np.arange(num_height_block)
    xx, yy = np.meshgrid(x_range, y_range)
    tuple_list = list(zip(yy.ravel(), xx.ravel()))

    # print("原图大小为:", (img_width, img_height))
    # print("tile大小为:", (block_size, block_size))
    # print("偏移量:", offset)
    return tuple_list


def comput_tile_corner_coor(ori_image_size: Tuple[int, int],
                            rectangle_size: Tuple[int, int],
                            block_size: int, tile_offset: int,
                            item: Tuple[int, int]):
    """
    计算一个tile的左上角和右下角坐标
    :param ori_image_size:  源影像大小
    :param rectangle_size:  范围推理的大小
    :param block_size:      tile大小
    :param tile_offset:     tile的重叠面积
    :param item:            代表第几行几列的tile
    :return:
    """
    if block_size is not None and tile_offset is not None:
        tile_offset = block_size - tile_offset  # tile_offset对于用户来说是tile的重叠量
        i, j = item
        img_width, img_height = ori_image_size
        rectangle_xmin, rectangle_ymin = rectangle_size
        block_xmin = j * tile_offset + rectangle_xmin
        block_ymin = i * tile_offset + rectangle_ymin
        block_xmax = block_xmin + block_size
        block_ymax = block_ymin + block_size
        if img_height <= block_ymax:
            block_ymin = img_height - block_size
            block_ymax = img_height
        if img_width <= block_xmax:
            block_xmin = img_width - block_size
            block_xmax = img_width
    else:
        block_xmin, block_ymin = item
        block_xmax, block_ymax = ori_image_size

    tile_corner = [block_xmin, block_ymin, block_xmax, block_ymax]

    return tile_corner


def coor2xyxy(coordinate_boxes_list, transform, point=None, bbox=None):
    """
    将坐标系坐标点转化为像素坐标(x,y,x,y,score,cls)
    """
    _list = []
    if bbox:
        for box_ in coordinate_boxes_list:
            ymin, xmin = rasterio.transform.rowcol(transform, box_[0], box_[3])
            ymax, xmax = rasterio.transform.rowcol(transform, box_[2], box_[1])
            if len(box_) == 6:
                _list.append([xmin, ymin, xmax, ymax, box_[4], box_[5]])
            elif len(box_) == 4:
                _list.append([xmin, ymin, xmax, ymax])
    if point:
        for point in coordinate_boxes_list:
            x, y = rasterio.transform.rowcol(transform, point[0], point[1])
            _list.append([x, y])
    return _list


def get_coordinate(features_list, point=None, bbox=None):
    """
    读取矢量数据中的信息
    :param features_list: 矢量数据，DatasetVector
    :param point:         是否时点矢量数据
    :param bbox:          是否时矩形面矢量数据
    :return:              list保存数据源中的经纬坐标、分数和类别信息
    """
    coordinate_list = []
    for features_ in features_list:
        region = features_.geometry
        values = features_.get_values(is_dict=True)
        bounds = region.bounds
        if bbox:
            coor_xmin, coor_ymin, coor_xmax, coor_ymax = bounds.left, bounds.bottom, bounds.right, bounds.top,
            if values.get('scores', None) and values.get('class_type', None):
                coordinate_list.append([coor_xmin, coor_ymin, coor_xmax, coor_ymax,
                                        values['scores'], values['class_type']])
            else:
                coordinate_list.append([coor_xmin, coor_ymin, coor_xmax, coor_ymax])
        if point:
            coor_x, coor_y = bounds.left, bounds.bottom,
            coordinate_list.append([coor_x, coor_y])

    return coordinate_list


# @count_time
def save_udbx_masks(ds_, outname, masks_geojson, datasetType, scores_cls_list=None, adjust_name=True):
    """
    保存数据到UDBX
    :param ds_:             udbx数据
    :param outname:         保存的数据集名称
    :param masks_geojson:   要保存的geojson文件
    :param datasetType:     数据类型，点线面
    :param scores_cls_list: 预测对象分数
    :param adjust_name:     当名称冲突时，自适应改变名称
    :return:                Updated dataset name.
    """
    if not ds_.is_available_dataset_name(outname) and adjust_name:
        outname = ds_.get_available_dataset_name(outname)
    # 不同的矢量数据要创建对应的数据集,线对应LINE,面对应REGION,点对应POINT
    if datasetType == "POINT":
        dataset_name = outname + str('_points')
        mask_dataset = ds_.create_vector_dataset(dataset_name, DatasetType.POINT, adjust_name=True)
    elif datasetType == "LINE":
        dataset_name = outname + str('_line')
        mask_dataset = ds_.create_vector_dataset(dataset_name, DatasetType.LINE, adjust_name=True)
    elif datasetType == "REGION":
        dataset_name = outname
        mask_dataset = ds_.create_vector_dataset(dataset_name, DatasetType.REGION, adjust_name=True)
    else:
        print("请输入支持的datasetType(目前只支持LINE,EGION,POINT)")

    # create field
    type_class = FieldInfo("class_type", FieldType.TEXT, max_length=50)
    type_score = FieldInfo("scores", FieldType.DOUBLE, max_length=50)

    # each vector dataset create field
    mask_dataset.create_field(type_class)
    mask_dataset.create_field(type_score)

    feature_mask_list = []
    if masks_geojson is not None:
        if scores_cls_list is None or len(scores_cls_list) == 0:
            for _mask in masks_geojson:
                feature_mask = Feature(_mask, field_infos=[type_class, type_score])
                feature_mask_list.append(feature_mask)
        else:
            for _mask, scores_cls in zip(masks_geojson, scores_cls_list):
                feature_mask = Feature(_mask, {"class_type": scores_cls[1], "scores": float(scores_cls[0])},
                                       field_infos=[type_class, type_score])
                feature_mask_list.append(feature_mask)

    mask_dataset.append(feature_mask_list)

    return mask_dataset.name


# @count_time
def rle_masks2ori_mask(original_mask: np.ndarray, masks: List, leups: np.ndarray):
    """
    该方法将每次推理的tile掩码结果贴到原图大小的掩码上，避免最后所有tile的掩码结果过多内存溢出
    :param original_mask: 整图大小的mask，全局变量
    :param masks: 每个tile上的mask
    :param leups: mask对应tile的坐上角坐标
    :return:
    """
    mask_num = len(masks)
    for mnum in range(mask_num):
        mask_c = masks[mnum]
        leup = leups[mnum]
        if not isinstance(masks, np.ndarray):
            mask_c = np.array(mask_util.decode(mask_c), dtype=bool)  # 游程编码解码过程

        # 计算小掩码在大掩码中的位置
        bottom_x, bottom_y = leup[0] + mask_c.shape[0], leup[1] + mask_c.shape[1]
        # 将小掩码放置在大掩码上,这里索引调换的原因是因为ndarray二值图掩码的第一个索引表示行(高),第二个索引表示列(宽)
        if mask_c.shape != original_mask[leup[1]:bottom_y, leup[0]:bottom_x].shape:
            print("mask_c掩码大小：", mask_c.shape)
            print("原图切片掩码大小：", original_mask[leup[1]:bottom_y, leup[0]:bottom_x].shape)
        original_mask[leup[1]:bottom_y, leup[0]:bottom_x] += mask_c


def read_raster_data(ds, infer_region):
    """
    判断是否有范围推理，并读取tif数据
    :param ds:           影像数据
    :param infer_region: 推理范围
    :return: img_width,img_height,rectangle_ymin,rectangle_xmin,transform
    """
    # 判断是否是范围推理
    if infer_region is not None:
        with warnings.catch_warnings(record=True) as w:
            rectangle_ymin, rectangle_xmin, bounds, img_width, img_height, transform \
                = bounds_transform_coord(ds, infer_region, mode='general')
        for warning in w:
            if "Region bounds is beyond Image." in str(warning.message):
                raise RuntimeError("Region bounds is beyond Image, please reset Region bounds!")
    else:
        img_width, img_height = ds.width, ds.height
        rectangle_ymin, rectangle_xmin = 0, 0
        transform = ds.transform
    return img_width, img_height, rectangle_ymin, rectangle_xmin, transform


def pixel_dis2geo_dis(resolution, pixel_dis):
    unit = 110000
    geo_dis = resolution * unit * pixel_dis

    return geo_dis


def resize_matrix(matrix, target_shape):
    img_height, img_width = target_shape
    current_height, current_width = matrix.shape

    if current_height > img_height:
        # 当前高度大于目标高度,需要裁剪
        matrix = matrix[:img_height, :]
    elif current_height < img_height:
        # 当前高度小于目标高度,需要填充
        pad_height = img_height - current_height
        matrix = np.pad(matrix, ((0, pad_height), (0, 0)), mode='constant', constant_values=1)

    if current_width > img_width:
        # 当前宽度大于目标宽度,需要裁剪
        matrix = matrix[:, :img_width]
    elif current_width < img_width:
        # 当前宽度小于目标宽度,需要填充
        pad_width = img_width - current_width
        matrix = np.pad(matrix, ((0, 0), (0, pad_width)), mode='constant', constant_values=1)

    return matrix


def resize_np_by_bounds(src_bounds, prompt_bounds, resolution, prompt_np):
    o_xmin, o_ymin, o_xmax, o_ymax = src_bounds.left, src_bounds.bottom, src_bounds.right, src_bounds.top
    xmin, ymin, xmax, ymax = prompt_bounds.left, prompt_bounds.bottom, prompt_bounds.right, prompt_bounds.top
    if resolution > 0.001:
        # 计算需要裁剪的区域
        left_crop = abs(min(0, int(math.floor(xmin - o_xmin) / resolution)))
        top_crop = abs(min(0, int(math.floor(ymin - o_ymin) / resolution)))
        right_crop = max(0, int(math.ceil(xmax - o_xmax) / resolution))
        bottom_crop = max(0, int(math.ceil(ymax - o_ymax) / resolution))
        # 裁剪prompt_np
        prompt_np = prompt_np[bottom_crop:prompt_np.shape[0] - top_crop, left_crop:prompt_np.shape[1] - right_crop]

        # 计算需要填充的区域
        left_pad = max(0, int(math.floor(xmin - o_xmin) / resolution))
        top_pad = max(0, int(math.floor(ymin - o_ymin) / resolution))
        right_pad = max(0, int(math.ceil(o_xmax - xmax) / resolution))
        bottom_pad = max(0, int(math.ceil(o_ymax - ymax) / resolution))
        # 填充prompt_np
        prompt_np = np.pad(prompt_np, ((bottom_pad, top_pad), (left_pad, right_pad)), mode='constant',
                           constant_values=1)
    else:
        # 计算需要裁剪的区域
        left_crop = abs(min(0, int((xmin - o_xmin) / resolution)))
        top_crop = abs(min(0, int((ymin - o_ymin) / resolution)))
        right_crop = max(0, int((xmax - o_xmax) / resolution))
        bottom_crop = max(0, int(((ymax - o_ymax) / resolution)))
        # 裁剪prompt_np
        prompt_np = prompt_np[bottom_crop:prompt_np.shape[0] - top_crop, left_crop:prompt_np.shape[1] - right_crop]

        # 计算需要填充的区域
        left_pad = max(0, int((xmin - o_xmin) / resolution))
        top_pad = max(0, int((ymin - o_ymin) / resolution))
        right_pad = max(0, int((o_xmax - xmax) / resolution))
        bottom_pad = max(0, int((o_ymax - ymax) / resolution))
        # 填充prompt_np
        prompt_np = np.pad(prompt_np, ((bottom_pad, top_pad), (left_pad, right_pad)), mode='constant',
                           constant_values=1)
    return prompt_np


def encode_mask_results(mask_results):
    """Encode bitmap mask to RLE code.

    Args:
        mask_results (list): bitmap mask results.

    Returns:
        list | tuple: RLE encoded mask.
    """
    encoded_mask_results = []
    for mask in mask_results:
        encoded_mask_results.append(
            mask_util.encode(
                np.array(mask[:, :, np.newaxis], order='F',
                         dtype='uint8'))[0])  # encoded with RLE
    return encoded_mask_results
