import math
import cv2
import matplotlib.pyplot as plt
import numpy as np
import torch
import torch.nn.functional as F
from ..utils import uniform_sampling_by_interval, farthest_point_sampling_with_constraints
from ..utils.amg import build_point_grid


def homogeneous_region_sampling(tile_bgr, tile_promptdata, point_nm):
    """
    对tile和对应的提示区域进行同质区域类提示点采样
    :param tile_bgr: ndarray数组，(H,W,C)
    :param tile_promptdata: ndarray数组，(H,W)
    :param point_nm: int类型，采样点数量
    :return: 返回两个ndarray数组，一个是采样点坐标(point_nm, 2)，另一个是采样点的标签，正样本为1(point_nm,)
    """
    # 将 BGR 图像转换为灰度图像
    gray_image = cv2.cvtColor(tile_bgr, cv2.COLOR_BGR2GRAY)
    grad_8bit = cv2.Canny(gray_image, 100, 200).astype(np.uint8)
    gradientimage = np.where(grad_8bit >= 50, 255, 0).astype(np.uint8)
    tile_promptdata = tile_promptdata * 255
    no_tile_promptdata = ~tile_promptdata
    grad_addprompt = gradientimage + tile_promptdata
    grad_addprompt_no = grad_addprompt * no_tile_promptdata

    filter_image_tensor = torch.from_numpy(gradientimage).float().unsqueeze(0).unsqueeze(0)
    coords_grad = np.argwhere(grad_addprompt_no)
    # 如果需要，交换坐标的行和列索引以匹配 (column, row) 顺序
    coords_grad = coords_grad[:, [1, 0]]

    # 创建一个 11x11 的全 1 矩阵
    kernel = np.ones((11, 11), dtype=float)
    kernel_size = kernel.shape[0]
    # 将中心位置的值设置为 -120
    kernel[5, 5] = -120
    # 添加额外的维度以符合卷积函数的要求
    kernel_tensor = torch.from_numpy(kernel).type(torch.float32).unsqueeze(0).unsqueeze(0)
    # 应用卷积操作,周围像素一样的像元值为0为黑色，
    padding_size = int((kernel_size - 1) / 2)
    output = F.conv2d(filter_image_tensor, kernel_tensor, stride=1,
                      padding=padding_size).squeeze(0).squeeze(0).squeeze(0)
    # 过滤掉提示外的区域
    output_addtile = output + tile_promptdata
    coords = np.argwhere(np.array(output_addtile) == 0)
    coords = coords[:, [1, 0]]
    if len(coords) == 0:
        coords = np.argwhere(np.array(gradientimage) == 0)
        coords = coords[:, [1, 0]]
    # 减少采样点方法1：最远点采样
    # 先采样一次
    num_samples = 1000
    # 采样点的数量
    k = point_nm
    if len(coords_grad) == 0:
        sampled_coords_rs = uniform_sampling_by_interval(coords, k)
        labels_rs = np.ones(len(sampled_coords_rs))
    elif len(coords) > num_samples:
        sampled_coords = uniform_sampling_by_interval(coords, num_samples)
        sampled_coords_grad = uniform_sampling_by_interval(coords_grad, num_samples)
        min_dist_to_grad = 0  # 不同分辨率的参数改变
        # 进行最远点采样
        sampled_coords_rs = farthest_point_sampling_with_constraints(sampled_coords, sampled_coords_grad,
                                                                     k, min_dist_to_grad)
        labels_rs = np.ones(len(sampled_coords_rs))
    elif k < len(coords) <= 1000:
        sampled_coords = coords
        sampled_coords_grad = uniform_sampling_by_interval(coords_grad, num_samples)
        min_dist_to_grad = 0  # 不同分辨率的参数改变
        # 进行最远点采样
        sampled_coords_rs = farthest_point_sampling_with_constraints(sampled_coords, sampled_coords_grad,
                                                                     k, min_dist_to_grad)
        labels_rs = np.ones(len(sampled_coords_rs))
    else:
        sampled_coords_rs = coords
        labels_rs = np.ones(len(sampled_coords_rs))

    del coords_grad
    return sampled_coords_rs, labels_rs


def small_target_sampling(tile_bgr, tile_promptdata, point_nm):
    """
    对tile和对应的提示区域进行小目标提示点采样
    :param tile_bgr: ndarray数组，(H,W,C)
    :param tile_promptdata: ndarray数组，(H,W)
    :param point_nm: int类型，采样点数量
    :return: 返回两个ndarray数组，一个是采样点坐标(point_nm, 2)，另一个是采样点的标签，正样本为1(point_nm,)
    """
    # 将 BGR 图像转换为灰度图像
    gray_image = cv2.cvtColor(tile_bgr, cv2.COLOR_BGR2GRAY)
    grad_8bit = cv2.Canny(gray_image, 100, 200).astype(np.uint8)
    gradientimage = np.where(grad_8bit >= 50, 255, 0).astype(np.uint8)
    tile_promptdata = tile_promptdata * 255
    no_tile_promptdata = ~tile_promptdata
    grad_addprompt = gradientimage + tile_promptdata
    grad_addprompt_no = grad_addprompt * no_tile_promptdata
    # nonzero_indices = np.argwhere(np.array(grad_addprompt_no) != 0)
    coords_grad = np.argwhere(grad_addprompt_no)
    # 如果需要，交换坐标的行和列索引以匹配 (column, row) 顺序
    coords_grad = coords_grad[:, [1, 0]]
    k = point_nm
    if len(coords_grad) > k:
        sampled_coords_rs = uniform_sampling_by_interval(coords_grad, k)
        labels_rs = np.ones(len(sampled_coords_rs))
    else:
        sampled_coords_rs = coords_grad
        labels_rs = np.ones(len(sampled_coords_rs))

    return sampled_coords_rs, labels_rs


def grid_uniform_sampling(tile_bgr, tile_promptdata, point_nm):
    """
    均匀点采样
    """
    zero_coords = np.where(tile_promptdata == 0)
    zero_coords_tile_ = np.array(list(zip(zero_coords[0], zero_coords[1])))
    tile_size = tile_promptdata.shape
    n_per_side = math.floor(math.sqrt(point_nm))

    points_scale = np.array(tile_size)[None, ::-1]
    points = build_point_grid(int(n_per_side))
    points_for_tile_ = points * points_scale

    # set_promptpoints = set(map(tuple, zero_coords_tile_))
    set_tilepoints = set(map(tuple, points_for_tile_))

    # 使用集合的交集操作找出相同的坐标
    # points_for_tile = np.array(list(set_promptpoints & set_tilepoints))
    points_for_tile = np.array(list(set_tilepoints))
    labels_points_for_tile = np.ones(len(points_for_tile))
    if len(points_for_tile) != 0:
        points_for_tile = points_for_tile[:, [1, 0]]
    else:
        non_zero_indices = np.argwhere(tile_promptdata != 0)
        random_indices = np.random.choice(non_zero_indices.shape[0], point_nm, replace=False)
        random_points = non_zero_indices[random_indices]
        points_for_tile = random_points[:, [1, 0]]

    return points_for_tile, labels_points_for_tile


# @staticmethod
# def sample_neg_points(tile_img: np.ndarray):
#     """
#     通过边缘检测生成负样本点
#     """
#     # 生成负采样点
#     image_gray = cv2.cvtColor(tile_img, cv2.COLOR_BGR2GRAY)
#     edges = cv2.Canny(image_gray, 50, 200)  # 使用Canny边缘检测来提取边缘
#
#     # 寻找轮廓
#     area_threshold = 100
#     contours, hierarchy = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
#     filtered_contours = [contour for contour in contours if cv2.contourArea(contour) > area_threshold]
#
#     # 计算轮廓的中心点
#     center_list = []
#     for contour in filtered_contours:
#         # 计算轮廓的矩
#         M = cv2.moments(contour)
#         # 计算中心点坐标
#         if M['m00'] != 0:
#             cX = int(M['m10'] / M['m00'])
#             cY = int(M['m01'] / M['m00'])
#             center = (cX, cY)
#             center_list.append(center)
#
#     return center_list
# def _sample(self, tile_size: int, tile_img: np.ndarray, point_density=0.5):
#     # 生成正采样点
#     pos_points = self.sample_pos_points(point_density, tile_size)
#     # 生成负采样点
#     if self.neg:
#         neg_points = self.sample_neg_points(tile_img)
#     else:
#         neg_points = None
#     return pos_points, neg_points
