import os
import copy
import multiprocessing
import warnings
from concurrent.futures import ThreadPoolExecutor, wait

import numpy as np
import rasterio
from rasterio.windows import Window

from iobjectspy.ml.toolkit._toolkit import bounds_transform_coord
from .seg_data_io import SegDataIO
from ..tools._toolkit import MathTools


class CDDataIO(SegDataIO):
    def _initialize_source(self, input_path):
        """
        打开输入数据源，读取波段索引
        :param input_path:
        :return:
        """
        self.src0 = rasterio.open(input_path[0])
        self.src1 = rasterio.open(input_path[1])
        self.src = self.src0
        self.band_index = self.band_index if max(self.band_index) <= self.src0.count else \
            [i + 1 for i in range(self.src0.count)]

    def _initialize_region(self, infer_region, input_path):
        """
        根据是否为范围推理设置不同的范围参数
        :param infer_region:
        :param input_path:
        :return:
        """
        self.region_mask = None
        # 给定范围
        if infer_region is not None:
            (self.rectangle_ymin, self.rectangle_xmin,
             self.rectangle_ymin_compare, self.rectangle_xmin_compare,
             self.bounds, self.width, self.height,
             self.transform, self.out_region_mask
             ) = (
                bounds_transform_coord(
                    self.src0, infer_region, mode="cd",
                    ds_compare=self.src1, to_raster=True,
                    out_path=input_path[0])
            )

            if self.out_region_mask is not None:
                with warnings.catch_warnings():
                    warnings.simplefilter("ignore")
                    self.region_mask = rasterio.open(self.out_region_mask)
        # 未给定范围，存在坐标时，求交集
        elif self.src0.transform[0] * self.src0.transform[4] * self.src0.transform[8] != 1:
            (self.rectangle_ymin, self.rectangle_xmin,
             self.rectangle_ymin_compare, self.rectangle_xmin_compare,
             self.bounds, self.width, self.height,
             self.transform, self.out_region_mask
             ) = (
                bounds_transform_coord(self.src0, mode="cd", ds_compare=self.src1)
            )
        else:
            self.bounds = self.src0.bounds
            self.width, self.height = self.src0.width, self.src0.height
            self.rectangle_ymin, self.rectangle_xmin = 0, 0
            self.rectangle_ymin_compare, self.rectangle_xmin_compare = 0, 0
            self.transform = self.src0.transform

    def _initialize_temp_path(self, input_path):
        """
        用于生成推理结果临时落盘的路径
        :param input_path:
        :return:
        """
        dir_path = os.path.split(input_path[0])
        self.temp_path = os.path.join(dir_path[0], os.path.splitext(dir_path[1])[0] + '_temp_mask')
        os.makedirs(self.temp_path, exist_ok=True)
        self.count = 0

    def _read(self, x, y):
        xBegin, yBegin = MathTools.calculate_begin(x, y, self.width, self.height, self.block_size, self.cut_edge)
        crop_size = self.block_size + 2 * self.cut_edge

        # 指定范围推理时，block读取需加上左上角起始点坐标
        block0 = self.src0.read(self.band_index, window=Window(
            xBegin + self.rectangle_xmin, yBegin + self.rectangle_ymin, crop_size, crop_size), boundless=True)
        block1 = self.src1.read(self.band_index, window=Window(
            xBegin + self.rectangle_xmin_compare, yBegin + self.rectangle_ymin_compare, crop_size, crop_size),
                                boundless=True)
        if self.transform is not None:
            mask0 = np.ones((crop_size, crop_size), dtype=np.uint8)
            mask1 = np.ones((crop_size, crop_size), dtype=np.uint8)
            # 超出图像边缘部分像素值通常为0，mask值赋0，图像内也存在为0处，但数量少且不会连片出现
            # 此方式可不检测像素值为0和不为区域的变化
            mask0[np.all(block0 == 0, axis=0)] = 0
            mask1[np.all(block1 == 0, axis=0)] = 0
            mask = mask0 * mask1
            # 超出图像边缘部分像素值均赋0
            block0, block1 = block0 * mask, block1 * mask
        if self.region_mask is not None:
            mask_region = self.region_mask.read(window=Window(
                xBegin, yBegin, crop_size, crop_size), boundless=True)
            block0, block1 = block0 * mask_region, block1 * mask_region
        return [block0, block1]

    def read_batch(self, blocks):
        data = []
        new_blocks = copy.deepcopy(blocks)
        blocks = [[x for x, _ in blocks], [y for _, y in blocks]]
        with ThreadPoolExecutor(max_workers=min(self.batch_size, multiprocessing.cpu_count(), 16)) as pool:
            for r in pool.map(self._read, blocks[0], blocks[1]):
                data.append(r)

        if self.preprocessing_fn is not None:
            with ThreadPoolExecutor(max_workers=min(self.batch_size, multiprocessing.cpu_count())) as pool:
                task_list1 = [pool.submit(self.preprocessing_fn, image=image[0]) for image in data]
                task_list2 = [pool.submit(self.preprocessing_fn, image=image[1]) for image in data]
                wait(task_list1), wait(task_list2)
                data1 = [t.result()['image'] for t in task_list1]
                data2 = [t.result()['image'] for t in task_list2]
        arrays1 = np.stack(data1, axis=0)
        arrays2 = np.stack(data2, axis=0)
        return [arrays1, arrays2], new_blocks

    def close_src(self):
        self.src0.close()
        self.src1.close()
        self.temp_dst.close()
