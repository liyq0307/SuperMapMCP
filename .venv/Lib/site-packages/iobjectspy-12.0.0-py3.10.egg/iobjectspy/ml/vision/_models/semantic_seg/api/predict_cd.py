import numpy as np
import torch

from iobjectspy._logger import log_warning
from .predict_seg import SegTorchEstimation
from ..dataio import CDDataIO
from ..tools import SaveTools
from ...device_utils import Device_type


class SegTorchEstimation_CD(SegTorchEstimation):
    def _create_dataio(self, dom_path, tmp_file, batch_size, infer_region, confidence_map):
        # dom_path1, dom_path2 = dom_path[0], dom_path[1]
        return CDDataIO(
            input_path=dom_path,
            out_path=tmp_file,
            block_size=self.seg_size,
            batch_size=batch_size,
            cut_edge=self.half_oversize,
            color_map=self.color_map,
            preprocessing_fn=self.preprocessing,
            band_index=[i + 1 for i in range(self.input_bands)],
            infer_region=infer_region,
            confidence_map=confidence_map
        )

    @torch.no_grad()
    def _predict_on_batch(self, predict_tiles):
        batch_data1, batch_data2 = predict_tiles
        x_tensor1 = torch.from_numpy(batch_data1).to(self.device)
        x_tensor2 = torch.from_numpy(batch_data2).to(self.device)

        with torch.no_grad():
            pr_mask = self.model.forward([x_tensor1, x_tensor2])
        pr_mask = (pr_mask.cpu().detach().numpy())

        return pr_mask

    def _process_mask(self, mask_block, single_threshold, confidence_map):
        if self.output_msk_num > 1:
            mask = np.argmax(mask_block, axis=1)[:, np.newaxis, :, :]
        else:
            if self.model_name != 'dsamnet':
                mask = mask_block if confidence_map else (mask_block > single_threshold)
            else:
                mask = mask_block > 1.0

        mask = mask.astype(np.float32 if confidence_map else np.uint8)
        return mask[:, np.newaxis, :, :] if len(mask.shape) < 4 else mask

    def _finalize_result(self, result_type, out_ds, dst_name, tmp_file, out_tmp_name, infer_region):
        """
        保存结果数据
        :param result_type:
        :param out_ds:
        :param dst_name:
        :param tmp_file:
        :param out_tmp_name:
        :return:
        """
        if result_type.strip() == 'grid':
            return SaveTools.finalize_grid_result_cd(out_ds, dst_name, tmp_file, out_tmp_name)
        elif result_type.strip() == 'region':
            return SaveTools.finalize_region_result_cd(out_ds, dst_name, tmp_file, self.back_or_no_value, infer_region)
        else:
            raise ValueError('Invalid result_type')

    def close_model(self):
        # todo close model
        try:
            del self.model
            Device_type.empty_cache()
        except Exception as e:
            log_warning('Close model error : {}'.format(e))
        pass
