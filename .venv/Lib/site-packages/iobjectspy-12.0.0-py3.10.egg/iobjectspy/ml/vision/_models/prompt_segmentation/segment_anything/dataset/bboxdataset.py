import json

import matplotlib.pyplot as plt
import numpy as np
import rasterio
import shapely
import torch
from rasterio.windows import Window
from shapely.geometry import Point, shape
from tqdm import tqdm

from iobjectspy import (Datasource, Geometry, open_datasource)
from ._base_.dataset import SamDataset
from ...utils import comput_tile_corner_coor, transform_image, save_udbx_masks
from .processor import Samprocessor


def show_box(box, ax):
    x0, y0 = box[0], box[1]
    w, h = box[2] - box[0], box[3] - box[1]
    ax.add_patch(plt.Rectangle((x0, y0), w, h, edgecolor='green', facecolor=(0, 0, 0, 0), lw=2))


class SamBboxDataset(SamDataset):
    def __init__(self, sam, datapath, promptdata, boxes_list_np, tilesize, offset):
        super().__init__(sam, datapath, promptdata, tilesize, offset)
        self.boxes_list_np = boxes_list_np
        sam_input_image_size = sam.image_encoder.img_size
        self.processor = Samprocessor(sam_input_image_size)
        # self.process()  # 处理数据，并按照切块保存在data字典中，

    def write2dataset(self, eroded_mask, outpath, outname, profile):
        if isinstance(outpath, str):
            ds_ = open_datasource(outpath)
        elif isinstance(outpath, Datasource):
            ds_ = outpath
        else:
            raise TypeError('Only support str and Datasource types.')

        all_object = list(
            rasterio.features.shapes(eroded_mask, mask=eroded_mask.astype(np.bool_), transform=self.affine_transform))
        masks_process = []
        for geom, value in all_object:
            polygon = shape(geom)
            # 将geometry保存为GeoJSON格式
            geojson = json.dumps(shapely.geometry.mapping(polygon))
            region_shp = Geometry.from_geojson(geojson)
            masks_process.append(region_shp)
        # 创建保存mask的数据格式
        datasetType = "REGION"
        outname = save_udbx_masks(ds_, outname, masks_process, datasetType)

        return outname

    def __len__(self):
        return len(self.tile_list)

    def __getitem__(self, idx):
        tile_item = self.tile_list[idx]
        tile_corner = comput_tile_corner_coor(self.ori_image_size, self.rectangle_size,
                                              self.tilesize, self.offset, tile_item)
        b_xmin, b_ymin, b_xmax, b_ymax = tile_corner
        condition = (self.boxes_list_np[:, 0] >= b_xmin) & (self.boxes_list_np[:, 2] <= b_xmax) & \
                    (self.boxes_list_np[:, 1] >= b_ymin) & (self.boxes_list_np[:, 3] <= b_ymax)
        indices = np.where(condition)

        # 如果找到索引,读取对应block图像,将box坐标投影到当前block上,并记录左上点.否则跳过当前迭代
        inputs = {"tile_corner": torch.tensor(tile_corner)}
        if len(indices[0]) != 0:
            with rasterio.open(self.datapath) as src:
                window = Window(tile_corner[0], tile_corner[1], self.tilesize, self.tilesize)
                image = src.read(window=window)
                image_size = image.shape[1:]
                tile_rgb = transform_image(image)
                # 先将box对应原图坐标系的坐标转换为对应block的像素坐标后传给sam模型进行分割
                processed_boxes = [
                    torch.tensor([
                        float(box_[0]) - b_xmin, float(box_[1]) - b_ymin,
                        float(box_[2]) - b_xmin, float(box_[3]) - b_ymin
                    ], dtype=torch.float64)
                    for box_ in self.boxes_list_np[indices]
                ]
                boxes_tensor = torch.stack(processed_boxes)
                inputs = self.processor(tile_rgb, image_size,
                                        tile_corner=tile_corner, bbox=boxes_tensor)
                inputs["tile_corner"] = torch.tensor(tile_corner)

        return inputs, idx
