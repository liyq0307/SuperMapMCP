# Copyright (c) OpenMMLab. All rights reserved.
import shapely.speedups
shapely.speedups.disable()
import os, copy
import xml.etree.ElementTree as ET
from typing import List, Union
import cv2 as cv
import numpy as np
import mmcv
import tqdm,yaml
from mmdet.datasets.coco import CocoDataset
from mmdet.registry import DATASETS
from mmengine.fileio import get, get_local_path, list_from_file
from iobjectspy.ml.vision._models.object_detection._mmdet._tools import \
    extract_sub_mask_from_ROI_TRANS_by_using_BGR, find_nearest, single_mask_generates_polygon_or_rle


@DATASETS.register_module()
class SMVOCMaskDataset(CocoDataset):

    def __init__(self, **kwargs):
        self.find_suffix(kwargs.get('data_root'))
        self.model_type = kwargs.get('model_type')
        del kwargs['model_type']
        super(SMVOCMaskDataset, self).__init__(**kwargs)

    def find_suffix(self, data_root):
        for file in os.listdir(data_root):
            if file.endswith('.sda'):
                file_path = os.path.join(data_root, file)
        with open(file_path, encoding='utf-8') as f:
            config_dict = yaml.load(f, Loader=yaml.FullLoader)
        self.suffix = config_dict['dataset']['suffix']

    def str2int(self, s):
        s.lstrip("0")
        if s == " ":
            return 0
        else:
            return int(s)

    def load_data_list(self) -> List[dict]:
        """Load annotation from XML style ann_file.

        Returns:
            list[dict]: Annotation info from XML file.
        """
        assert self._metainfo.get('classes', None) is not None, \
            '`classes` in `XMLDataset` can not be None.'
        self.cat2label = {
            cat: i
            for i, cat in enumerate(self._metainfo['classes'])
        }

        data_list = []
        img_ids = list_from_file(self.ann_file, backend_args=self.backend_args)
        for img_id in tqdm.tqdm(img_ids, desc='loading data'):
            file_name = os.path.join('Images', f'{img_id}.'+self.suffix)
            xml_path = os.path.join(self.data_root, 'Annotations',
                                f'{img_id}.xml')
            mask_path = os.path.join(self.data_root,'SegmentationObject',
                                     f'{img_id}.png')
            raw_img_info = {}
            raw_img_info['img_id'] = self.str2int(img_id)
            raw_img_info['file_name'] = file_name
            raw_img_info['xml_path'] = xml_path
            raw_img_info['mask_path'] = mask_path

            parsed_data_info = self.parse_data_info(raw_img_info)
            data_list.append(parsed_data_info)

        return data_list

    def parse_data_info(self, img_info: dict) -> Union[dict, List[dict]]:
        """Parse raw annotation to target format.

        Args:
            img_info (dict): Raw image information, usually it includes
                `img_id`, `file_name`, and `xml_path`.

        Returns:
            Union[dict, List[dict]]: Parsed annotation.
        """
        data_info = {}
        img_path = os.path.join(self.data_root, img_info['file_name'])
        data_info['img_path'] = img_path
        data_info['img_id'] = img_info['img_id']
        data_info['seg_map_path'] = None
        # deal with xml file
        with get_local_path(
                img_info['xml_path'],
                backend_args=self.backend_args) as local_path:
            raw_ann_info = ET.parse(local_path)
        root = raw_ann_info.getroot()
        size = root.find('size')
        if size is not None:
            width = int(size.find('width').text)
            height = int(size.find('height').text)
        else:
            img_bytes = get(img_path, backend_args=self.backend_args)
            img = mmcv.imfrombytes(img_bytes, backend='cv2')
            height, width = img.shape[:2]
            del img, img_bytes

        data_info['height'] = height
        data_info['width'] = width
        mask = mask = cv.imdecode(np.fromfile(img_info['mask_path'], dtype=np.uint8), -1)[:,:,:3]

        data_info['instances'] = self._parse_instance_info(
            raw_ann_info, mask, minus_one=True)

        return data_info


    def _parse_instance_info(self,
                             raw_ann_info: ET, mask,
                             minus_one: bool = True) -> List[dict]:
        """parse instance information.

        Args:
            raw_ann_info (ElementTree): ElementTree object.
            minus_one (bool): Whether to subtract 1 from the coordinates.
                Defaults to True.

        Returns:
            List[dict]: List of instances.
        """
        instances = []
        for obj in raw_ann_info.findall('object'):
            instance = {}
            name = obj.find('name').text
            if name not in self._metainfo['classes']:
                continue
            difficult = obj.find('difficult')
            difficult = 0 if difficult is None else int(difficult.text)
            bnd_box = obj.find('bndbox')
            bbox = [
                int(float(bnd_box.find('xmin').text)),
                int(float(bnd_box.find('ymin').text)),
                int(float(bnd_box.find('xmax').text)),
                int(float(bnd_box.find('ymax').text))
            ]
            # VOC needs to subtract 1 from the coordinates
            # if minus_one:
            #     bbox = [x - 1 for x in bbox]

            ignore = False
            # if self.bbox_min_size is not None:
            #     assert not self.test_mode
            #     w = bbox[2] - bbox[0]
            #     h = bbox[3] - bbox[1]
            #     if w < self.bbox_min_size or h < self.bbox_min_size:
            #         ignore = True
            if difficult or ignore:
                instance['ignore_flag'] = 1
            else:
                instance['ignore_flag'] = 0
            instance['bbox'] = bbox
            instance['bbox_label'] = self.cat2label[name]
            seg_final, area = self.get_mask(mask, bbox, obj)
            instance['mask'] = seg_final
            instances.append(instance)

        return instances

    def get_mask(self,mask, bbox, obj):

        ROI = mask[bbox[1]:bbox[3], bbox[0]:bbox[2], :]
        # 查看ROI
        ROI_TRANS = ROI.transpose(2, 0, 1)

        # 如果object中记录了RBG,先提取出来
        if obj.find('color') is not None:
            color_ids = ((obj.find('color')).text).strip('()').split(',')
            original_color = [int(color_id) for color_id in color_ids]
            # 从ROI_TRANS中取出该mask，进入单个mask生成polygon/RLE逻辑
            # （由于xml记录的是RGB，ROI_TRANS是BGR, 需要转置）
            original_color.reverse()
            seg_final, area = extract_sub_mask_from_ROI_TRANS_by_using_BGR(ROI_TRANS, original_color, mask, bbox)
        # 如果object中没有记录RBG，就反算该物体的RBG值
        else:
            # 记录有几种颜色, 先设置一个color_index列表，并将黑色BGR记录上去
            # 最后返回的color_index，如果不是拥挤多边形，它的长度就是2，反之，大于2
            color_index = [[0, 0, 0]]
            # 遍历sub-mask
            for x in range(ROI_TRANS.shape[2]):
                for y in range(ROI_TRANS.shape[1]):
                    # 提取每一个点的BGR值
                    color = ROI_TRANS[:, y, x]
                    color_list = color.tolist()
                    # 如果color_index里面没有该点的RGB值
                    # 就往color_index追加一个RGB值
                    if color_list not in color_index:
                        color_index.append(color_list)

            # =============== 如果color_index的长度大于2，那该sub-mask就是拥挤多边形 =============== #
            if len(color_index) > 2:
                # 先复制一个color_index
                color_index_deepcopy = copy.deepcopy(color_index)
                # 计算gt_bbox的面积
                gt_bbox_area = (bbox[3] - bbox[1]) * (bbox[2] - bbox[0])
                area_list = []
                # 循环读取color_index的RGB值，循环次数为len(color_index)-1
                # 每次都提color_index的最后一个RGB值，这样就不会提[0,0,0]
                for _ in range(1, len(color_index)):
                    # 为了方便理解，这部分的运算都是CHW
                    # 提取color_index最后一个RGB值的mask
                    mask_temp = (ROI_TRANS[0, :, :] == color_index[-1][0]) & \
                                (ROI_TRANS[1, :, :] == color_index[-1][1]) & \
                                (ROI_TRANS[2, :, :] == color_index[-1][2])
                    # color_index删除最后一个color
                    color_index.pop(-1)
                    # 布尔型转整形
                    mask_temp = mask_temp + 0
                    # 生成一张跟mask_temp大小一样的灰度图
                    arr = np.zeros((mask_temp.shape[0], mask_temp.shape[1], 3))
                    arr[:, :, 0] = mask_temp
                    arr[:, :, 1] = mask_temp
                    arr[:, :, 2] = mask_temp
                    arr = arr.astype(np.uint8)
                    arr_gray = cv.cvtColor(arr, cv.COLOR_BGR2GRAY)
                    # 生成一个bbox(不管是不是空洞多边形，都会生成外接正四边形)
                    # 并放到bbox_list中
                    nums_labels, lables, calcu_boxes, centroids = cv.connectedComponentsWithStats(arr_gray, connectivity=8)
                    # 从ROI中单独抽取出来的对象，如果是连通的，则通过上式生成的box，长度是2；反之，长度大于2
                    if len(calcu_boxes) > 2:
                        # 删除calcu_boxes第一个元素, 并将所有剩余bbox由xywh转成x1y1x2y2
                        box_data = np.delete(calcu_boxes, 0, 0)
                        bbox_trans = []
                        for i_box in box_data:
                            bbox_trans.append([i_box[0], i_box[1],
                                           i_box[0] + i_box[2], i_box[1] + i_box[3]])
                        bbox_trans = np.array(bbox_trans)
                        # 比较所有bbox的x1y1，取最小值
                        # 比较所有bbox的x2y2，取最大值
                        # 作为最终bbox
                        clo_min = np.min(bbox_trans, axis=0)
                        clo_max = np.max(bbox_trans, axis=0)

                        w = clo_max[2] - clo_min[0]
                        h = clo_max[3] - clo_min[1]
                        area_temp = w * h
                    else:
                        area_temp = calcu_boxes[1][2] * calcu_boxes[1][3]
                    area_list.append(area_temp)
                # 将area_list倒序,并将color_index里面的黑色RGB删除
                # 如此，area_list[0]对应color_index[0], area_list[1]对应color_index[1] .....
                area_list.reverse()
                color_index_deepcopy.pop(0)
                # 判断取舍,返回最接近gt_bbox的bbox的索引,并从color_index中
                # 拿到该索引对应的RGB
                idx_color = find_nearest(area_list, gt_bbox_area)
                color_final = color_index_deepcopy[idx_color]

                # 从ROI_TRANS中取出该mask，进入单个mask生成polygon/RLE逻辑
                seg_final, area = extract_sub_mask_from_ROI_TRANS_by_using_BGR(ROI_TRANS, color_final, mask, bbox)

                # # 从原图mask上清理掉color_final
                #
                # mask_zero = np.zeros([mask.shape[0], mask.shape[1], mask.shape[2]], mask.dtype)
                # # 将arr_final放到全0图上
                # mask_zero[bbox[1]:bbox[3], bbox[0]:bbox[2], :] = arr_final
                # mask[:, :, 0][mask_zero[:, :, 0] != 0] = 0
                # mask[:, :, 1][mask_zero[:, :, 1] != 0] = 0
                # mask[:, :, 2][mask_zero[:, :, 2] != 0] = 0

            # ================= 否则就不是拥挤多边形,进入单个sub-mask生成polygon/RLE逻辑 ================= #
            else:
                seg_final, area = single_mask_generates_polygon_or_rle(mask, bbox, ROI)

        return seg_final, area

    def filter_data(self) -> List[dict]:
        """Filter annotations according to filter_cfg.

        Returns:
            List[dict]: Filtered results.
        """
        return self.data_list
        # self.test_mode = True
        # if self.test_mode:
        #     return self.data_list
        #
        # filter_empty_gt = self.filter_cfg.get('filter_empty_gt', False) \
        #     if self.filter_cfg is not None else False
        # min_size = self.filter_cfg.get('min_size', 0) \
        #     if self.filter_cfg is not None else 0
        #
        # valid_data_infos = []
        # for i, data_info in enumerate(self.data_list):
        #     width = data_info['width']
        #     height = data_info['height']
        #     if filter_empty_gt and len(data_info['instances']) == 0:
        #         continue
        #     if min(width, height) >= min_size:
        #         valid_data_infos.append(data_info)
        #
        # return valid_data_infos
