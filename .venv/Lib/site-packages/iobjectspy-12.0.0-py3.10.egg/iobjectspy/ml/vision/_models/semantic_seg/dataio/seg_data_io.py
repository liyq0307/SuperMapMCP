import copy
import math
import multiprocessing
import os
import shutil
import time
import warnings
from concurrent.futures import ThreadPoolExecutor, wait

import numpy as np
import rasterio
from rasterio.windows import Window

from .data_io import DataIO
from ..tools._toolkit import MathTools
from .....toolkit._toolkit import bounds_transform_coord


class SegDataIO(DataIO):
    def __init__(self, input_path, out_path, block_size, batch_size=1, cut_edge=128, color_map=None,
                 preprocessing_fn=None, band_index=[1, 2, 3], infer_region=None, **kwargs):
        self.cut_edge = cut_edge
        self.block_size = block_size - (cut_edge * 2)
        self.batch_size = batch_size
        self.color_map = color_map
        self.preprocessing_fn = preprocessing_fn
        self.band_index = band_index   # 波段索引
        self.confidence_map = kwargs.get("confidence_map")

        self._initialize_source(input_path)
        self._initialize_region(infer_region, input_path)
        self._initialize_destination(out_path)
        self._initialize_patch_index()
        self._initialize_temp_path(input_path)

    def _initialize_source(self, input_path):
        """
        打开输入数据源，读取波段索引
        :param input_path:
        :return:
        """
        self.src = rasterio.open(input_path)
        self.band_index = self.band_index if max(self.band_index) <= self.src.count else \
            [i + 1 for i in range(self.src.count)]

    def _initialize_region(self, infer_region, input_path):
        """
        根据是否为范围推理设置不同的范围参数
        :param infer_region:
        :param input_path:
        :return:
        """
        if infer_region is not None:
            self.rectangle_ymin, self.rectangle_xmin, self.bounds, self.width, self.height, self.transform, \
                self.out_region_mask = bounds_transform_coord(self.src, infer_region, mode='general', to_raster=True,
                                                              out_path=input_path)
            if self.out_region_mask is not None:
                with warnings.catch_warnings():
                    warnings.simplefilter("ignore")
                    self.region_mask = rasterio.open(self.out_region_mask)
            else:
                self.region_mask = None
        else:
            self.bounds = self.src.bounds
            self.width, self.height = self.src.width, self.src.height
            self.rectangle_ymin, self.rectangle_xmin = 0, 0
            self.transform = self.src.transform
            self.region_mask = None

    def _initialize_destination(self, out_path):
        """
        设置rasterio写入结果文件参数
        :param out_path:
        :return:
        """
        dtype = np.float32 if self.confidence_map else np.uint8
        self.dst = rasterio.open(out_path, 'w', driver='GTiff', width=self.width, height=self.height,
                                 count=1, crs=self.src.crs, transform=self.transform,dtype=dtype)
        if not self.confidence_map:
            self.dst.write_colormap(1, self.color_map)

    def _initialize_patch_index(self):
        """
        生成滑块起始坐标索引列表，设置最大滑块面积
        :return:
        """
        self.patch_index = self._slice_index()
        self.large_patch_area = math.pow(25600, 2)  # default
        self.factor = max(self.large_patch_area / self.width // self.block_size, 1)
        self.large_patch_index = []
        self.cut_y = 0

    def _initialize_temp_path(self, input_path):
        """
        用于生成推理结果临时落盘的路径
        :param input_path:
        :return:
        """
        dir_path = os.path.split(input_path)
        self.temp_path = os.path.join(dir_path[0], os.path.splitext(dir_path[1])[0] + '_temp_mask')
        os.makedirs(self.temp_path, exist_ok=True)
        self.count = 0

    def _slice_index(self):
        if self.block_size <= 0:
            raise ValueError("The offset size cannot exceed half of the block size")
        self.coversize = 0
        self.rPatchNum = math.ceil((self.height * 1.0 - self.block_size) / (self.block_size - self.coversize)) + 1
        self.cPatchNum = math.ceil((self.width * 1.0 - self.block_size) / (self.block_size - self.coversize)) + 1
        rowBegin = 0
        colBegin = 0
        num_patch = 0
        patch_index = []
        tmpPatchIndex = [0, 0]  # 影像中起始列, 影像中起始行,
        for i in range(self.rPatchNum):
            for j in range(self.cPatchNum):
                if (colBegin + self.block_size) < self.width:
                    tmpPatchIndex[0] = colBegin
                elif self.width < self.block_size:
                    tmpPatchIndex[0] = 0
                else:
                    tmpPatchIndex[0] = self.width - self.block_size
                if (rowBegin + self.block_size) < self.height:
                    tmpPatchIndex[1] = rowBegin
                elif self.height < self.block_size:
                    tmpPatchIndex[1] = 0
                else:
                    tmpPatchIndex[1] = self.height - self.block_size
                patch_index.append(tmpPatchIndex)
                tmpPatchIndex = [0, 0]
                colBegin = colBegin + self.block_size - self.coversize
                num_patch += 1

            rowBegin = rowBegin + self.block_size - self.coversize
            colBegin = 0

        return patch_index

    def _read(self, x, y):
        xBegin, yBegin = MathTools.calculate_begin(x, y, self.width, self.height, self.block_size, self.cut_edge)
        crop_size = self.block_size + 2 * self.cut_edge

        crop_patch = self.src.read(self.band_index, window=Window(
            xBegin + self.rectangle_xmin, yBegin + self.rectangle_ymin, crop_size, crop_size), boundless=True)

        if self.region_mask is not None:
            mask_region = self.region_mask.read(window=Window(
                xBegin, yBegin, crop_size, crop_size), boundless=True)
            crop_patch = crop_patch * mask_region
        return crop_patch

    def _write(self, data, x, y, y_new):
        h, w = data.shape[1:3]
        write_w, cut_edge_w = MathTools.calculate_write_and_cut(x, self.width, self.block_size, self.cut_edge, w)
        write_h, cut_edge_h = MathTools.calculate_write_and_cut(y, self.height, self.block_size, self.cut_edge, h)
        data = data[:, cut_edge_h:cut_edge_h + write_h, cut_edge_w:cut_edge_w + write_w]

        self.temp_dst.write(data, window=Window(x, y_new, write_w, write_h))

    def read_batch(self, blocks):
        """
        数据读取接口
        :param blocks:
        :return:
        """
        new_blocks = copy.deepcopy(blocks)
        blocks = [[x for x, _ in blocks], [y for _, y in blocks]]

        with ThreadPoolExecutor(max_workers=min(self.batch_size, multiprocessing.cpu_count(), 16)) as pool:
            data = list(pool.map(self._read, blocks[0], blocks[1]))

        if self.preprocessing_fn is not None:
            with ThreadPoolExecutor(max_workers=min(self.batch_size, multiprocessing.cpu_count())) as pool:
                task_list = [pool.submit(self.preprocessing_fn, image=image) for image in data]
                wait(task_list)
                data = [t.result()['image'] for t in task_list]

        arrays = np.stack(data, axis=0)
        return arrays, new_blocks

    def write_batch(self, data, blocks):
        large_patch_height = min(self.block_size * self.factor, self.height)
        for (x, y), sample in zip(blocks, data):
            if x == 0 and (y % large_patch_height) == 0:
                self._initialize_new_large_patch(y, large_patch_height)
            if not np.all(sample == 0):
                self._write(sample, x, y, y - self.cut_y)
            if self._is_end_of_large_patch(x, y, large_patch_height):
                self.temp_dst.close()
                self.cut_y = y + self.block_size

    def _initialize_new_large_patch(self, y, large_patch_height):
        self.count += 1
        if (large_patch_height + y + self.block_size) >= self.height:
            height = int(self.height - y)
        else:
            height = int(large_patch_height)

        self.large_patch_index.append([0, y])
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            self.temp_dst = rasterio.open(os.path.join(self.temp_path, f"{self.count}.tif"), 'w',
                                          driver='GTiff', width=self.width, height=height, count=1,
                                          dtype=np.float32 if self.confidence_map else np.uint8)

    def _is_end_of_large_patch(self, x, y, large_patch_height):
        return ((x + self.block_size) == self.width and
                ((y + self.block_size) % large_patch_height) == 0 and
                ((y + self.block_size + self.block_size) < self.height))

    def write_large_patch(self):
        if self.region_mask is not None:
            self.region_mask.close()
            os.remove(self.out_region_mask)

        for i, (x, y) in enumerate(self.large_patch_index):
            with warnings.catch_warnings():
                warnings.simplefilter("ignore")
                data = rasterio.open(os.path.join(self.temp_path, f"{i + 1}.tif"))

            w, h = data.width, data.height
            self._write_data_in_chunks(data, x, y, w, h)
            data.close()

        self._clean_up_temp_files()

    def _write_data_in_chunks(self, data, x, y, w, h):
        chunk_size = w // 2
        self.dst.write(data.read(window=Window(0, 0, chunk_size, h), boundless=True),
                       window=Window(x, y, chunk_size, h))
        self.dst.write(data.read(window=Window(chunk_size, 0, w - chunk_size, h), boundless=True),
                       window=Window(x + chunk_size, y, w - chunk_size, h))

    def _clean_up_temp_files(self):
        try:
            shutil.rmtree(self.temp_path)
        except:
            time.sleep(2)
            shutil.rmtree(self.temp_path)

    def __len__(self):
        return math.ceil(len(self.patch_index) / self.batch_size)

    def __getitem__(self, item):
        batch_blocks = self.patch_index[item * self.batch_size:min((item + 1) * self.batch_size, len(self.patch_index))]
        return self.read_batch(batch_blocks)

    def close_src(self):
        self.src.close()
        self.temp_dst.close()

    def close_dst(self):
        self.dst.close()
