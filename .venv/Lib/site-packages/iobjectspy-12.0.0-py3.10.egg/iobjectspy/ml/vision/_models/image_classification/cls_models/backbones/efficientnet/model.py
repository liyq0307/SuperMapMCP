# !/usr/bin/env python3
# coding=utf-8

import os
import copy
import torch
import torch.nn as nn
from efficientnet_pytorch import EfficientNet
from urllib.parse import urlparse
import torch.utils.model_zoo as model_zoo
from torch.hub import _get_torch_home
from .params import url_map, url_map_advprop


class EfficientNetBackbone(nn.Module):
    def __init__(self, model_name, in_channels=3, out_channels=1000):
        super(EfficientNetBackbone, self).__init__()
        """
        :param model_name:  model category, ['efficinetnet-b0','efficinetnet-b1',...,'efficinetnet-b8']
        :param out_channels: class number, redefine the output of the full connection layer of the model
        """

        self._name = model_name
        self._out_channels = out_channels
        self._in_channels = in_channels
        self.efficientnet = EfficientNet.from_name(model_name, override_params={'num_classes': out_channels})
        self.efficientnet_pretrained = self.load_pretrained_weights(self.efficientnet, model_name)
        self.modify_first_conv(self.efficientnet_pretrained, self._in_channels)

    def forward(self, x):
        features = self.efficientnet_pretrained(x)
        return features

    def load_state_dict_ext(self, model_dict, in_channels=3, load_fc=False, **kwargs):
        state_dict = copy.deepcopy(model_dict)
        if not load_fc:
            state_dict.pop("_fc.bias")
            state_dict.pop("_fc.weight")
        if in_channels != 3:
            pretrained_dict = {}
            for i, (k, weight) in enumerate(state_dict.items()):
                if i == 0:
                    if in_channels == 1:
                        weight = weight.sum(1, keepdim=True)
                    elif in_channels == 2:
                        weight = weight[:, :2] * (3.0 / 2.0)
                    else:
                        weight_base = [weight, ] * (in_channels // 3) + [weight[:, :in_channels % 3], ]
                        weight = torch.cat(weight_base, dim=1)
                    pretrained_dict[k] = weight
                else:
                    pretrained_dict[k] = weight
            # overwrite entries in the existing state dict
            state_dict.update(pretrained_dict)
        super().load_state_dict(state_dict, **kwargs)

    def load_weights(self, model_name, model, state_dict, load_fc=False):
        if load_fc:
            model.load_state_dict(state_dict)
        else:
            state_dict.pop('_fc.weight')
            state_dict.pop('_fc.bias')
            res = model.load_state_dict(state_dict, strict=False)
            assert set(res.missing_keys) == set(['_fc.weight', '_fc.bias']), 'issue loading pretrained weights'
        print('Loaded pretrained weights for {}'.format(model_name))

    def load_pretrained_weights(self, model, model_name, load_fc=False, advprop=False):
        """ Loads pretrained weights, and downloads if loading for the first time.
            Loads from a existing file first.
        """
        # AutoAugment or Advprop (different preprocessing)
        url_map_ = url_map_advprop if advprop else url_map
        url = url_map_[model_name]

        parts = urlparse(url)
        filename = os.path.basename(parts.path)
        torch_home = _get_torch_home()
        model_dir = os.path.join(torch_home, 'checkpoints')
        torch_cached_file = os.path.join(model_dir, filename)
        cached_dir = os.path.abspath(os.path.join('..', '..', 'resources_ml', 'backbone'))
        cached_file = os.path.join(cached_dir, filename)
        if os.path.exists(cached_file):
            state_dict = torch.load(cached_file)
            self.load_weights(model_name, model, state_dict, load_fc)
        else:
            try:
                state_dict = model_zoo.load_url(url)
                self.load_weights(model_name, model, state_dict, load_fc)
            except:
                print(
                    'Backbone\'s weight download fails, please download it from the following URL and save it to the directory "{}" or "{}". The download URL is: {}'.format(
                        cached_dir, model_dir, url))
        return model

    def modify_first_conv(self, model, in_channels):
        """Modify first convolution layer input channels.
        In case:
            in_channels == 1 or in_channels == 2 -> reuse original weights
            in_channels > 3 -> make random kaiming normal initialization
        """

        # get first conv
        for module in model.modules():
            if isinstance(module, nn.Conv2d):
                break

        # change input channels for first conv
        module.in_channels = in_channels
        weight = module.weight.detach()
        reset = False

        if in_channels == 1:
            weight = weight.sum(1, keepdim=True)
        elif in_channels == 2:
            weight = weight[:, :2] * (3.0 / 2.0)
        else:
            reset = True
            weight = torch.Tensor(
                module.out_channels,
                module.in_channels // module.groups,
                *module.kernel_size
            )

        module.weight = nn.parameter.Parameter(weight)
        if reset:
            module.reset_parameters()

def efficientnetb0(in_channels, out_channels, **kwargs):
    """Constructs a efficientnet model.

        Args:
            out_channels(int): class
        """
    model = EfficientNetBackbone('efficientnet-b0', in_channels, out_channels)
    return model

def efficientnetb1(in_channels, out_channels, **kwargs):
    """Constructs a efficientnet model.

        Args:
            out_channels(int): class
        """
    model = EfficientNetBackbone('efficientnet-b1', in_channels, out_channels)
    return model

def efficientnetb2(in_channels, out_channels, **kwargs):
    """Constructs a efficientnet model.

        Args:
            out_channels(int): class
        """
    model = EfficientNetBackbone('efficientnet-b2', in_channels, out_channels)
    return model

def efficientnetb3(in_channels, out_channels, **kwargs):
    """Constructs a efficientnet model.

        Args:
            out_channels(int): class
        """
    model = EfficientNetBackbone('efficientnet-b3', in_channels, out_channels)
    return model

def efficientnetb4(in_channels, out_channels, **kwargs):
    """Constructs a efficientnet model.

        Args:
            out_channels(int): class
        """
    model = EfficientNetBackbone('efficientnet-b4', in_channels, out_channels)
    return model

def efficientnetb5(in_channels, out_channels, **kwargs):
    """Constructs a efficientnet model.

        Args:
            out_channels(int): class
        """
    model = EfficientNetBackbone('efficientnet-b5', in_channels, out_channels)
    return model

def efficientnetb6(in_channels, out_channels, **kwargs):
    """Constructs a efficientnet model.

        Args:
            out_channels(int): class
        """
    model = EfficientNetBackbone('efficientnet-b6', in_channels, out_channels)
    return model

def efficientnetb7(in_channels, out_channels, **kwargs):
    """Constructs a efficientnet model.

        Args:
            out_channels(int): class
        """
    model = EfficientNetBackbone('efficientnet-b7', in_channels, out_channels)
    return model