from typing import Optional, Union
from .decoder import Dilatedblock, DLinknetDecoder
from ..base import SegmentationHead, SegmentationModel, ClassificationHead
from ..encoders import get_encoder


class DLinknet(SegmentationModel):
    def __init__(
            self,
            encoder_name: str = "resnet34",
            encoder_depth: int = 5,
            encoder_weights: Optional[str] = "imagenet",
            decoder_use_batchnorm: bool = True,
            in_channels: int = 3,
            classes: int = 1,
            activation: Optional[Union[str, callable]] = None,
            aux_params: Optional[dict] = None,
            siame_encoder: bool = False,
    ):
        super().__init__()

        self.siame_encoder = siame_encoder
        self.encoder = get_encoder(
            encoder_name,
            in_channels=in_channels,
            depth=encoder_depth,
            weights=encoder_weights,
        )

        self.center = Dilatedblock(self.encoder.out_channels[-1])

        self.decoder = DLinknetDecoder(
            encoder_channels=self.encoder.out_channels,
            n_blocks=encoder_depth,
            prefinal_channels=32,
            use_batchnorm=decoder_use_batchnorm,
        )

        self.segmentation_head = SegmentationHead(
            in_channels=32, out_channels=classes, activation=activation, kernel_size=1
        )

        if aux_params is not None:
            self.classification_head = ClassificationHead(
                in_channels=self.encoder.out_channels[-1], **aux_params
            )
        else:
            self.classification_head = None

        self.name = "dlink-{}".format(encoder_name)
        self.initialize()

    def forward(self, x, y=None):
        """Sequentially pass `x` trough model`s encoder, decoder and heads"""
        features = list(self.encoder(x))
        if not y == None:
            features[0] = y
        decoder_output = self.decoder(self.center, *features)

        masks = self.segmentation_head(decoder_output)

        if self.classification_head is not None:
            labels = self.classification_head(features[-1])
            return masks, labels

        return masks
