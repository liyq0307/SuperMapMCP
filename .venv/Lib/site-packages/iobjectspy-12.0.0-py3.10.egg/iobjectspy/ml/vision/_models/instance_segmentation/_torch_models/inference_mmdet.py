# !/usr/bin/env python3
# coding=utf-8
import atexit
import bisect
import importlib
import math
import multiprocessing as mp
import os
import warnings

import cv2
import numpy as np
import pycocotools.mask as mask_util
import rasterio
import yaml
from mmdet.apis import DetInferencer, init_detector, inference_detector
from mmengine.config import Config
from rasterio.plot import reshape_as_image
from rasterio.windows import Window

from iobjectspy.ml.toolkit._toolkit import bounds_transform_coord
from ..utils import nms_all_output, nms_large_output, geo_process_masks_smooth_no_pinjie
from ...device_utils import Device_type
from ...object_detection._mmdet import old_config_name_mapping
from ...object_detection._mmdet.configs._base_ import custom_imports
from .....toolkit._toolkit import view_bar


def import_modules(custom_imports):
    imported_modules = {}
    for module_name in custom_imports["imports"]:
        try:
            imported_modules[module_name] = importlib.import_module(module_name)
        except ImportError as e:
            if custom_imports["allow_failed_imports"]:
                print(f"Warning: Failed to import {module_name} - {e}")
            else:
                raise ImportError(f"Error: Failed to import {module_name}") from e
    return imported_modules


imported_modules = import_modules(custom_imports)


class MmdetEstimation(object):
    def __init__(self, model_path, config, batch_size=1, **kwargs):
        if not isinstance(model_path, str):
            raise TypeError('model_path data type inappropriate ，should be str ')
        if not os.path.exists(model_path):
            raise Exception('model_path  path not exists')
        mp.set_start_method("spawn", force=True)

        self.nms_thresh = kwargs.get('nms_thresh')
        self.score_thresh = kwargs.get('score_thresh')
        self.gpus = kwargs.get('gpus')

        self.batch_size = batch_size
        self.load_model(config, model_path)

    def old2new_config(self, old_config_name):
        new_config_name = old_config_name_mapping[old_config_name]
        return new_config_name

    def load_model(self, config, model_path):
        with open(config, encoding='utf-8') as f:
            config_dict = yaml.load(f, Loader=yaml.FullLoader)
        self.tile_size = config_dict['model']['blocksize']
        self.tile_offset = config_dict['model']['tile_offset']
        self.class_names = config_dict['model']['categorys']

        model_name = os.path.basename(config).split('.')[0] + '.pth'
        model_name = os.path.abspath(os.path.join(config, os.path.pardir, model_name))
        self.cfg = self.read_mmdet_config(config_dict)
        self.device = 'cpu'
        Device_type.setup('cpu')
        if self.gpus is not None:
            if (self.gpus == [-1]) or (self.gpus == []):
                self.device = 'cpu'
            else:
                Device_type.setup()
                if len(self.gpus) == 1:
                    self.device = f'{Device_type._device}:' + ','.join(str(x) for x in self.gpus)
                else:
                    self.device = ['{}:{}'.format(Device_type._device, gpuid) for gpuid in self.gpus]
                    self.batch_size = self.batch_size // len(self.gpus)
                    # if len(self.batch_size) < 1:
                    #     raise ValueError("The number if gpus must be smaller than batch size")
        if len(self.gpus) > 1:
            self.inferencer = AsyncMmdetEstimation(self.cfg, model_name, self.device)
        else:
            if 'cuda' in self.device and os.environ.get("CUDA_VISIBLE_DEVICES"):
                visible_devices_list = [int(x) for x in os.environ.get("CUDA_VISIBLE_DEVICES").split(',')]
                src_idx = int(self.device.split(':')[1])
                if src_idx in visible_devices_list:
                    self.inferencer = init_detector(self.cfg, model_name, palette='coco',
                                                    device=f'cuda:{visible_devices_list.index(src_idx)}')
                elif not visible_devices_list:
                    self.inferencer = init_detector(self.cfg, model_name, palette='coco', device=self.device)
                else:
                    raise Exception(f"GPU {self.device} is not available.")
            else:
                self.inferencer = init_detector(self.cfg, model_name, palette='coco', device=self.device)
            # self.inferencer = DetInferencer(model=self.cfg,
            #                            weights=model_name,
            #                            device=self.device,
            #                            palette='coco',
            #                             show_progress=False)

    def read_mmdet_config(self, config_dict):
        """
        Create configs and perform basic setups.
        """
        base_dir = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
        total_config_path_new = os.path.join(base_dir, 'object_detection', '_mmdet', "configs")
        mm_config_path = os.path.join(total_config_path_new, config_dict['model_architecture'],
                                      config_dict['config_file'] + '.py')
        if not os.path.exists(mm_config_path):
            new_config_name = self.old2new_config(config_dict['config_file'])
            mm_config_path = os.path.join(total_config_path_new, config_dict['model_architecture'],
                                          new_config_name)
        cfg = Config.fromfile(mm_config_path)
        if cfg.model.type == 'RTMDet':
            cfg.model.test_cfg.score_thr = self.score_thresh
            cfg.model.test_cfg.nms.iou_threshold = self.nms_thresh
            cfg.model.bbox_head.num_classes = len(self.class_names)
        elif cfg.model.type == 'MaskRCNN':
            cfg.model.test_cfg.rcnn.score_thr = self.score_thresh
            cfg.model.test_cfg.rcnn.nms.iou_threshold = self.nms_thresh
            cfg.model.roi_head.bbox_head.num_classes = len(self.class_names)
            cfg.model.roi_head.mask_head.num_classes = len(self.class_names)
        return cfg

    def _mmdet_estimate_pic(self, input_data, out_visual_result, out_txt_result):
        from tqdm import tqdm
        if len(input_data) != 0:
            # 遍历每一个子图
            for i in tqdm(input_data):

                image = cv2.imread(i)
                height = image.shape[0]
                width = image.shape[1]
                channel = image.shape[2]

                # 对文件夹内每一个子图进行推理
                boxes, classes_id, scores, masks, leups = self._infer_single(i)
                if boxes is None:
                    continue
                boxes, masks, classes_id, scores, leups = nms_large_output([boxes], masks, [scores], [classes_id],
                                                                           [leups], self.nms_thresh)
                # 得到文件名
                file_name = os.path.basename(i)
                file_name_split = file_name[:-4]
                # mask格式保存为png
                new_name = file_name_split + '.png'
                if len(boxes) != 0:
                    # 根据sda得到background
                    class_name = self.class_names
                    # 保存png
                    self._save_png(new_name, out_visual_result, width, height, channel,
                                   masks, classes_id)
                    # 保存feature_box(xml内置信息)
                    feature_box = []
                    # 遍历nms后保留下的每一个box，按顺序填入feature_box。
                    index = 0
                    for extra_boxes_temp, extra_scores_temp in zip(boxes, scores):
                        list_box = []
                        list_box.append(extra_boxes_temp[0])
                        list_box.append(extra_boxes_temp[1])
                        list_box.append(extra_boxes_temp[2])
                        list_box.append(extra_boxes_temp[3])
                        list_box.append(class_name[classes_id[index]])
                        list_box.append(0)
                        list_box.append(extra_scores_temp)
                        feature_box.append(list_box)
                        index += 1
                    # 保存xml文件
                    self._save_results_txt(out_txt_result, feature_box, file_name_split)

        else:
            print("There is no picture in the path！")

    def _infer_single(self, input_data):
        """
        预测单幅图片
        :return: 掩膜（masks），坐标框（boxes），分类（classes），置信（scores）等
        """
        # 读取
        block = cv2.imread(input_data, cv2.IMREAD_COLOR)
        block = cv2.cvtColor(block, cv2.COLOR_RGB2BGR)
        boxes, class_id, scores, all_masks, all_leups = None, None, None, None, None
        # 推理
        all_masks = []
        if len(self.gpus) > 1:
            output = self.inferencer(block)
            if len(output['predictions'][0]['bboxes']) != 0:
                class_id = np.array(output['predictions'][0]['labels'])
                scores = np.array(output['predictions'][0]['scores'])
                boxes = np.array(output['predictions'][0]['bboxes'])
                masks = output['predictions'][0]['masks']
                for mask in masks:
                    mask_c = np.array(mask_util.decode(mask), dtype=np.uint8)
                    all_masks.append(mask_c)
                all_leups = np.array([[0.0, 0.0]] * len(class_id))
        else:
            output = inference_detector(self.inferencer, block)
            if len(output.pred_instances.bboxes) != 0:
                boxes = np.array(output.pred_instances.bboxes.tolist())
                scores = np.array(output.pred_instances.scores.tolist())
                class_id = np.array(output.pred_instances.labels.tolist())
                masks = np.array(output.pred_instances.masks.tolist())
                # 后處理
                for mask in masks:
                    mask_c = mask + 0
                    mask_c = mask_c.astype(np.uint8)
                    all_masks.append(mask_c)
                all_leups = np.array([[0.0, 0.0]] * len(class_id))

        return boxes, class_id, scores, all_masks, all_leups

    def _save_png(self, file_name, out_data, width, height, channel, masks, scores):

        import random

        # 先画一个背景图
        img = np.zeros((height, width, channel), dtype=np.uint8)
        mv = cv2.split(img)
        # 获取个数
        length = len(scores)

        color_codes_list = [[142, 1, 1], [153, 153, 153], [218, 112, 214], [25, 202, 173], [25, 128, 0], [1, 255, 255],
                            [60, 20, 220], [53, 57, 130], [32, 11, 119], [255, 255, 0], [255, 125, 64], [255, 0, 255]]

        for i in range(length):
            # 随机选择color
            color_codes_temp = random.choice(color_codes_list)
            # 压缩
            mask = np.squeeze(masks[i] > 0.5)
            mv[2][mask == 1], mv[1][mask == 1], mv[0][mask == 1] = \
                [color_codes_temp[2], color_codes_temp[1], color_codes_temp[0]]

        img_out = cv2.merge(mv)
        # 输出图像
        entire_file_name = os.path.join(out_data, file_name)
        result = cv2.imwrite(entire_file_name, img_out)
        return result

    def _save_results_txt(self, out_data, results, indices):

        with open(os.path.join(out_data, indices + '.txt'), 'w', encoding='utf-8') as file:
            for sub in results:
                line = " ".join(map(str, sub))
                file.write(line + "\n")

    def mmdet_estimate_img(self, input_data, outpath, outname, return_bbox, infer_region):

        with rasterio.open(input_data) as ds:
            profile = ds.profile
            all_rois, all_masks, all_scores, all_class_ids, all_leups, transform = \
                self.infer_large(ds, infer_region, is_geo_image=True)

        if len(all_leups) != 0:
            output_dataset_name = nms_all_output(all_rois, all_masks, all_scores, all_class_ids, all_leups, transform,
                                                 self.class_names, outpath, outname,
                                                 self.nms_thresh,
                                                 profile,
                                                 return_bbox=return_bbox)
            return output_dataset_name
        else:
            print("There is no object in the image")

    def estimate_geojson(self, input_data):
        # 将预测结果使用geojson的形式进行返回
        # input_data：预测图片地址
        all_rois, all_masks, all_scores, all_class_ids, all_leups, transform = self.infer_large(
            input_data, is_geo_image=False
        )

        if len(all_leups) != 0:
            extra_rois, extra_masks, extra_class_ids, extra_scores, extra_leups = nms_large_output(
                all_rois, all_masks, all_scores, all_class_ids, all_leups, self.nms_thresh
            )

            extra_rois, extra_scores, extra_class_ids, masks_processed = geo_process_masks_smooth_no_pinjie(
                extra_rois, extra_masks, extra_scores, extra_class_ids, transform, extra_leups, False
            )

            return extra_rois, extra_scores, extra_class_ids, masks_processed
        else:
            print("There is no object in the image")

    def infer_large(self, ds, infer_region=None, is_geo_image=True):

        transform = ds.transform

        # 推理小图的边长
        block_side_length = self.tile_size
        # 推理时每个小图重叠的像素长度
        overlap_pixels = self.tile_size - self.tile_offset

        all_masks = []
        all_class_ids = []
        all_leups = []
        all_rois = []
        all_scores = []

        if infer_region is not None:
            out_path = os.path.join(os.getcwd(), '..', 'example_data')
            with warnings.catch_warnings(record=True) as w:
                rectangle_ymin, rectangle_xmin, bounds, width, height, _, out_mask \
                    = bounds_transform_coord(ds, infer_region, mode='general', to_raster=True, out_path=out_path)
                # rectangle_ymin, rectangle_xmin, bounds, width, height, transform, self.out_region_mask \
                #     = bounds_transform_coord(ds, infer_region, mode='general', to_raster=True, out_path=out_path)

            width_block = math.ceil((width - block_side_length) / overlap_pixels) + 1
            height_block = math.ceil((height - block_side_length) / overlap_pixels) + 1
            block_now = 0
            block_all = height_block * width_block
            if out_mask is not None:
                with rasterio.open(out_mask) as ds_mask:
                    all_rois, all_masks, all_scores, all_class_ids, all_leups = \
                        self.loop_calculation_with_infer_region(ds_mask, ds, height, width, height_block, width_block,
                                                                block_side_length, overlap_pixels,
                                                                rectangle_ymin, rectangle_xmin, block_now, block_all,
                                                                all_rois, all_masks, all_scores, all_class_ids,
                                                                all_leups)
                os.remove(out_mask)
            # 考虑到上层传来的是Rectangle的情况
            else:
                all_rois, all_masks, all_scores, all_class_ids, all_leups = \
                    self.loop_calculation_with_infer_region(None, ds, height, width, height_block, width_block,
                                                            block_side_length, overlap_pixels,
                                                            rectangle_ymin, rectangle_xmin, block_now, block_all,
                                                            all_rois, all_masks, all_scores, all_class_ids, all_leups)
        else:
            width, height = ds.width, ds.height
            rectangle_ymin, rectangle_xmin = 0, 0

            # w_m, h_m = 0, 0
            width_block = math.ceil((width - block_side_length) / overlap_pixels) + 1
            height_block = math.ceil((height - block_side_length) / overlap_pixels) + 1
            block_now = 0
            block_all = height_block * width_block

            all_rois, all_masks, all_scores, all_class_ids, all_leups = \
                self.loop_calculation(ds, height, width, height_block, width_block, block_side_length, overlap_pixels,
                                      block_now, block_all, all_rois, all_masks, all_scores, all_class_ids, all_leups)

        return all_rois, all_masks, all_scores, all_class_ids, all_leups, transform

    def loop_calculation_with_infer_region(self, ds_mask, ds, height, width, height_block, width_block,
                                           block_side_length,
                                           overlap_pixels, rectangle_ymin, rectangle_xmin, block_now, block_all,
                                           all_rois, all_masks, all_scores, all_class_ids, all_leups,
                                           is_geo_image=True):

        for ph in range(height_block):
            start_h = ph * overlap_pixels + rectangle_ymin
            if (start_h + block_side_length) > height + rectangle_ymin:
                if height + rectangle_ymin <= block_side_length:
                    start_h = 0
                    block_side_length = height + rectangle_ymin
                else:
                    # 回退
                    start_h = (height + rectangle_ymin) - block_side_length
            for pw in range(width_block):
                start_w = pw * overlap_pixels + rectangle_xmin
                if (start_w + block_side_length) > width + rectangle_xmin:
                    if width + rectangle_xmin <= block_side_length:
                        start_w = 0
                        block_side_length = width + rectangle_xmin
                    else:
                        # 回退
                        start_w = (width + rectangle_xmin) - block_side_length
                block_now += 1
                if is_geo_image:
                    view_bar(block_now, block_all)

                # Window的参数：起始的列行，取的宽高
                img = ds.read(window=Window(start_w, start_h, block_side_length, block_side_length))
                block = np.zeros([3, block_side_length, block_side_length], dtype=np.uint8)
                block[:, :img.shape[1], :img.shape[2]] = img[:3, :, :]
                block = reshape_as_image(block)
                block = cv2.cvtColor(block, cv2.COLOR_RGB2BGR)

                # 推理
                if len(self.gpus) > 1:
                    output = self.inferencer(block)
                else:
                    output = inference_detector(self.inferencer, block)
                # output = self.inferencer(inputs=block,
                #                         pred_score_thr=0.0001,
                #                         batch_size=self.test_batch_size,
                #                         show=False,
                #                         no_save_vis=False,
                #                         no_save_pred=False,
                #                         print_result=False)
                # 2.0推理接口
                if hasattr(output, 'pred_instances'):
                    if len(output.pred_instances.bboxes) != 0:
                        boxes = np.array(output.pred_instances.bboxes.tolist())
                        boxes[:, [0, 2]] = boxes[:, [0, 2]] + start_w
                        boxes[:, [1, 3]] = boxes[:, [1, 3]] + start_h
                        scores = np.array(output.pred_instances.scores.tolist())
                        class_id = np.array(output.pred_instances.labels.tolist())
                        masks = np.array(output.pred_instances.masks.tolist())
                        # 指定范围推理非Rectangle的情况，有ds_mask
                        if ds_mask is not None:
                            delete_list = []
                            modify_list = []
                            for i, mask in enumerate(masks):
                                mask_c = mask + 0
                                mask_c = mask_c.astype(np.uint8)
                                overlap_matrix = ds_mask.read(window=Window(int(start_w) - rectangle_xmin,
                                                                            int(start_h) - rectangle_ymin,
                                                                            block_side_length, block_side_length))
                                indices = np.squeeze((np.logical_and(mask_c == 1, overlap_matrix == 0)))
                                mask_c[indices] = 0
                                if np.all(mask_c == 0):
                                    delete_list.append(i)
                                else:
                                    all_masks.append(mask_util.encode(np.asfortranarray(mask_c)))
                            all_rois.append(np.delete(boxes, delete_list, axis=0))
                            all_scores.append(np.delete(scores, delete_list, axis=0))
                            all_class_ids.append(np.delete(class_id, delete_list, axis=0))
                            all_leups.append(
                                np.array([[start_w, start_h]] * len(np.delete(class_id, delete_list, axis=0))))
                        # 指定范围推理Rectangle的情况，没有ds_mask，直接是一个矩形
                        else:
                            for mask in masks:
                                mask_c = mask + 0
                                mask_c = mask_c.astype(np.uint8)
                                all_masks.append(mask_c)
                            all_rois.append(boxes)
                            all_scores.append(scores)
                            all_class_ids.append(class_id)
                            all_leups.append(np.array([[start_w, start_h]] * len(class_id)))
                # 3.0推理接口
                else:
                    if len(output['predictions'][0]['bboxes']) != 0:
                        class_id = np.array(output['predictions'][0]['labels'])
                        scores = np.array(output['predictions'][0]['scores'])

                        boxes = np.array(output['predictions'][0]['bboxes'])
                        boxes[:, [0, 2]] = boxes[:, [0, 2]] + start_w
                        boxes[:, [1, 3]] = boxes[:, [1, 3]] + start_h

                        masks = output['predictions'][0]['masks']

                        if ds_mask is not None:
                            delete_list = []
                            modify_list = []
                            for i, mask in enumerate(masks):
                                mask_c = np.array(mask_util.decode(mask), dtype=np.uint8)
                                overlap_matrix = ds_mask.read(window=Window(int(start_w) - rectangle_xmin,
                                                                            int(start_h) - rectangle_ymin,
                                                                            block_side_length, block_side_length))
                                indices = np.squeeze((np.logical_and(mask_c == 1, overlap_matrix == 0)))
                                mask_c[indices] = 0
                                if np.all(mask_c == 0):
                                    delete_list.append(i)
                                else:
                                    all_masks.append(mask_util.encode(np.asfortranarray(mask_c)))
                            all_rois.append(np.delete(boxes, delete_list, axis=0))
                            all_scores.append(np.delete(scores, delete_list, axis=0))
                            all_class_ids.append(np.delete(class_id, delete_list, axis=0))
                            all_leups.append(
                                np.array([[start_w, start_h]] * len(np.delete(class_id, delete_list, axis=0))))
                        else:
                            for mask in masks:
                                all_masks.append(mask)
                            all_rois.append(boxes)
                            all_scores.append(scores)
                            all_class_ids.append(class_id)
                            all_leups.append(np.array([[start_w, start_h]] * len(class_id)))

        return all_rois, all_masks, all_scores, all_class_ids, all_leups

    def loop_calculation(self, ds, height, width, height_block, width_block, block_side_length, overlap_pixels,
                         block_now, block_all,
                         all_rois, all_masks, all_scores, all_class_ids, all_leups, is_geo_image=True):

        batch_blocks = []
        block_positions = []
        for ph in range(height_block):
            start_h = ph * overlap_pixels
            if (start_h + block_side_length) > height:
                if height <= block_side_length:
                    start_h = 0
                    block_side_length = height
                else:
                    # 回退
                    start_h = height - block_side_length
            for pw in range(width_block):
                start_w = pw * overlap_pixels
                if (start_w + block_side_length) > width:
                    if width <= block_side_length:
                        start_w = 0
                        block_side_length = width
                    else:
                        # 回退
                        start_w = width - block_side_length
                block_now += 1
                if is_geo_image:
                    view_bar(block_now, block_all)

                # Window的参数：起始的列行，取的宽高
                img = ds.read(window=Window(start_w, start_h, block_side_length, block_side_length))
                block = np.zeros([3, block_side_length, block_side_length], dtype=np.uint8)
                block[:, :img.shape[1], :img.shape[2]] = img[:3, :, :]
                block = reshape_as_image(block)
                block = cv2.cvtColor(block, cv2.COLOR_RGB2BGR)

                # batch_blocks.append(block)
                # block_positions.append((start_w, start_h))
                # if len(batch_blocks) == self.batch_size:
                # 推理
                if len(self.gpus) > 1:
                    output = self.inferencer(block)
                    # block.clear()
                else:
                    output = inference_detector(self.inferencer, block)
                    # output = self.inferencer(inputs=block,
                    #                          pred_score_thr=0.0001,
                    #                          batch_size=self.test_batch_size,
                    #                          show=False,
                    #                          no_save_vis=False,
                    #                          no_save_pred=False,
                    #                          print_result=False)
                    # batch_blocks.clear()
                if hasattr(output, 'pred_instances'):
                    # for output, (start_w, start_h) in zip(outputs, block_positions):
                    if len(output.pred_instances.bboxes) != 0:
                        boxes = np.array(output.pred_instances.bboxes.tolist())
                        boxes[:, [0, 2]] = boxes[:, [0, 2]] + start_w
                        boxes[:, [1, 3]] = boxes[:, [1, 3]] + start_h

                        scores = np.array(output.pred_instances.scores.tolist())
                        class_id = np.array(output.pred_instances.labels.tolist())
                        masks = np.array(output.pred_instances.masks.tolist())

                        for mask in masks:
                            mask = (mask + 0).astype(np.uint8)
                            all_masks.append(mask)
                        all_rois.append(boxes)
                        all_scores.append(scores)
                        all_class_ids.append(class_id)
                        all_leups.append(np.array([[start_w, start_h]] * len(class_id)))
                else:
                    # for output, (start_w, start_h) in zip(outputs, block_positions):
                    if len(output['predictions'][0]['bboxes']) != 0:
                        class_id = np.array(output['predictions'][0]['labels'])
                        scores = np.array(output['predictions'][0]['scores'])

                        boxes = np.array(output['predictions'][0]['bboxes'])
                        boxes[:, [0, 2]] = boxes[:, [0, 2]] + start_w
                        boxes[:, [1, 3]] = boxes[:, [1, 3]] + start_h

                        masks = output['predictions'][0]['masks']

                        for mask in masks:
                            all_masks.append(mask)
                        all_rois.append(boxes)
                        all_scores.append(scores)
                        all_class_ids.append(class_id)
                        all_leups.append(np.array([[start_w, start_h]] * len(class_id)))

        return all_rois, all_masks, all_scores, all_class_ids, all_leups

    def close_model(self):
        Device_type.empty_cache()


class AsyncMmdetEstimation:
    class _StopToken:
        pass

    class _PredictWorker(mp.Process):
        def __init__(self, cfg, model_name, gpuid, task_queue, result_queue):
            self.gpuid = gpuid
            self.cfg = cfg
            self.model_name = model_name
            self.task_queue = task_queue
            self.result_queue = result_queue
            super().__init__()

        def run(self):
            # self.inferencer = init_detector(self.cfg, self.model_name, palette='coco', device=self.gpuid)

            if ((os.path.basename(self.cfg.filename)).split('-'))[0] == 'redet':
                scope = 'mmrotate'
            else:
                scope = 'mmdet'

            self.inferencer = DetInferencer(model=self.cfg,
                                            weights=self.model_name,
                                            device=self.gpuid,
                                            scope=scope,
                                            palette='coco',
                                            show_progress=False)
            while True:
                task = self.task_queue.get()
                if isinstance(task, AsyncMmdetEstimation._StopToken):
                    break
                idx, data = task
                # result = inference_detector(self.inferencer, data)
                result = self.inferencer(inputs=data,
                                         pred_score_thr=0.0001,
                                         show=False,
                                         no_save_vis=False,
                                         no_save_pred=False,
                                         print_result=False)
                self.result_queue.put((idx, result))

    def __init__(self, cfg, model, device):
        """
        Args:
            cfg (CfgNode):
            num_gpus (int): if 0, will run on CPU
        """

        num_workers = max(len(device), 1)
        self.task_queue = mp.Queue(maxsize=num_workers * 3)
        self.result_queue = mp.Queue(maxsize=num_workers * 3)
        self.procs = []

        for i, gpuid in enumerate(device):
            self.procs.append(
                AsyncMmdetEstimation._PredictWorker(cfg, model, gpuid, self.task_queue, self.result_queue)
            )

        self.put_idx = 0
        self.get_idx = 0
        self.result_rank = []
        self.result_data = []

        for p in self.procs:
            p.start()
        atexit.register(self.shutdown)

    def put(self, image):
        self.put_idx += 1
        self.task_queue.put((self.put_idx, image))

    def get(self):
        self.get_idx += 1  # the index needed for this request
        if len(self.result_rank) and self.result_rank[0] == self.get_idx:
            res = self.result_data[0]
            del self.result_data[0], self.result_rank[0]
            return res

        while True:
            # make sure the results are returned in the correct order
            idx, res = self.result_queue.get()
            if idx == self.get_idx:
                return res
            insert = bisect.bisect(self.result_rank, idx)
            self.result_rank.insert(insert, idx)
            self.result_data.insert(insert, res)

    def __len__(self):
        return self.put_idx - self.get_idx

    def __call__(self, image):
        self.put(image)
        return self.get()

    def shutdown(self):
        for _ in self.procs:
            self.task_queue.put(AsyncMmdetEstimation._StopToken())

    @property
    def default_buffer_size(self):
        return len(self.procs) * 5
