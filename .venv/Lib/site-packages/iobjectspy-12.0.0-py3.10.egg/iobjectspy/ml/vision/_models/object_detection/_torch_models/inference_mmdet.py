#!/usr/bin/env python
# encoding: utf-8
import os

import yaml
from mmdet.apis import init_detector, inference_detector
from mmengine.config import Config

from iobjectspy.ml.vision._models.instance_segmentation._torch_models.inference_mmdet import AsyncMmdetEstimation
from iobjectspy.ml.vision._models.object_detection._torch_models.ob_inference_base import ODEstimation
from .._mmdet import old_config_name_mapping

"""
影像数据目标检测
"""


class MmdetEstimation(ODEstimation):

    def load_model(self):

        with open(self.config, encoding='utf-8') as f:
            config_dict = yaml.load(f, Loader=yaml.FullLoader)

        self.class_names = config_dict['model']['categorys']
        self.tile_size = config_dict['model']['blocksize']
        self.tile_offset_size = config_dict['model']['tile_offset']
        self.development_kit = config_dict['development_kit']
        model_name = os.path.basename(self.config).split('.')[0] + '.pth'
        model_name = os.path.abspath(os.path.join(self.config, os.path.pardir, model_name))
        cfg = self.read_mmdet_config(config_dict)
        if len(self.gpus) > 1:
            self.inferencer = AsyncMmdetEstimation(cfg, model_name, self.device)
        else:
            self.inferencer = init_detector(cfg, model_name, palette='coco', device=self.device)

    def old2new_config(self, old_config_name):
        new_config_name = old_config_name_mapping[old_config_name]
        return new_config_name

    def read_mmdet_config(self, config_dict):
        """
        Create configs and perform basic setups.
        """
        base_dir = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))

        total_config_path_new = os.path.join(base_dir, 'object_detection', '_mmdet', "configs")
        mm_config_path = os.path.join(total_config_path_new, config_dict['model_architecture'],
                                      config_dict['config_file'] + '.py')
        if not os.path.exists(mm_config_path):
            new_config_name = self.old2new_config(config_dict['config_file'])
            mm_config_path = os.path.join(total_config_path_new, config_dict['model_architecture'],
                                          new_config_name)
        cfg = Config.fromfile(mm_config_path)
        if cfg.model.type == 'RTMDet':
            cfg.model.test_cfg.score_thr = self.score_thresh
            cfg.model.test_cfg.nms.iou_threshold = self.nms_thresh
            cfg.model.bbox_head.num_classes = len(self.class_names)
        elif cfg.model.type == 'CascadeRCNN':
            cfg.model.test_cfg.rcnn.score_thr = self.score_thresh
            cfg.model.test_cfg.rcnn.nms.iou_threshold = self.nms_thresh
            cfg.model.roi_head.bbox_head[0].num_classes = len(self.class_names)
            cfg.model.roi_head.bbox_head[1].num_classes = len(self.class_names)
            cfg.model.roi_head.bbox_head[2].num_classes = len(self.class_names)

        return cfg

    def return_inference_result(self, ds, all_boxes, block_xmin, block_ymin, block, infer_region):
        # 推理
        if len(self.gpus) > 1:
            results_origin = self.inferencer(block)
        else:
            results_origin = inference_detector(self.inferencer, block)

        all_boxes = self._det2str(results_origin, block_xmin, block_ymin)

        return all_boxes

    def _det2str(self, results_origin, block_xmin, block_ymin):
        results_convert = []
        if hasattr(results_origin, 'pred_instances'):
            results_convert_bboxes = results_origin.pred_instances.bboxes.tolist()
            results_convert_scores = results_origin.pred_instances.scores.tolist()
            results_convert_labels = results_origin.pred_instances.labels.tolist()
        else:
            results_convert_bboxes = results_origin['predictions'][0]['bboxes']
            results_convert_scores = results_origin['predictions'][0]['scores']
            results_convert_labels = results_origin['predictions'][0]['labels']
        if len(results_convert_bboxes) != 0:
            for i in range(len(results_convert_bboxes)):
                result_temp = []
                bbox = results_convert_bboxes[i]
                bbox = [bbox[0] + block_xmin, bbox[1] + block_ymin,
                        bbox[2] + block_xmin, bbox[3] + block_ymin]
                score = results_convert_scores[i]
                label = results_convert_labels[i]
                label2name = self.class_names[label]
                result_temp.append(bbox[0])
                result_temp.append(bbox[1])
                result_temp.append(bbox[2])
                result_temp.append(bbox[3])
                result_temp.append(score)
                result_temp.append(label2name)
                results_convert.append(result_temp)

        return results_convert
