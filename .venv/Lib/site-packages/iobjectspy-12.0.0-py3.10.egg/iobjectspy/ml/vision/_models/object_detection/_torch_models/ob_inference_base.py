#!/usr/bin/env python
# encoding: utf-8
import shapely
import shapely.speedups
shapely.speedups.disable()
from shapely.geometry import Polygon, MultiPoint  # 多边形
import logging
import os
import sys
import time
import warnings
import cv2
import numpy as np
import importlib
import rasterio
from rasterio import transform
from rasterio.plot import reshape_as_image
from rasterio.windows import Window
from mmrotate.structures.bbox.box_converters import rbox2qbox
from iobjectspy.ml.toolkit._toolkit import bounds_transform_coord
from iobjectspy import FieldType, DatasetType
from iobjectspy import GeoRegion, Feature, FieldInfo
from iobjectspy._jsuperpy.data._util import get_output_datasource, DatasetType, FieldType
from ...device_utils import Device_type
from ...object_detection._mmdet.configs._base_ import custom_imports


def import_modules(custom_imports):
    imported_modules = {}
    for module_name in custom_imports["imports"]:
        try:
            imported_modules[module_name] = importlib.import_module(module_name)
        except ImportError as e:
            if custom_imports["allow_failed_imports"]:
                print(f"Warning: Failed to import {module_name} - {e}")
            else:
                raise ImportError(f"Error: Failed to import {module_name}") from e
    return imported_modules
imported_modules = import_modules(custom_imports)
"""
影像数据目标检测
"""


class ODEstimation(object):
    def __init__(self, model_path, config, nms_thresh, score_thresh, gpus=None, batch_size=None):
        if not isinstance(model_path, str):
            raise TypeError('model_path data type inappropriate ，should be str ')
        if not os.path.exists(model_path):
            raise Exception('model_path  path not exists')

        self.model_path = model_path
        self.config = config
        if nms_thresh is not None:
            self.nms_thresh = nms_thresh
        if score_thresh is not None:
            self.score_thresh = score_thresh
        if batch_size is not None:
            self.batch_size = batch_size
        else:
            self.batch_size = 1
        self.device = 'cpu'
        Device_type.setup('cpu')
        self.gpus = gpus
        if self.gpus is not None:
            if (self.gpus == [-1]) or (self.gpus == []):
                self.device = 'cpu'
            else:
                Device_type.setup()
                if len(self.gpus) == 1:
                    self.device = f'{Device_type._device}:' + ','.join(str(x) for x in self.gpus)
                else:
                    self.device = ['{}:{}'.format(Device_type._device, gpuid) for gpuid in self.gpus]
                    self.batch_size = self.batch_size // len(self.gpus)
        if len(self.gpus) > 1:
            import torch
            torch.multiprocessing.set_start_method('spawn',force=True)
        self.load_model()
        self.i = 0
    def load_model(self):
        pass

    def save_results_txt(self, out_data, results, indices):

        with open(os.path.join(out_data, indices+'.txt'), 'w', encoding='utf-8') as file:
            for sub in results:
                line = " ".join(map(str, sub))
                file.write(line + "\n")

    def estimation_numpy(self, input_data, out_data, out_name, category_name):
        # 返回值位numpy

        self._estimation_numpy(input_data, out_data,
                               out_name, category_name)

    def estimation_img(self, input_data, out_data, out_name, category_name,infer_region):
        """
        影像目标检测
        Args:
            input_data (str): 输入文件路径
            out_data (str): 输出文件路径
            out_name (str) : 输出数据集名称
            category_name (list[dict]): 类别

        Returns:

        """

        result = self._estimation_img(input_data, out_data,
                                      out_name, category_name, infer_region)

        return result

    def estimation_pic(self, input_data, out_data, out_name, category_name):
        """
        图片目标检测
        Args:
            input_data (str): 输入文件路径
            out_data (str): 输出文件路径
            out_name (str) : 输出数据集名称
            category_name (list[dict]): 类别

        Returns:

        """
        save_path = os.path.join(out_data, out_name)
        if not os.path.exists(save_path):
            os.makedirs(save_path)
        out_result_dict_arr = []
        # if len(input_data) == 1:
        #     for i in input_data:
        #         temp_out_result_dict = self._estimation_pic(i, out_data, os.path.basename(i).split(".")[0]+out_name, category_name)
        #         out_result_dict_arr.append(temp_out_result_dict)
        # else:
        for i in input_data:
            temp_out_result_dict = self._estimation_pic(i, save_path, os.path.basename(i).split(".")[0], category_name)
            out_result_dict_arr.append(temp_out_result_dict)

    def estimation_pic_single_json(self, input_data, category_name):
        """
        文件夹目标检测
        Args:
            input_data (str): 输入文件路径
            category_name (list[dict]): 类别

        Returns:

        """
        result = self._estimation_pic_single_json(input_data, category_name)

        return result

    def _estimation_pic(self, input_data, out_data, out_name, category_name):
        """
        进行图像数据目标检测
        """

        with rasterio.open(input_data, encoding='utf-8') as ds:
            width = ds.width
            height = ds.height
            width_block = ds.width // self.tile_offset_size + 1
            height_block = ds.height // self.tile_offset_size + 1
            width_block = int(width_block)
            height_block = int(height_block)

            all_boxes = []
            # # 记录一个像素占据地理坐标的比率
            # one_pixel = 1
            # try:
            #     one_pixel = ds.res[0]
            # except:
            #     pass
            cost_times = 0
            estimation_type = 'picture'
            if (ds.height <= self.tile_size) | (ds.width <= self.tile_size):
                all_boxes, cost_times = self._get_bbox(ds, None, -1, -1, height, width, 0, 0,
                                                       all_boxes, cost_times, estimation_type)
                logging.info('cost times is ()'.format(cost_times))
                logging.info('()： Width and height less than or equal to ()'.format(input_data, self.tile_size))
            else:
                # 记录程序运行进度条
                p = 0
                for i in range(height_block):
                    for j in range(width_block):
                        all_boxes, cost_times = self._get_bbox(ds, None, j, i, height, width, 0, 0,
                                                               all_boxes, cost_times, estimation_type)
                        logging.info('cost times is ()'.format(cost_times))
                        p += 1
                        self._view_bar(p, (height_block) * (width_block))
                print('')
                logging.info('()： Width and height is greater than ()'.format(input_data, self.tile_size))

            # 对all_boxes中所有的框整体去重
            num_objects = 0
            feature_box = []
            import json
            jsons = []
            classes = []

            for cls_ind, cls in enumerate(self.class_names[0:]):
                all_boxes_temp = self._get_target_boxes_for_each_category(ds, category_name, cls, all_boxes,
                                                                          estimation_type)

                for bbox_score in all_boxes_temp:
                    list_box = []
                    list_box.append(int(bbox_score[0]))
                    list_box.append(int(bbox_score[1]))
                    list_box.append(int(bbox_score[2]))
                    list_box.append(int(bbox_score[3]))
                    list_box.append(cls)
                    list_box.append(round(bbox_score[4], 2))
                    feature_box.append(list_box)
                    json_dir = {}
                    json_dir["type"] = "Polygon"
                    json_dir["coordinates"] = [[[bbox_score[0], height - bbox_score[3]],
                                                [bbox_score[2], height - bbox_score[3]],
                                                [bbox_score[2], height - bbox_score[1]],
                                                [bbox_score[0], height - bbox_score[1]],
                                                [bbox_score[0], height - bbox_score[3]]]]
                    jsons.append(json.dumps(json_dir))
                    classes.append(self.class_names.index(cls))
            # self._save_xml(out_data, feature_box, width, height,
            #                out_name + '.' + input_data.split(".")[-1], input_data.split(".")[-1],
            #                ds.count)
            self.save_results_txt(out_data, feature_box, out_name)
        return 1, num_objects

    def _estimation_pic_single_json(self, input_data, category_name):
        """
        进行影像数据目标检测
        """

        with rasterio.open(input_data, encoding='utf-8') as ds:
            width = ds.width
            height = ds.height
            width_block = ds.width // self.tile_offset_size + 1
            height_block = ds.height // self.tile_offset_size + 1
            width_block = int(width_block)
            height_block = int(height_block)

            all_boxes = []

            cost_times = 0
            estimation_type = 'picture'
            if (ds.height <= self.tile_size) | (ds.width <= self.tile_size):
                all_boxes, cost_times = self._get_bbox(ds, -1, -1, height, width, 0, 0,
                                                       all_boxes, cost_times, estimation_type)
                logging.info('cost times is ()'.format(cost_times))
                logging.info('()： Width and height less than or equal to ()'.format(input_data, self.tile_size))
            else:
                # 记录程序运行进度条
                p = 0
                for i in range(height_block):
                    for j in range(width_block):
                        all_boxes, cost_times = self._get_bbox(ds, j, i, height, width, 0, 0,
                                                               all_boxes, cost_times, estimation_type)
                        logging.info('cost times is ()'.format(cost_times))
                        p += 1
                        self._view_bar(p, (height_block) * (width_block))
                print('')
                logging.info('()： Width and height is greater than ()'.format(input_data, self.tile_size))

            # 对all_boxes中所有的框整体去重

            feature_box = []
            import json
            jsons = []
            classes = []

            for cls_ind, cls in enumerate(self.class_names[0:]):
                all_boxes_temp = self._get_target_boxes_for_each_category(ds, category_name, cls, all_boxes,
                                                                          estimation_type)

                for bbox_score in all_boxes_temp:
                    list_box = []
                    list_box.append(bbox_score[0])
                    list_box.append(bbox_score[1])
                    list_box.append(bbox_score[2])
                    list_box.append(bbox_score[3])
                    list_box.append(cls)
                    list_box.append(0)
                    list_box.append(bbox_score[4])
                    feature_box.append(list_box)
                    json_dir = {}
                    json_dir["type"] = "Polygon"
                    json_dir["coordinates"] = [[[bbox_score[0], height - bbox_score[3]],
                                                [bbox_score[2], height - bbox_score[3]],
                                                [bbox_score[2], height - bbox_score[1]],
                                                [bbox_score[0], height - bbox_score[1]],
                                                [bbox_score[0], height - bbox_score[3]]]]
                    jsons.append(json.dumps(json_dir))
                    classes.append(self.class_names.index(cls))

        return classes, jsons

    def _estimation_img(self, input_data, out_data, out_name, category_name, infer_region=None):
        """
        进行影像数据目标检测
        """
        features = []
        ds = get_output_datasource(out_data)
        adjust_name = True
        if not ds.is_available_dataset_name(out_name) and adjust_name:
            out_name = ds.get_available_dataset_name(out_name)
        bbox_dataset = ds.create_vector_dataset(out_name, DatasetType.REGION, adjust_name=adjust_name)
        type_class = FieldInfo("class_type", FieldType.TEXT, max_length=50)
        type_score = FieldInfo("scores", FieldType.DOUBLE, max_length=50)

        bbox_dataset.create_field(type_class)
        bbox_dataset.create_field(type_score)

        estimation_type = 'img'
        with rasterio.open(input_data, encoding='utf-8') as ds:
            profile = ds.profile
            if profile.get("crs"):
                bbox_dataset.set_prj_coordsys(profile.get("crs").to_wkt())

            if infer_region is not None:
                out_path = os.path.join(os.getcwd(), '..', 'out')
                with warnings.catch_warnings(record=True) as w:
                    rectangle_ymin, rectangle_xmin, bounds, width, height, transform, out_mask \
                        = bounds_transform_coord(ds, infer_region, mode='general', to_raster=True,
                                                 out_path=out_path)
                width_block = width // self.tile_offset_size + 1
                height_block = height // self.tile_offset_size + 1
                width_block = int(width_block)
                height_block = int(height_block)

                if out_mask is not None:
                    with rasterio.open(out_mask) as ds_mask:
                        all_boxes = self.loop_calculation(ds, ds_mask, height, width, rectangle_ymin, rectangle_xmin, estimation_type,
                                                      input_data, height_block, width_block, infer_region)
                    os.remove(out_mask)
                # 考虑到上层传来的是Rectangle的情况
                else:
                    all_boxes = self.loop_calculation(ds, None, height, width, rectangle_ymin, rectangle_xmin,
                                                      estimation_type,
                                                      input_data, height_block, width_block, infer_region)

            else:
                width, height = ds.width, ds.height
                rectangle_ymin, rectangle_xmin = 0, 0

                width_block = width // self.tile_offset_size + 1
                height_block = height // self.tile_offset_size + 1
                width_block = int(width_block)
                height_block = int(height_block)

                all_boxes = self.loop_calculation(ds, None, height, width, rectangle_ymin, rectangle_xmin, estimation_type,
                                                 input_data, height_block, width_block, infer_region)

            # 对all_boxes中所有的框整体去重
            for cls_ind, cls in enumerate(self.class_names[0:]):

                all_boxes_temp = self._get_target_boxes_for_each_category(ds, category_name, cls, all_boxes,
                                                                          estimation_type)
                if hasattr(self, 'development_kit') and self.development_kit == 'mmrotate':
                    for box in all_boxes_temp:
                        points = [(box[0], box[1]),
                                  (box[2], box[3]),
                                  (box[4], box[5]),
                                  (box[6], box[7]),
                                  (box[0], box[1])]
                        region = GeoRegion(points=points)
                        features.append(Feature(region, {"class_type": cls, "scores": box[-1]},
                                                field_infos=[type_class, type_score]))
                else:
                    for bbox_score in all_boxes_temp:
                        points = [(float(bbox_score[0]), float(bbox_score[3])),
                                  (float(bbox_score[2]), float(bbox_score[3])),
                                  (float(bbox_score[2]), float(bbox_score[1])),
                                  (float(bbox_score[0]), float(bbox_score[1])),
                                  (float(bbox_score[0]), float(bbox_score[3]))]
                        region = GeoRegion(points=points)
                        features.append(Feature(region, {"class_type": cls, "scores": bbox_score[4]},
                                                field_infos=[type_class, type_score]))
            bbox_dataset.append(features)
            bbox_dataset.close()

        return out_name

    def loop_calculation(self, ds, ds_mask, height, width, rectangle_ymin, rectangle_xmin,
                                           estimation_type, input_data, height_block, width_block, infer_region):

        all_boxes = []

        cost_times = 0
        if (height <= self.tile_size) | (width <= self.tile_size):

            all_boxes, cost_times = self._get_bbox(ds, ds_mask, -1, -1,  height, width, rectangle_ymin, rectangle_xmin,
                                                   all_boxes, cost_times, estimation_type, infer_region)
            logging.info('cost times is ()'.format(cost_times))
            logging.info('()： Width and height less than or equal to ()'.format(input_data, self.tile_size))
        else:
            # 记录程序运行进度条
            p = 0
            for i in range(height_block):
                for j in range(width_block):
                    all_boxes, cost_times = self._get_bbox(ds, ds_mask, j, i,  height, width, rectangle_ymin,
                                                           rectangle_xmin, all_boxes, cost_times, estimation_type,
                                                           infer_region)
                    logging.info('cost times is ()'.format(cost_times))
                    p += 1
                    self._view_bar(p, (height_block) * (width_block))
            print('')
            logging.info('()： Width and height is greater than ()'.format(input_data, self.tile_size))

        return all_boxes


    def _get_target_boxes_for_each_category(self, ds, category_name, cls, all_boxes, estimation_type):

        all_boxes_temp = []
        all_boxes_temp_ = []
        all_scores_temp = []
        transf = ds.transform
        height = ds.height

        if hasattr(self, 'development_kit') and self.development_kit == 'mmrotate':
            all_boxes_temp_rotate = []
            if cls in category_name:
                for i in all_boxes:
                    if cls == i[2] and i[1] >= self.score_thresh:
                        all_boxes_temp_rotate.append(i)
                        all_boxes_temp.append(i[0])
                        all_scores_temp.append(i[1])
                all_boxes_temp_rotate = np.array(all_boxes_temp_rotate)
                all_boxes_temp = np.array(all_boxes_temp)
                all_scores_temp = np.array(all_scores_temp)
                if (all_boxes_temp != np.array([])):
                    keep = self.non_max_suppression_rotate(all_boxes_temp, all_scores_temp)
                    all_boxes_temp_rotate = all_boxes_temp_rotate[keep, :]

            if (ds.crs is None) & (transf[4] == 1):
                for i in all_boxes_temp_rotate:
                    all_boxes_temp_.append(
                        [float(i[0][0]), float(height - float(i[0][1])),
                         float(i[0][2]), float(height - float(i[0][3])),
                         float(i[0][4]), float(height - float(i[0][5])),
                         float(i[0][6]), float(height - float(i[0][7])), float(i[1])])
            else:
                for i in all_boxes_temp_rotate:
                    coord_1 = transform.xy(transf, float(i[0][1]), float(i[0][0]))
                    coord_2 = transform.xy(transf, float(i[0][3]), float(i[0][2]))
                    coord_3 = transform.xy(transf, float(i[0][5]), float(i[0][4]))
                    coord_4 = transform.xy(transf, float(i[0][7]), float(i[0][6]))

                    x1, y1 = coord_1[0], coord_1[1]
                    x2, y2 = coord_2[0], coord_2[1]
                    x3, y3 = coord_3[0], coord_3[1]
                    x4, y4 = coord_4[0], coord_4[1]

                    all_boxes_temp_.append(
                        [float(x1), float(y1),
                         float(x2), float(y2),
                         float(x3), float(y3),
                         float(x4), float(y4),
                         float(i[1])])
        else:
            if category_name is None:
                for i in all_boxes:
                    if cls == i[5] and i[4] >= self.score_thresh:
                        all_boxes_temp.append(i[0:5])
                all_boxes_temp = np.array(all_boxes_temp)
                if (all_boxes_temp != np.array([])):
                    keep = self.nms(all_boxes_temp)
                    all_boxes_temp = all_boxes_temp[keep, :]
            else:
                if cls in category_name:
                    for i in all_boxes:
                        if cls == i[5] and i[4] >= self.score_thresh:
                            all_boxes_temp.append(i[0:5])
                    all_boxes_temp = np.array(all_boxes_temp)
                    if (all_boxes_temp != np.array([])):
                        keep = self.nms(all_boxes_temp)
                        all_boxes_temp = all_boxes_temp[keep, :]

            for i in all_boxes_temp:
                if estimation_type == 'picture':
                    all_boxes_temp_.append(
                        [float(i[0]), float(i[1]),
                         float(i[2]),
                         float(i[3]),
                         float(i[4])])

                elif (ds.crs is None) & (transf[4] == 1):
                    all_boxes_temp_.append(
                        [float(i[0]), float(height - float(i[1])),
                         float(i[2]),
                         float(height - float(i[3])),
                         float(i[4])])
                else:
                    coord_min = transform.xy(transf, float(i[1]), float(i[0]))
                    coord_max = transform.xy(transf, float(i[3]), float(i[2]))
                    xmin = coord_min[0]
                    ymin = coord_max[1]
                    xmax = coord_max[0]
                    ymax = coord_min[1]
                    all_boxes_temp_.append(
                        [float(xmin), float(ymin), float(xmax), float(ymax),
                         float(i[4])])
        return all_boxes_temp_

    def _estimation_numpy(self, input_data, out_data, out_name, category_name):
        """
        进行影像数据目标检测
        """
        features = []
        ds = get_output_datasource(out_data)
        adjust_name = True
        if not ds.is_available_dataset_name(out_name) and adjust_name:
            out_name = ds.get_available_dataset_name(out_name)
        bbox_dataset = ds.create_vector_dataset(out_name, DatasetType.REGION, adjust_name=adjust_name)
        type_class = FieldInfo("class_type", FieldType.TEXT, max_length=50)
        type_score = FieldInfo("scores", FieldType.DOUBLE, max_length=50)

        bbox_dataset.create_field(type_class)
        bbox_dataset.create_field(type_score)

        with rasterio.open(input_data, encoding='utf-8') as ds:
            width_block = ds.width // self.tile_offset_size + 1
            height_block = ds.height // self.tile_offset_size + 1
            width_block = int(width_block)
            height_block = int(height_block)

            all_boxes = []
            one_pixel = 1
            try:
                one_pixel = ds.res[0]
            except:
                pass
            estimation_type = 'img'
            cost_times = 0
            if (ds.height <= self.tile_size) | (ds.width <= self.tile_size):
                all_boxes, cost_times = self._get_bbox(ds, -1, -1, ds.height, ds.width, 0, 0,
                                                       all_boxes, cost_times, estimation_type)
                logging.info('cost times is ()'.format(cost_times))
                logging.info('()： Width and height less than or equal to ()'.format(input_data, self.tile_size))
            else:
                # 记录程序运行进度条
                p = 0
                for i in range(height_block):
                    for j in range(width_block):
                        all_boxes, cost_times = self._get_bbox(ds, j, i, ds.height, ds.width, 0, 0,
                                                               all_boxes, cost_times, estimation_type)
                        logging.info('cost times is ()'.format(cost_times))
                        p += 1
                        self._view_bar(p, (height_block) * (width_block))
                print('')
                logging.info('()： Width and height is greater than ()'.format(input_data, self.tile_size))

            # 对all_boxes中所有的框整体去重
            for cls_ind, cls in enumerate(self.class_names[0:]):
                all_boxes_temp = []
                if category_name is None:
                    for i in all_boxes:
                        if cls == i[5] and i[4] >= self.score_thresh:
                            all_boxes_temp.append(i[0:5])
                    all_boxes_temp = np.array(all_boxes_temp)
                    if (all_boxes_temp != np.array([])):
                        keep = self.nms(all_boxes_temp, one_pixel)
                        all_boxes_temp = all_boxes_temp[keep, :]
                else:
                    if cls in category_name:
                        for i in all_boxes:
                            if cls == i[5] and i[4] >= self.score_thresh:
                                all_boxes_temp.append(i[0:5])
                        all_boxes_temp = np.array(all_boxes_temp)
                        if (all_boxes_temp != np.array([])):
                            keep = self.nms(all_boxes_temp, one_pixel)
                            all_boxes_temp = all_boxes_temp[keep, :]

                for bbox_score in all_boxes_temp:
                    points = [(float(bbox_score[0]), float(bbox_score[3])),
                              (float(bbox_score[2]), float(bbox_score[3])),
                              (float(bbox_score[2]), float(bbox_score[1])),
                              (float(bbox_score[0]), float(bbox_score[1])),
                              (float(bbox_score[0]), float(bbox_score[3]))]
                    region = GeoRegion(points=points)
                    features.append(Feature(region, {"class_type": cls, "scores": bbox_score[4]},
                                            field_infos=[type_class, type_score]))

        return features

    def _save_xml(self, output_path_label, lists, width, height, pic_name, tile_format, depth):
        """
          生成xml描述文件

          :param output_path_label: 输入标签文件存储路径
          :type output_path_label: str
          :param lists: 包含bbox，category，difficult信息
          :type lists: list
          :param width: 图像宽度
          :type width: Long
          :param height: 图像高度
          :type height: Long
          :param pic_name: 对应标签文件的图片名称
          :type pic_name: str
          :param tile_format: 切片的图像格式:TIFF,PNG,JPG
          :type tile_format: str

          """
        if tile_format == 'jpg' or tile_format == 'png':
            depth = 3
        from lxml.etree import Element, SubElement, tostring

        node_root = Element('annotation')

        node_folder = SubElement(node_root, 'folder')
        node_folder.text = 'VOC'

        node_filename = SubElement(node_root, 'filename')
        node_filename.text = pic_name

        node_size = SubElement(node_root, 'size')
        node_width = SubElement(node_size, 'width')
        node_width.text = '%s' % width

        node_height = SubElement(node_size, 'height')
        node_height.text = '%s' % height

        node_depth = SubElement(node_size, 'depth')
        node_depth.text = '%s' % depth

        node_segmented = SubElement(node_root, 'segmented')
        node_segmented.text = '%s' % 0

        for list in lists:
            node_object = SubElement(node_root, 'object')
            node_name = SubElement(node_object, 'name')
            node_name.text = str(list[4])
            node_difficult = SubElement(node_object, 'difficult')
            node_difficult.text = str(list[5])
            node_truncated = SubElement(node_object, 'truncated')
            node_truncated.text = str(0)
            node_score = SubElement(node_object, 'score')
            node_score.text = '%s' % list[6]
            node_bndbox = SubElement(node_object, 'bndbox')
            node_xmin = SubElement(node_bndbox, 'xmin')
            node_xmin.text = '%s' % list[0]
            node_ymin = SubElement(node_bndbox, 'ymin')
            node_ymin.text = '%s' % list[1]
            node_xmax = SubElement(node_bndbox, 'xmax')
            node_xmax.text = '%s' % list[2]
            node_ymax = SubElement(node_bndbox, 'ymax')
            node_ymax.text = '%s' % list[3]
        xml = tostring(node_root, pretty_print=True, encoding='UTF-8')
        save_xml = os.path.join(output_path_label, pic_name.split('.')[0] + '.xml')

        with open(save_xml, 'wb') as f:
            f.write(xml)

    def nms(self, dets, one_pixel=1):
        """
            nms,去除重复框
        """
        # x1、y1、x2、y2、以及score赋值
        x1 = dets[:, 0]
        y1 = dets[:, 1]
        x2 = dets[:, 2]
        y2 = dets[:, 3]
        scores = dets[:, 4]

        # 每一个检测框的面积
        areas = (x2 - x1 + one_pixel) * (y2 - y1 + one_pixel)
        ## 按照score置信度降序排序
        order = scores.argsort()[::-1]
        keep = []  # 保留的结果框集合
        while order.size > 0:
            i = order[0]
            keep.append(i)  # 保留该类剩余box中得分最高的一个
            # 得到相交区域，左上及右下
            xx1 = np.maximum(x1[i], x1[order[1:]])
            yy1 = np.maximum(y1[i], y1[order[1:]])
            xx2 = np.minimum(x2[i], x2[order[1:]])
            yy2 = np.minimum(y2[i], y2[order[1:]])

            # 计算相交面积，不重叠的时候为0
            w = np.maximum(0.0, xx2 - xx1 + one_pixel)
            h = np.maximum(0.0, yy2 - yy1 + one_pixel)
            inter = w * h
            # 计算IoU：重叠面积/（面积1+面积2-重叠面积）
            ovr = inter / (areas[i] + areas[order[1:]] - inter)
            # 保留IoU小于阈值的box
            inds = np.where(ovr <= self.nms_thresh)[0]
            order = order[inds + 1]  # 因为ovr的数组长度比order数组少一个，所以这里要将所有下标后移一位
        return keep

    def compute_rotate_iou(self, box, boxes, box_area, boxes_area):
        """Calculates IoU of the given box with the array of the given boxes.
        # 使用给定框的数组计算给定框的IoU。
        box: 1D vector [y1, x1, y2, x2]
        boxes: [boxes_count, (y1, x1, y2, x2)]
        box_area: float. the area of 'box'  'box'的面积
        boxes_area: array of length boxes_count.  长度数组box_count
        Note: the areas are passed in rather than calculated here for
              efficency. Calculate once in the caller to avoid duplicate work.
        """

        # 修改后的代码
        line1 = box  # 四边形四个点坐标的一维数组表示，[x,y,x,y....]
        a = np.array(line1).reshape(4, 2)  # 四边形二维坐标表示
        poly1 = Polygon(a).convex_hull  # python四边形对象，会自动计算四个点，最后四个点顺序为：左上 左下  右下 右上 左上
        iou_list = []
        # if boxes is not None:
        for box_ in boxes:
            line2 = box_
            b = np.array(line2).reshape(4, 2)
            poly2 = Polygon(b).convex_hull
            # print(Polygon(b).convex_hull)

            union_poly = np.concatenate((a, b))  # 合并两个box坐标，变为8*2
            # print(union_poly)
            # print(MultiPoint(union_poly).convex_hull)  # 包含两四边形最小的多边形点
            if not poly1.intersects(poly2):  # 如果两四边形不相交
                iou = 0
                iou_list.append(iou)
            else:
                try:
                    inter_area = poly1.intersection(poly2).area  # 相交面积
                    # print(inter_area)
                    # union_area = poly1.area + poly2.area - inter_area
                    union_area = MultiPoint(union_poly).convex_hull.area
                    # print(union_area)
                    if union_area == 0:
                        iou = 0
                        iou_list.append(iou)
                    iou = float(inter_area) / union_area
                    iou_list.append(iou)
                    # iou=float(inter_area) /(poly1.area+poly2.area-inter_area)
                    # 源码中给出了两种IOU计算方式，第一种计算的是: 交集部分/包含两个四边形最小多边形的面积
                    # 第二种： 交集 / 并集（常见矩形框IOU计算方式）
                except shapely.geos.TopologicalError:
                    print('shapely.geos.TopologicalError occured, iou set to 0')
                    iou = 0
                    iou_list.append(iou)
        return iou_list

    def non_max_suppression_rotate(self, boxes, scores):
        """Performs non-maximum supression and returns indicies of kept boxes.
        执行非最大抑制并返回保留框的索引
        boxes: [N, (y1, x1, y2, x2)]. Notice that (y2, x2) lays outside the box. 注意（y2，x2）在框外。
        scores: 1-D array of box scores.
        threshold: Float. IoU threshold to use for filtering. 用于过滤的IoU阈值
        """
        assert boxes.shape[0] > 0
        if boxes.dtype.kind != "f":  # not float
            boxes = boxes.astype(np.float32)

        # Compute box areas
        x = boxes[:, [0, 2, 4, 6]]
        y = boxes[:, [1, 3, 5, 7]]
        area = 0.5 * abs((x[:, 0] * y[:, 1] + x[:, 1] * y[:, 2] + x[:, 2] * y[:, 3] + x[:, 3] * y[:, 0] -
                          x[:, 1] * y[:, 0] - x[:, 2] * y[:, 1] - x[:, 3] * y[:, 2] - x[:, 0] * y[:, 3]))

        # Get indicies of boxes sorted by scores (highest first)
        # 获取按分数排序的盒子索引（最高的第一个）
        ixs = scores.argsort()[::-1]  # 从小到大排序

        pick = []
        while len(ixs) > 0:
            # Pick top box and add its index to the list
            # 选择顶部框并将其索引添加到列表中
            i = ixs[0]
            pick.append(i)
            # Compute IoU of the picked box with the rest
            iou_list = self.compute_rotate_iou(boxes[i], boxes[ixs[1:]], area[i], area[ixs[1:]])
            # Identify boxes with IoU over the threshold. This
            # returns indicies into ixs[1:], so add 1 to get
            # indicies into ixs.
            # 识别超过阈值的IoU的盒子。 这将索引返回到ixs [1：]，所以加1以使索引变成ixs。
            remove_ixs_list = []
            # for iou in iou_list:
            remove_ixs = np.where(np.array(iou_list) > self.nms_thresh)[0] + 1
            if remove_ixs.size > 0:
                remove_ixs_list.append(remove_ixs)
            # Remove indicies of the picked and overlapped boxes.
            # 删除挑选和重叠框的索引。
            if remove_ixs_list is not None:
                for remove_ixs_ in remove_ixs_list:
                    ixs = np.delete(ixs, remove_ixs_)
            ixs = np.delete(ixs, 0)
        return pick

    def _is_image_file(self, input_data):
        """
        输入数据是否为影像文件
        通过后缀名判断
        """
        try:
            with rasterio.open(input_data, encoding='utf-8') as ds:
                data_is_image = True
        except Exception as e:
            data_is_image = False

        return data_is_image

    def _get_bbox(self, ds, ds_mask, j, i, height, width, rectangle_ymin, rectangle_xmin,
                  all_boxes, cost_times, estimation_type='img', infer_region=None):
        transf = ds.transform
        block_xmin = j * self.tile_offset_size + rectangle_xmin
        block_ymin = i * self.tile_offset_size + rectangle_ymin
        if (j == -1) & (i == -1):
            block_xmin = 0 + rectangle_xmin
            block_ymin = 0 + rectangle_ymin
            block = np.zeros([3, height, width], dtype=np.uint8)
            img = ds.read(window=Window(block_xmin, block_ymin, width, height))

        else:
            block_xmax = block_xmin + self.tile_size
            block_ymax = block_ymin + self.tile_size
            if height + rectangle_ymin <= block_ymax:
                block_ymin = height + rectangle_ymin - self.tile_size
            if width + rectangle_xmin <= block_xmax:
                block_xmin = width + rectangle_xmin - self.tile_size
            block = np.zeros([3, self.tile_size, self.tile_size], dtype=np.uint8)
            img = ds.read(window=Window(block_xmin, block_ymin, self.tile_size, self.tile_size))

        block[:, :img.shape[1], :img.shape[2]] = img[:3, :, :]
        block = reshape_as_image(block)
        block = cv2.cvtColor(block, cv2.COLOR_RGB2BGR)

        # 执行预测
        start_time = time.time()

        all_boxes_origin = self.return_inference_result(ds, all_boxes, block_xmin, block_ymin, block, infer_region)
        if len(all_boxes_origin) != 0:
            if ds_mask is not None:
                overlap_matrix = ds_mask.read(window=Window(int(block_xmin) - rectangle_xmin,
                                                        int(block_ymin) - rectangle_ymin,
                                                        self.tile_size, self.tile_size))

                if hasattr(self, 'development_kit') and self.development_kit == 'mmrotate':
                    for box_i in all_boxes_origin:
                        center_x, center_y = box_i[0][0] - block_xmin, box_i[0][1] - block_ymin
                        if overlap_matrix[0][int(center_y)][int(center_x)] != 0:
                            box_i[0] = self.r2q(box_i[0])
                            all_boxes.append(box_i)
                else:
                    for box_i in all_boxes_origin:
                        adjusted_box_i = [box_i[0]-block_xmin, box_i[1]-block_ymin,
                                        box_i[2]-block_xmin, box_i[3]-block_ymin]
                        center_x, center_y = self.calculate_center(adjusted_box_i)
                        if overlap_matrix[0][int(center_y)][int(center_x)] != 0:
                            all_boxes.append(
                                [float(box_i[0]), float(box_i[1]),
                                 float(box_i[2]),
                                 float(box_i[3]),
                                 float(box_i[4]), box_i[5]])
            else:
                if hasattr(self, 'development_kit') and self.development_kit == 'mmrotate':
                    for i in all_boxes_origin:
                        all_boxes.append(i)
                else:
                    for i in all_boxes_origin:
                        all_boxes.append(
                            [float(i[0]), float(i[1]),
                             float(i[2]),
                             float(i[3]),
                             float(i[4]), i[5]])

        cost_time = time.time() - start_time
        cost_times = cost_time + cost_times

        return all_boxes, cost_times

    def r2q(self, A):

        x, y, w, h, t = A
        hw, hh = w/2, h/2

        rm = np.array([[np.cos(t), -np.sin(t)],
                       [np.sin(t), -np.cos(t)]])

        c = np.array([[-hw, -hh],
                      [hw, -hh],
                      [hw, hh],
                      [-hw, hh]])
        rc = np.dot(c, rm.T)

        rc[:, 0] += x
        rc[:, 1] += y

        return rc.flatten()

    def calculate_center(self, coordinates):
        x_min, y_min, x_max, y_max = coordinates
        x = (x_min + x_max) / 2
        y = (y_min + y_max) / 2
        return int(x), int(y)

    def return_inference_result(self, ds, all_boxes, block_xmin, block_ymin, block, infer_region):
        pass

    def _view_bar(self, num, total):
        """
        进度条
        """
        rate = float(num) / float(total)
        rate_num = int(rate * 100)
        r = '\r[%s%s]%d%%,%d' % (">" * rate_num, "-" * (100 - rate_num), rate_num, num)
        sys.stdout.write(r)
        sys.stdout.flush()

    def close_model(self):
        import torch
        Device_type.empty_cache()

