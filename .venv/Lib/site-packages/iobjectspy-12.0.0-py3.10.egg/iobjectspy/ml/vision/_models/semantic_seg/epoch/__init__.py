from .seg_epoch import TrainEpoch, ValidEpoch
from .siamecd_epoch import TrainEpoch_SiameCD, ValidEpoch_SiameCD


class EpochBuilder:
    def __init__(self, model, sda_data_config, sdt_trainer_config, loss, metrics, optimizer,
                 device, scheduler, start_epoch, train_dataset, batch_size):
        data_type = sda_data_config.dataset.data_type
        model_name = sdt_trainer_config.model.name
        if data_type == 'general_change_detection':
            self._train_epoch = TrainEpoch_SiameCD(
                model,
                loss=loss,
                metrics=metrics,
                optimizer=optimizer,
                device=device,
                verbose=True,
                scheduler=scheduler,
                start_epoch=[start_epoch, len(train_dataset) // batch_size],
                model_name=model_name,
            )
            self._valid_epoch = ValidEpoch_SiameCD(
                model,
                model_name=model_name,
                loss=loss,
                metrics=metrics,
                device=device,
                verbose=True,
            )
        else:
            self._train_epoch = TrainEpoch(
                model,
                loss=loss,
                metrics=metrics,
                optimizer=optimizer,
                device=device,
                verbose=True,
                scheduler=scheduler,
                start_epoch=[start_epoch, len(train_dataset) // batch_size]
            )
            self._valid_epoch = ValidEpoch(
                model,
                loss=loss,
                metrics=metrics,
                device=device,
                verbose=True,
            )

    def get_train_epoch(self):
        return self._train_epoch

    def get_valid_epoch(self):
        return self._valid_epoch

    def run_tarin_epoch(self, epoch_info, dataloader, multiprocessing_distributed, Rank):
        return self._train_epoch.run(epoch_info, dataloader, multiprocessing_distributed, Rank)

    def run_valid_epoch(self, epoch_info, dataloader, multiprocessing_distributed, Rank):
        return self._valid_epoch.run(epoch_info, dataloader, multiprocessing_distributed, Rank)
