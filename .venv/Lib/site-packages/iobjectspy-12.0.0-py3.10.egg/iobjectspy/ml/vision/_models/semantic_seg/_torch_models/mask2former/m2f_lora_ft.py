import math
import torch.nn as nn

from ..ft_module import LoRA_layer
from ...sft import SupervisedFineTune


class Mask2formerLora(SupervisedFineTune, nn.Module):
    def __init__(self, mask2former, finetune_module_type):
        nn.Module.__init__(self)
        SupervisedFineTune.__init__(self, mask2former, finetune_module_type)
        self.model = mask2former
        self.perpare_finetune()

    def perpare_finetune(self, rank=4, lora_layer=None):
        assert rank > 0

        if lora_layer:
            self.lora_layer = lora_layer
        else:
            blocks = [getattr(self.model.encoder, f'block{i}') for i in range(1, 5)]
            self.lora_layer = [sum(len(block) - 1 for block in blocks[:i]) for i in range(1, len(blocks) + 1)]

        # create for storage, then we can init them or load weights
        self.w_As = []  # These are linear layers
        self.w_Bs = []

        # lets freeze first
        for i in range(1, 5):
            block_module = getattr(self.model.encoder, f"block{i}", None)
            for param in block_module.parameters():
                param.requires_grad = False

        # Here, we do the surgery
        t_layer_i = 0
        for i in range(1, 5):
            block_module = getattr(self.model.encoder, f"block{i}", None)
            # for t_layer_i, blk in enumerate(block_module):
            for _, blk in enumerate(block_module):
                # If we only want few lora layer instead of all
                if t_layer_i not in self.lora_layer:
                    t_layer_i += 1
                    continue
                w_q_linear = blk.attn.q
                w_kv_linear = blk.attn.kv
                self.q_dim = w_q_linear.in_features
                self.kv_dim = w_kv_linear.in_features
                w_a_linear_q = nn.Linear(self.q_dim, rank, bias=False)
                w_b_linear_q = nn.Linear(rank, self.q_dim, bias=False)
                w_a_linear_v = nn.Linear(self.kv_dim, rank, bias=False)
                w_b_linear_v = nn.Linear(rank, self.kv_dim, bias=False)
                self.w_As.append(w_a_linear_q)
                self.w_Bs.append(w_b_linear_q)
                self.w_As.append(w_a_linear_v)
                self.w_Bs.append(w_b_linear_v)
                blk.attn.q = LoRA_layer(
                    w_q_linear,
                    w_a_linear_q,
                    w_b_linear_q
                )
                blk.attn.qv = LoRA_layer(
                    w_kv_linear,
                    w_a_linear_v,
                    w_b_linear_v,
                )
                t_layer_i += 1
            self.reset_parameters()

    def reset_parameters(self) -> None:
        for w_A in self.w_As:
            nn.init.kaiming_uniform_(w_A.weight, a=math.sqrt(5))
        for w_B in self.w_Bs:
            nn.init.zeros_(w_B.weight)
