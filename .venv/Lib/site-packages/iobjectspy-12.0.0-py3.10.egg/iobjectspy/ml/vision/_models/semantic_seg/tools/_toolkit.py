import os
import sys
import tempfile
import traceback

import albumentations as albu

from ...... import import_tif, DatasourceConnectionInfo, Datasource, raster_to_vector, EngineType, DatasetType, overlay
from iobjectspy._logger import log_error


def to_tensor(x, **kwargs):
    return x.transpose(2, 0, 1).astype('float32')


def get_preprocessing(preprocessing_fn):
    """Construct preprocessing transform

    Args:
        preprocessing_fn (callbale): data normalization function
            (can be specific for each pretrained neural network)
    Return:
        transform: albumentations.Compose

    """

    _transform = [
        albu.Lambda(image=preprocessing_fn),
        albu.Lambda(image=to_tensor, mask=to_tensor),
    ]
    return albu.Compose(transforms=_transform)


class MathTools:
    @staticmethod
    def calculate_begin(x, y, width, height, block_size, expand):
        """
        用于计算推理读取影像时影像宽高不能被整除时，坐标向前偏移后的位置
        :param x: x起始位置
        :param y: y起始位置
        :param width: 影像的宽
        :param height: 影像的高
        :param block_size: block大小
        :param expand: 膨胀推理时的膨胀区域
        :return:
        """

        def calc_begin(pos, size, block_size, expand):
            if pos == 0:
                return 0
            elif pos + block_size == size:
                return pos - 2 * expand
            elif pos + block_size + expand > size:
                return size - 2 * expand - block_size
            else:
                return pos - expand

        xBegin = calc_begin(x, width, block_size, expand)
        yBegin = calc_begin(y, height, block_size, expand)

        return xBegin, yBegin

    @staticmethod
    def calculate_write_and_cut(pos, size, block_size, expand, data_size):
        """
        用于计算膨胀推理时保存的区域边界和范围
        :param pos:
        :param size:
        :param block_size:
        :param expand:
        :param data_size:
        :return:
        """
        write_size = block_size
        if pos == 0 and size != block_size:
            cut_edge = 0
            write_size = min(block_size, size)
        elif pos + block_size == size:
            cut_edge = data_size - block_size
        elif pos + block_size + expand > size:
            cut_edge = data_size - (size - pos)
        else:
            cut_edge = data_size - block_size - expand
        return write_size, cut_edge


class SaveTools:
    @staticmethod
    def finalize_grid_result(out_ds, dst_name, tmp_file, out_tmp_name):
        """
        向目标数据源写入tif文件的栅格结果数据集
        :param out_ds:
        :param dst_name:
        :param tmp_file:
        :param out_tmp_name:
        :return:
        """
        if dst_name.lower().endswith(('.tif', '.tiff')):
            return out_tmp_name
        try:
            result = import_tif(os.path.abspath(tmp_file), output=out_ds, out_dataset_name=dst_name,
                                is_import_as_grid=True)
            result = result[0] if isinstance(result, list) and result else result
            os.remove(tmp_file)
            return result
        except Exception as e:
            log_error(f'Import Datasource Failed! Error is {e}')
            sys.stderr.write('Import TIF to Dataset Failed! Copy Raster File to Out Datasource\'s Directory. '
                             'Please check iobjectspy.log for error.')
            return out_tmp_name

    @staticmethod
    def finalize_region_result(out_ds, dst_name, tmp_file, back_or_no_value, infer_region):
        """
        向目标数据源写入结果的矢量结果数据集。先转tif栅格再转矢量
        :param infer_region:
        :param back_or_no_value:
        :param out_ds:
        :param dst_name:
        :param tmp_file:
        :return:
        """
        try:
            tmp_udb_file = os.path.join(os.environ.get("SuperMapML_TempDir"), 'tmp.udbx')
            tmp_dsc = DatasourceConnectionInfo(server=tmp_udb_file, engine_type=EngineType.UDBX)
            tmp_ds = Datasource().create(tmp_dsc)
            dst_mask_tmp = import_tif(tmp_file, output=tmp_ds, out_dataset_name='mask_tmp', is_import_as_grid=True)
            dst_mask = dst_mask_tmp[0] if isinstance(dst_mask_tmp, list) and len(dst_mask_tmp) > 0 else 'mask_tmp'
            from iobjectspy import Rectangle
            if infer_region and isinstance(infer_region, Rectangle) is False:
                temp_vector = raster_to_vector(
                    tmp_ds[dst_mask],
                    value_field='class_type',
                    out_dataset_type=DatasetType.REGION,
                    back_or_no_value=back_or_no_value,
                    is_thin_raster=True,
                    out_data=tmp_ds,
                    out_dataset_name=dst_name + '_temp'
                )
                result = overlay(
                    temp_vector, infer_region, 'clip', out_data=out_ds, out_dataset_name=dst_name
                )

            else:
                result = raster_to_vector(
                    tmp_ds[dst_mask],
                    value_field='class_type',
                    out_dataset_type=DatasetType.REGION,
                    back_or_no_value=back_or_no_value,
                    is_thin_raster=True,
                    out_data=out_ds,
                    out_dataset_name=dst_name
                )

            tmp_ds.delete_all()
            tmp_ds.close()
            os.remove(tmp_file)
            os.remove(tmp_udb_file)
            return result.name if result else None
        except Exception as e:
            log_error(traceback.format_exc())
            return None

    @staticmethod
    def finalize_grid_result_cd(out_ds, dst_name, tmp_file, out_tmp_name):
        """
        向目标数据源写入tif文件的栅格结果数据集
        :param out_ds:
        :param dst_name:
        :param tmp_file:
        :param out_tmp_name:
        :return:
        """
        if dst_name.lower().endswith(('.tif', '.tiff')):
            return out_tmp_name
        try:
            result = import_tif(os.path.abspath(tmp_file), output=out_ds, out_dataset_name=dst_name,
                                is_import_as_grid=True)
            result = result[0] if isinstance(result, list) and len(result) > 0 else result
            os.remove(tmp_file)
            return result
        except Exception as e:
            log_error(f'Import Datasource Failed! Error is {e}')
            sys.stderr.write('Import TIF to Dataset Failed! Copy Raster File to Out Datasource\'s Directory. '
                             'Please check iobjectspy.log for error.')
            return out_tmp_name

    @staticmethod
    def finalize_region_result_cd(out_ds, dst_name, tmp_file, back_or_no_value, infer_region):
        """
        向目标数据源写入结果的矢量结果数据集。先转tif栅格再转矢量
        :param infer_region:
        :param back_or_no_value:
        :param out_ds:
        :param dst_name:
        :param tmp_file:
        :return:
        """
        try:
            tmp_udbx_file = os.path.join(os.environ.get("SuperMapML_TempDir"), 'tmp.udbx')
            tmp_dsc = DatasourceConnectionInfo(server=tmp_udbx_file, engine_type=EngineType.UDBX)
            tmp_ds = Datasource().create(tmp_dsc)
            dst_mask_tmp = import_tif(tmp_file, output=tmp_ds, out_dataset_name='mask_tmp', is_import_as_grid=True)

            dst_mask = dst_mask_tmp[0] if isinstance(dst_mask_tmp, list) and len(dst_mask_tmp) > 0 else 'mask_tmp'
            result = raster_to_vector(tmp_ds[dst_mask], 'class_type', out_dataset_type=DatasetType.REGION,
                                      back_or_no_value=back_or_no_value,
                                      is_thin_raster=True, out_data=out_ds, out_dataset_name=dst_name)
            # result = result[0] if isinstance(result, list) and len(result) > 0 else result
            result = result.name if result is not None else ''
            tmp_ds.delete_all()
            tmp_ds.close()
            os.remove(tmp_file)
            os.remove(tmp_udbx_file)
            return result
        except Exception as e:
            log_error(traceback.format_exc())
            return None
