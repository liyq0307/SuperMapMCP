# Copyright (c) OpenMMLab. All rights reserved.
import copy
import functools
import logging
import os
import os.path as osp
import re
import warnings
from abc import ABCMeta, abstractmethod
from collections.abc import MutableMapping
from typing import Any, Callable, List, Optional, Sequence, Union

import cv2
import numpy as np
import torch

from mmengine.registry import VISBACKENDS
from mmengine.visualization.vis_backend import TensorboardVisBackend
from mmengine.visualization.vis_backend import force_init_env


@VISBACKENDS.register_module()
class CustomTensorboardVisBackend(TensorboardVisBackend):
    @force_init_env
    def add_scalar(self,
                   name: str,
                   value: Union[int, float, torch.Tensor, np.ndarray],
                   step: int = 0,
                   **kwargs) -> None:
        """Record the scalar data to tensorboard.

        Args:
            phase (str): train or val
            name (str): The scalar identifier.
            value (int, float, torch.Tensor, np.ndarray): Value to save.
            step (int): Global step value to record. Defaults to 0.
        """
        if isinstance(value, (int, float, torch.Tensor, np.ndarray, np.number)):
            self._tensorboard.add_scalar(f'{name}(Y) vs Epoch(X)', value, step)
        else:
            warnings.warn(f'Got {type(value)}, but numpy array, torch tensor, '
                          f'int or float are expected. skip it!')

    @force_init_env
    def add_scalars(self,
                    phase: str,
                    scalar_dict: dict,
                    step: int = 0,
                    file_path: Optional[str] = None,
                    **kwargs) -> None:
        """Record the scalar's data to tensorboard.

        Args:
            phase (str): train or val
            scalar_dict (dict): Key-value pair storing the tag and
                corresponding values.
            step (int): Global step value to record. Defaults to 0.
            file_path (str, optional): Useless parameter. Just for
                interface unification. Defaults to None.
        """
        assert isinstance(scalar_dict, dict)
        assert 'step' not in scalar_dict, 'Please set it directly through the step parameter'
        require_keys = ['loss', 'loss_bbox', 'loss_cls', 'mAP', 'acc']
        total_loss_cls = 0
        total_loss_bbox = 0
        total_acc = 0
        nums = 0
        for key, value in scalar_dict.items():
            # 处理COCO格式的评估指标
            if key.startswith("coco/"):
                metric_name = key.split('/')[-1]
                if metric_name in ['bbox_mAP', 'segm_mAP']:
                    self.add_scalar(f'{phase}/{metric_name}', value, scalar_dict.get('epoch', step))
                continue

            if key.startswith("pascal_voc/") and key.endswith("mAP"):
                new_key = "mAP"  # 统一成 'mAP'
            else:
                new_key = key  # 保持原有 key
            if new_key in require_keys:
                self.add_scalar(f'{phase}/{new_key}', value, scalar_dict.get('epoch', step))
            elif re.match(r's\d+\.loss_cls', new_key):
                total_loss_cls += value

            elif re.match(r's\d+\.loss_bbox', new_key):
                total_loss_bbox += value

            elif re.match(r's\d+\.acc', new_key):
                total_acc += value
                nums += 1

        if total_loss_cls != 0:
            self.add_scalar(f'{phase}/loss_cls', total_loss_cls, scalar_dict.get('epoch', step))

        if total_loss_bbox != 0:
            self.add_scalar(f'{phase}/loss_bbox', total_loss_bbox, scalar_dict.get('epoch', step))

        if total_acc != 0:
            self.add_scalar(f'{phase}/mAcc', total_acc/nums, scalar_dict.get('epoch', step))

    def close(self):
        """close an opened tensorboard object."""
        if hasattr(self, '_tensorboard'):
            self._tensorboard.close()
