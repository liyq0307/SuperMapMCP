import os
import os.path as osp
import torch
from typing import Dict
from ._base import BaseConverter

class ONNXConverter(BaseConverter):
    def __init__(self, model_path, output_model_path, **kwargs):
        """
        转换pytorch模型至onnx模型

        :param model_path: 模型存储路径
        :type  model_path: str
        :param output_model_path: 模型输出路径
        :type output_model_path: str
        """
        self.config = model_path
        dir_path, sdm_name = osp.split(model_path)
        model_name = osp.splitext(sdm_name)[0]
        self.torch_model_path = osp.join(dir_path, model_name + '.pth')
        output_model_path = osp.join(output_model_path, model_name)
        if not osp.exists(output_model_path):
            os.makedirs(output_model_path)
        self.output_model_path = osp.join(output_model_path, model_name + '.onnx')
        self.config_path = osp.join(output_model_path, model_name + '.sdm')
    def torch2onnx(self, convert_cfg: Dict = dict()):
        """
        输出onnx模型

        :param export_cfg: 模型转换参数
        :type export_cfg: dict
        :return: onnx中间模型
        """
        try:
            model = torch.load(self.torch_model_path, map_location=convert_cfg['device'])
            with torch.no_grad():
                input_tensor = torch.rand(convert_cfg['input_shape']).to(convert_cfg['device'])
                torch.onnx.export(model, input_tensor, self.output_model_path, export_params=True, verbose=False,
                          input_names=convert_cfg['input_names'], output_names=convert_cfg['output_names'],
                                  dynamic_axes=convert_cfg['dynamic_axes'], opset_version=convert_cfg['opset_version'])
                self._save_model(self.config, self.config_path, 'onnx')
                print("Model convert successfully.")
        except:
            raise RuntimeError("Model convert failed.")

        # todo, 模型重构，替换模型中不能被转换且可以重写的部分，尝试trace和script联合解决不能转换部分
