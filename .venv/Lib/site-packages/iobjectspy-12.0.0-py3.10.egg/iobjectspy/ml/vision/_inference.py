import os
import sys
import tempfile
import time
import traceback
import warnings
import shutil
from enum import Enum, unique
import rasterio
from iobjectspy import Dataset, conversion, DatasetImage, DatasetMosaic, open_datasource, DatasourceConnectionInfo, \
    EngineType, Datasource, Rectangle, DatasetVector
from iobjectspy._jsuperpy._utils import check_lic
from iobjectspy._logger import log_info
from ..toolkit._toolkit import _is_image_file, del_dir, _get_dataset_readonly, get_config_from_yaml, \
    get_pic_path_from_dir,get_out_data_dir
from ..._jsuperpy.data._util import get_output_datasource
from ..toolkit._toolkit import bounds_transform_coord


@unique
class _ImageryInType(Enum):
    SINGLEFILE = 1
    FILELIST = 2
    FILEDIR = 3
    DATASETIMAGE = 4
    DATASETMOSAIC = 5


class ImageryInference:
    def __init__(self, model_path, gpus=[0], batch_size=1, **kwargs):
        """
        影像数据模型推理功能入口

        :param model_path: 模型存储路径
        :type  model_path: str
        :param gpus: 模型推理设备
        :type gpus: list
        :param batch_size: 单次推理数量
        :type batch_size: int

        """
        check_lic()

        self._img_ext = ['.tif', '.TIF', '.tiff', '.TIFF', '.img', '.IMG', '.jpg', '.JPG', '.png', '.PNG']
        self._ds_ext = ['.udb', '.udbx', '.UDB', '.UDBX']

        self.config = get_config_from_yaml(model_path)
        self.model_path = model_path
        self.kwargs = kwargs
        self.__func_class = ''.join([x.capitalize() for x in self.config.model_type.split('_')])
        self.__imagery_in_type = _ImageryInType.SINGLEFILE

        if self.__func_class == 'GeneralChangeDetection':
            from ._inference_collector.general_change_detection_infer import GeneralChangeDetection
        elif self.__func_class == 'ObjectDetection':
            from ._inference_collector.object_detection_infer import ObjectDetection
        elif self.__func_class == 'BinaryClassification':
            from ._inference_collector.binary_classification_infer import BinaryClassification
        elif self.__func_class == 'MultiClassification':
            from ._inference_collector.multi_classification_infer import MultiClassification
        elif self.__func_class == 'SceneClassification':
            from ._inference_collector.scene_classification_infer import SceneClassification
        elif self.__func_class == 'ImageClassification':
            from ._inference_collector.image_classification_infer import ImageClassification
        elif self.__func_class == 'ObjectExtraction':
            from ._inference_collector.object_extraction_infer import ObjectExtraction
        elif self.__func_class == 'PromptSegmentationInfer':
            from ._inference_collector.prompt_segmentation_infer import PromptSegmentationInfer
        elif self.__func_class == 'ObjectClassification':
            from ._inference_collector.object_classification_infer import ObjectClassification
        elif self.__func_class == 'SuperResolution':
            from ._inference_collector.super_resolution_infer import SuperResolution
        self.__inferece_obj = eval(self.__func_class)(self.model_path, gpus, batch_size, **kwargs)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def close(self):
        """
        清空已加载的模型
        """
        self.__inferece_obj.close_model()

    def __tempDirTool(method):
        # 装饰器：对temp文件夹进行管理，避免在用户磁盘产生冗余文件
        def wrapper(self,*args, **kwargs):
            tmp_dir = get_out_data_dir(kwargs.get('out_data'))
            if tmp_dir is not None:
                if not os.path.exists(tmp_dir):
                    os.makedirs(tmp_dir)
            self.tmp_data_dir = os.path.abspath(tempfile.mkdtemp(prefix='tempSupermapMl_',dir=tmp_dir))
            os.environ['SuperMapML_TempDir'] = self.tmp_data_dir            #下层代码中需要用到temp文件夹时采用os.os.environ.get("SuperMapML_TempDir")方式获取temp文件路径
            log_info('ImageryInference class tmp directory is: \' {} \''.format(self.tmp_data_dir))
            try:
                return method(self,*args, **kwargs)
            except Exception as e:
                raise e
            finally:
                os.environ.pop('SuperMapML_TempDir')        #清理temp文件夹路径环境变量
                try:
                    shutil.rmtree(self.tmp_data_dir)
                    print("Successfully cleared temporary folder:{}".format(self.tmp_data_dir))
                except Exception as e:
                    print("Clearing temporary folder:{} failed,please check the folder".format(self.tmp_data_dir))
                    raise e
        return wrapper

    @__tempDirTool
    def object_detect_infer(self, input_data, out_data, out_dataset_name, category_name, infer_region=None):
        """
        影像数据目标检测

        | 支持 tif、img (Erdas Image) 等影像文件，检测结果为矢量面数据集

        :param input_data: 待推理的数据
        :type  input_data: str or Dataset
        :param out_data: 输出文件（或数据源）路径
        :type  out_data: str or Datasource or DatasourceConnectionInfo
        :param out_dataset_name: 输出文件（或数据集）名称
        :type  out_dataset_name: str
        :param category_name: 目标检测类别，支持多类别检测
        :type  category_name: list[str] or str
        :return: 数据集名称
        """
        input_data_list = self.__get_input_data_list(input_data,infer_region)
        infer_region_dataset = self.__get_input_region_dataset(infer_region)
        out_data_target = self.__get_out_data(out_data)
        out_return = []
        if self.__imagery_in_type is _ImageryInType.SINGLEFILE or self.__imagery_in_type is _ImageryInType.DATASETIMAGE:
            # 单张影像，与11.0版本及其历史版本逻辑相同
            result_dataset_name = self.__inferece_obj.infer(input_data_list[0], out_data_target, out_dataset_name,
                                               category_name, infer_region_dataset)
            out_return = self.__get_return(out_return, out_data_target, result_dataset_name)
        elif self.__imagery_in_type is _ImageryInType.DATASETMOSAIC:
            if os.path.splitext(out_data_target)[-1] in self._ds_ext:
                for input_data_path in input_data_list:
                    out_file_list = []
                    out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name
                    if infer_region_dataset:
                        if bounds_transform_coord(rasterio.open(input_data_path), infer_region_dataset) == None:
                            continue
                    result_dataset_name = self.__inferece_obj.infer(input_data_path, out_data_target, out_name, category_name, infer_region_dataset)
                    out_return = self.__get_return(out_return,out_data_target,result_dataset_name)
            else:
                raise TypeError('\'input_data\' is a DatasetMosaic, but \'out_data\' is not a Datasource.')
        else:
            # 多张影像，将多张结果根据 'out_dataset_name + _ +原始文件名'形式保存在结果数据源所在目录或结果目录
            if os.path.splitext(out_data_target)[-1] in self._ds_ext:
                if isinstance(infer_region_dataset, list):
                    for input_data_path, region in zip(input_data_list, infer_region_dataset):
                        out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name
                        result_dataset_name = self.__inferece_obj.infer(input_data_path, out_data, out_name, category_name,
                                                           region)
                        out_return = self.__get_return(out_return,out_data_target,result_dataset_name)
                else:
                    for input_data_path in input_data_list:
                        out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name
                        result_dataset_name = self.__inferece_obj.infer(input_data_path, out_data_target, out_name, category_name, infer_region_dataset)
                        out_return = self.__get_return(out_return,out_data_target,result_dataset_name)
            else:
                raise ValueError('The extension of output is wrong, please check it!')
        return out_return

    @__tempDirTool
    def binary_classify_infer(self, input_data, out_data, out_dataset_name, offset, result_type, infer_region=None,
                              **kwargs):
        """
        遥感影像数据二元分类
        支持 tif、img (Erdas Image) 等影像文件，分类结果为二值栅格或矢量文件
        支持SuperMap SDX下的影像数据集，分类结果为矢量或栅格数据集

        :param input_data: 待推理的数据
        :type  input_data: str or Dataset or List
        :param out_data: 输出文件（或数据源）路径
        :type  out_data: str or Datasource or DatasourceConnectionInfo
        :param out_dataset_name: 输出文件（或数据集）名称
        :type  out_dataset_name: str
        :param offset: 图像分块偏移，其值为分块间重叠部分大小。大幅图像需分块预测，以提高图像块边缘预测结果
        :type offset: int
        :param result_type: 结果返回类型，支持矢量面和栅格: 'region' or 'grid'
        :type infer_region: vector对象 or vector连接信息 or bounds or list(bounds or str)
        :param infer_region: 指定推理范围，输入矢量面或角点坐标, 默认None
        :type result_type: str
        :return: 数据集列表
        """
        input_data_list = self.__get_input_data_list(input_data,infer_region)
        infer_region_dataset = self.__get_input_region_dataset(infer_region)
        out_data_target = self.__get_out_data(out_data)
        out_return = []
        if self.__imagery_in_type is _ImageryInType.SINGLEFILE or self.__imagery_in_type is _ImageryInType.DATASETIMAGE:
            # 单张影像，与11.0版本及其历史版本逻辑相同
            if isinstance(out_data_target, str):
                if os.path.splitext(out_data_target)[-1] not in self._ds_ext and os.path.splitext(out_dataset_name)[-1] not in self._img_ext and result_type == 'grid':
                    out_dataset_name = out_dataset_name + '.tif'
            result_dataset_name = self.__inferece_obj.infer(input_data_list[0], out_data_target, out_dataset_name, offset, result_type,
                                               infer_region_dataset, **kwargs)
            out_return = self.__get_return(out_return,out_data_target,result_dataset_name)
        elif self.__imagery_in_type is _ImageryInType.DATASETMOSAIC:
            # 镶嵌数据集，解析镶嵌数据集中影像列表，循环推理并输出，输出结果为grid时分化为两种情况：输出数据源中和输出文件夹中
            if os.path.splitext(out_data_target)[-1] in self._ds_ext:
                out_data_dir = os.path.dirname(out_data_target) if result_type == 'grid' else out_data_target
            elif os.path.isdir(out_data_target):
                out_data_dir = out_data_target
            else:
                raise ValueError("Out Data is not a Datasource or Directory!")

            out_file_list = []
            for input_data_path in input_data_list:
                out_suffix = '.tif' if result_type == 'grid' else ''
                out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name + out_suffix
                if infer_region_dataset:
                    if bounds_transform_coord(rasterio.open(input_data_path), infer_region_dataset) == None:
                        continue
                result_dataset_name = self.__inferece_obj.infer(input_data_path, out_data_dir, out_name, offset, result_type,
                                                   infer_region_dataset, **kwargs)
                out_file_list = self.__get_return(out_file_list,out_data_dir,result_dataset_name)
            if len(out_file_list) > 1 and result_type == 'grid' and os.path.splitext(out_data_target)[-1] in self._ds_ext:
                ds = get_output_datasource(out_data_target)
                conn_info = DatasourceConnectionInfo(out_file_list[0], EngineType.IMAGEPLUGINS)
                ds_result = open_datasource(conn_info)
                dt_ms = ds.create_mosaic_dataset(out_dataset_name, ds_result.prj_coordsys, adjust_name=True)
                dt_ms.add_files(out_file_list)
                out_return.append(os.path.join(out_data_target, dt_ms.name))
                dt_ms.close()
                ds_result.close()
            else:
                out_return = out_file_list
        else:
            # 多张影像，将多张结果根据 'out_dataset_name + _ +原始文件名'形式保存在结果数据源所在目录或结果目录
            name_tif = False
            if os.path.splitext(out_data_target)[-1] in self._ds_ext:
                name_tif = False
                print('Input data is multiple imageries, results will be saved in datasource: {}'.format(out_data_target))
            else:
                name_tif = True
                print('Input data is multiple imageries, results will be saved in directory: {}'.format(out_data_target))
            if isinstance(infer_region_dataset, list):
                for input_data_path, region in zip(input_data_list, infer_region_dataset):
                    if name_tif:
                        out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name + '.tif'
                    else:
                        out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name
                    result_dataset_name = self.__inferece_obj.infer(input_data_path, out_data_target, out_name, offset, result_type,
                                                       region, **kwargs)
                    out_return = self.__get_return(out_return,out_data_target,result_dataset_name)
            else:
                for input_data_path in input_data_list:
                    if name_tif:
                        out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name + '.tif'
                    else:
                        out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name
                    result_dataset_name = self.__inferece_obj.infer(input_data_path, out_data_target, out_name, offset, result_type,
                                                       infer_region_dataset, **kwargs)
                    out_return = self.__get_return(out_return,out_data_target,result_dataset_name)
        return out_return

    @__tempDirTool
    def multi_classify_infer(self, input_data, out_data, out_dataset_name, offset, result_type, infer_region=None,
                             **kwargs):
        """
        遥感影像数据多分类，地物分类
        支持 tif、img (Erdas Image)等影像文件，分类结果为多值栅格或矢量文件
        支持SuperMap SDX下的影像数据集，分类结果为矢量或栅格数据集

        :param input_data: 待推理的数据
        :type  input_data: str or Dataset or List
        :param out_data: 输出文件（或数据源）路径
        :type  out_data: str or Datasource or DatasourceConnectionInfo
        :param out_dataset_name: 输出文件（或数据集）名称
        :type  out_dataset_name: str
        :param offset: 图像分块偏移，其值为分块间重叠部分大小。大幅图像需分块预测，以提高图像块边缘预测结果
        :type offset: int
        :param result_type: 结果返回类型，支持矢量面和栅格: 'region' or 'grid'
        :type infer_region: vector or bounds or list(bounds or str)
        :param infer_region: 指定推理范围，输入矢量面或角点坐标, 默认None
        :type result_type: str
        :return: 数据集列表
        """

        input_data_list = self.__get_input_data_list(input_data, infer_region)
        infer_region_dataset = self.__get_input_region_dataset(infer_region)
        out_data_target = self.__get_out_data(out_data)
        out_return = []
        if self.__imagery_in_type is _ImageryInType.SINGLEFILE or self.__imagery_in_type is _ImageryInType.DATASETIMAGE:
            # 单张影像，与11.0版本及其历史版本逻辑相同
            if isinstance(out_data_target, str):
                if os.path.splitext(out_data_target)[-1] not in self._ds_ext and os.path.splitext(out_dataset_name)[-1] not in self._img_ext and result_type == 'grid':
                    out_dataset_name = out_dataset_name + '.tif'
            result_dataset_name = self.__inferece_obj.infer(input_data_list[0], out_data_target, out_dataset_name, offset, result_type,
                                               infer_region_dataset, **kwargs)
            out_return = self.__get_return(out_return, out_data_target, result_dataset_name)
        elif self.__imagery_in_type is _ImageryInType.DATASETMOSAIC:
            # 镶嵌数据集，将多张推理结果（*.tif）保存在结果数据源所在目录
            if os.path.splitext(out_data_target)[-1] in self._ds_ext:
                out_data_dir = os.path.dirname(out_data_target) if result_type == 'grid' else out_data_target
            elif os.path.isdir(out_data_target):
                out_data_dir = out_data_target
            else:
                raise ValueError("Out Data is not a Datasource or Directory!")

            out_file_list = []
            for input_data_path in input_data_list:
                out_suffix = '.tif' if result_type == 'grid' else ''
                out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name + out_suffix
                if infer_region_dataset:
                    if bounds_transform_coord(rasterio.open(input_data_path), infer_region_dataset) == None:
                        continue
                result_dataset_name = self.__inferece_obj.infer(input_data_path, out_data_dir, out_name, offset, result_type,
                                                   infer_region_dataset, **kwargs)
                out_file_list = self.__get_return(out_file_list, out_data_dir, result_dataset_name)
            if len(out_file_list) > 1 and result_type == 'grid' and os.path.splitext(out_data_target)[-1] in self._ds_ext:
                ds = get_output_datasource(out_data_target)
                conn_info = DatasourceConnectionInfo(out_file_list[0], EngineType.IMAGEPLUGINS)
                ds_result = open_datasource(conn_info)
                dt_ms = ds.create_mosaic_dataset(out_dataset_name, ds_result.prj_coordsys, adjust_name=True)
                dt_ms.add_files(out_file_list)
                out_return.append(os.path.join(out_data_target, dt_ms.name))
                dt_ms.close()
                ds_result.close()
            else:
                out_return = out_file_list
        else:
            # 多张影像，将多张结果根据 'out_dataset_name + _ +原始文件名'形式保存在结果数据源所在目录或结果目录
            name_tif = False
            if os.path.splitext(out_data_target)[-1] in self._ds_ext:
                name_tif = False
                print(
                    'Input data is multiple imageries, results will be saved in datasource: {}'.format(out_data_target))
            else:
                name_tif = True
                print(
                    'Input data is multiple imageries, results will be saved in directory: {}'.format(out_data_target))
            if isinstance(infer_region_dataset, list):
                for input_data_path, region in zip(input_data_list, infer_region_dataset):
                    if name_tif:
                        out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name + '.tif'
                    else:
                        out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name
                    result_dataset_name = self.__inferece_obj.infer(input_data_path, out_data_target, out_name, offset, result_type,
                                                       region, **kwargs)
                    out_return = self.__get_return(out_return, out_data_target, result_dataset_name)
            else:
                for input_data_path in input_data_list:
                    if name_tif:
                        out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name + '.tif'
                    else:
                        out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name
                    result_dataset_name = self.__inferece_obj.infer(input_data_path, out_data_target, out_name, offset, result_type,
                                                       infer_region_dataset, **kwargs)
                    out_return = self.__get_return(out_return, out_data_target, result_dataset_name)
        return out_return

    @__tempDirTool
    def general_changedet_infer(self, input_data, input_compare_data, out_data, out_dataset_name, offset, result_type,
                                infer_region=None, **kwargs):
        """
        遥感影像数据通用变化检测
        支持 tif、img (Erdas Image) 等影像文件，分类结果为二值栅格或矢量文件
        支持SuperMap SDX下的影像数据集，分类结果为矢量或栅格数据集

        :param input_data: 待推理的数据
        :param input_compare_data: 待推理的数据
        :type  input_data or input_compare_data: str or Dataset or List
        :param out_data: 输出文件（或数据源）路径
        :type  out_data: str or Datasource or DatasourceConnectionInfo
        :param out_dataset_name: 输出文件（或数据集）名称
        :type  out_dataset_name: str
        :param offset: 图像分块偏移，其值为分块间重叠部分大小。大幅图像需分块预测，以提高图像块边缘预测结果
        :type offset: int
        :param result_type: 结果返回类型，支持矢量面和栅格: 'region' or 'grid'
        :type infer_region: vector or bounds or list(bounds or str)
        :param infer_region: 指定推理范围，输入矢量面或角点坐标, 默认None
        :type result_type: str
        :return: 数据集列表
        """
        input_data_list = self.__get_input_data_list(input_data,infer_region)
        input_compare_data_list = self.__get_input_data_list(input_compare_data,infer_region)
        infer_region_dataset = self.__get_input_region_dataset(infer_region)
        out_data_target = self.__get_out_data(out_data)
        if len(input_data_list) != len(input_compare_data_list):
            raise IndexError('The number of input data is inconsistent with the number of input compare data!')
        out_return = []
        if self.__imagery_in_type is _ImageryInType.SINGLEFILE or self.__imagery_in_type is _ImageryInType.DATASETIMAGE:
            # 单张影像，与11.0版本及其历史版本逻辑相同
            if isinstance(out_data_target,str):
                if os.path.splitext(out_data_target)[-1] not in self._ds_ext and os.path.splitext(out_dataset_name)[-1] not in self._img_ext and result_type == 'grid':
                    out_dataset_name = out_dataset_name + '.tif'
            result_dataset_name = self.__inferece_obj.infer(input_data_list[0], input_compare_data_list[0], out_data_target,
                                               out_dataset_name, offset, result_type, infer_region_dataset, **kwargs)
            out_return = self.__get_return(out_return, out_data_target, result_dataset_name)

        elif self.__imagery_in_type is _ImageryInType.DATASETMOSAIC:
            # 镶嵌数据集，将多张推理结果（*.tif）保存在结果数据源所在目录
            if os.path.splitext(out_data_target)[-1] in self._ds_ext:
                out_data_dir = os.path.dirname(out_data_target) if result_type == 'grid' else out_data_target
            elif os.path.isdir(out_data_target):
                out_data_dir = out_data_target
            else:
                raise ValueError("Out Data is not a Datasource or Directory!")
            out_file_list = []
            for i in range(len(input_data_list)):
                if os.path.basename(input_data_list[i]) == os.path.basename(input_compare_data_list[i]):
                    out_suffix = '.tif' if result_type == 'grid' else ''
                    out_name = os.path.splitext(os.path.basename(input_data_list[i]))[0] + '_' + out_dataset_name + out_suffix
                    if infer_region:
                        if bounds_transform_coord(rasterio.open(input_data_list[i]), infer_region) == None:
                            continue
                    result_dataset_name = self.__inferece_obj.infer(input_data_list[i], input_compare_data_list[i], out_data_dir,
                                                       out_name, offset, result_type, infer_region_dataset, **kwargs)
                    out_file_list = self.__get_return(out_file_list, out_data_dir, result_dataset_name)
                else:
                    raise Exception('The data names of the two phases must be consistent')
            if len(out_file_list) > 1 and result_type == 'grid' and os.path.splitext(out_data_target)[-1] in self._ds_ext:
                ds = get_output_datasource(out_data_target)
                conn_info = DatasourceConnectionInfo(out_file_list[0], EngineType.IMAGEPLUGINS)
                ds_result = open_datasource(conn_info)
                dt_ms = ds.create_mosaic_dataset(out_dataset_name, ds_result.prj_coordsys, adjust_name=True)
                dt_ms.add_files(out_file_list)
                out_return.append(os.path.join(out_data_target, dt_ms.name))
                dt_ms.close()
                ds_result.close()
            else:
                out_return = out_file_list
        else:
            # 多张影像，将多张结果根据'input原始文件名'+'_'+'compare原始文件名'+'_'+out_dataset_name形式保存在结果数据源所在目录或结果目录
            name_tif = False
            if os.path.splitext(out_data_target)[-1] in self._ds_ext:
                out_data_dir = out_data  # os.path.dirname(out_data)
                name_tif = False
                print('Input data is multiple imageries, results will be saved in datasource: {}'.format(out_data_target))
            else:
                out_data_dir = out_data
                name_tif = True
                print('Input data is multiple imageries, results will be saved in directory: {}'.format(out_data_target))

            if isinstance(infer_region_dataset, list):
                for i, region in enumerate(infer_region_dataset):
                    if name_tif:
                        out_name = os.path.splitext(os.path.basename(input_data_list[i]))[0] + '_' + \
                                   os.path.splitext(os.path.basename(input_compare_data_list[i]))[0] + '_' + out_dataset_name + '.tif'
                    else:
                        out_name = os.path.splitext(os.path.basename(input_data_list[i]))[0] + '_' + \
                                   os.path.splitext(os.path.basename(input_compare_data_list[i]))[0] + '_' + out_dataset_name
                    result_dataset_name = self.__inferece_obj.infer(input_data_list[i], input_compare_data_list[i], out_data_target,
                                                       out_name, offset, result_type, region, **kwargs)
                    out_return = self.__get_return(out_return, out_data_target, result_dataset_name)
            else:
                for i in range(len(input_data_list)):
                    if name_tif:
                        out_name = os.path.splitext(os.path.basename(input_data_list[i]))[0] + '_' + \
                                   os.path.splitext(
                                       os.path.basename(input_compare_data_list[i]))[0] + '_' + out_dataset_name + '.tif'
                    else:
                        out_name = os.path.splitext(os.path.basename(input_data_list[i]))[0] + '_' + \
                                   os.path.splitext(
                                       os.path.basename(input_compare_data_list[i]))[0] + '_' + out_dataset_name
                    result_dataset_name = self.__inferece_obj.infer(input_data_list[i], input_compare_data_list[i], out_data_target,
                                                       out_name, offset, result_type, infer_region_dataset, **kwargs)
                    out_return = self.__get_return(out_return, out_data_target, result_dataset_name)
        return out_return

    @__tempDirTool
    def scene_classify_infer(self, input_data, out_data, out_dataset_name, result_type, infer_region=None, **kwargs):
        """
        遥感影像数据场景分类
        支持 tif、img (Erdas Image) 等影像文件，以及 jpg、png等图像文件，分类结果为二值栅格或矢量文件
        支持SuperMap SDX下的影像数据集，分类结果为矢量或栅格数据集

        :param input_data: 待推理的数据
        :type  input_data: str or Dataset or List
        :param out_data: 输出文件（或数据源）路径
        :type  out_data: str or Datasource or DatasourceConnectionInfo
        :param out_dataset_name: 输出文件（或数据集）名称
        :type  out_dataset_name: str
        :param result_type: 结果返回类型，支持矢量面和栅格: 'region' or 'grid'
        :type infer_region: vector or bounds or list(bounds or str)
        :param infer_region: 指定推理范围，输入矢量面或角点坐标, 默认None
        :type result_type: str
        :return: 数据集列表
        """
        input_data_list = self.__get_input_data_list(input_data,infer_region)
        infer_region_dataset = self.__get_input_region_dataset(infer_region)
        out_data_target = self.__get_out_data(out_data)
        out_return = []
        if self.__imagery_in_type is _ImageryInType.SINGLEFILE or self.__imagery_in_type is _ImageryInType.DATASETIMAGE:
            # 单张影像，与11.0版本及其历史版本逻辑相同
            if isinstance(out_data_target, str):
                if os.path.splitext(out_data_target)[-1] not in self._ds_ext and os.path.splitext(out_dataset_name)[-1] not in self._img_ext and result_type == 'grid':
                    out_dataset_name = out_dataset_name + '.tif'
            result_dataset_name = self.__inferece_obj.infer(input_data_list[0], out_data_target, out_dataset_name, result_type,
                                               infer_region_dataset, **kwargs)
            out_return = self.__get_return(out_return, out_data_target, result_dataset_name)
        elif self.__imagery_in_type is _ImageryInType.DATASETMOSAIC:
            # 镶嵌数据集，将多张推理结果（*.tif）保存在结果数据源所在目录
            if os.path.splitext(out_data_target)[-1] in self._ds_ext:
                out_data_dir = os.path.dirname(out_data_target) if result_type == 'grid' else out_data_target
            elif os.path.isdir(out_data_target):
                out_data_dir = out_data_target
            else:
                raise ValueError("Out Data is not a Datasource or Directory!")

            out_file_list = []
            for input_data_path in input_data_list:
                out_suffix = '.tif' if result_type == 'grid' else ''
                out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name + out_suffix
                if infer_region_dataset:
                    if bounds_transform_coord(rasterio.open(input_data_path), infer_region_dataset) == None:
                        continue
                result_dataset_name = self.__inferece_obj.infer(input_data_path, out_data_target, out_name, result_type, infer_region_dataset,
                                                   **kwargs)
                out_file_list = self.__get_return(out_file_list, out_data_dir, result_dataset_name)
            if len(out_file_list) > 1 and result_type == 'grid' and os.path.splitext(out_data_target)[-1] in self._ds_ext:
                ds = get_output_datasource(out_data_target)
                conn_info = DatasourceConnectionInfo(out_file_list[0], EngineType.IMAGEPLUGINS)
                ds_result = open_datasource(conn_info)
                dt_ms = ds.create_mosaic_dataset(out_dataset_name, ds_result.prj_coordsys, adjust_name=True)
                dt_ms.add_files(out_file_list)
                out_return.append(os.path.join(out_data_target, dt_ms.name))
                dt_ms.close()
                ds_result.close()
            else:
                out_return = out_file_list
        else:
            # 多张影像，将多张结果根据 'out_dataset_name + _ +原始文件名'形式保存在结果数据源中
            name_tif = False
            if os.path.splitext(out_data_target)[-1] in self._ds_ext:
                name_tif = False
                print('Input data is multiple imageries, results will be saved in datasource: {}'.format(out_data_target))
            else:
                name_tif = True
                print('Input data is multiple imageries, results will be saved in directory: {}'.format(out_data_target))
            if isinstance(infer_region_dataset, list):
                for input_data_path, region in zip(input_data_list, infer_region_dataset):
                    if name_tif:
                        out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name + '.tif'
                    else:
                        out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name
                    result_dataset_name = self.__inferece_obj.infer(input_data_path, out_data_target, out_name, result_type,
                                                       region, **kwargs)
                    out_return = self.__get_return(out_return, out_data_target, result_dataset_name)
            else:
                for input_data_path in input_data_list:
                    if name_tif:
                        out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name + '.tif'
                    else:
                        out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name
                    result_dataset_name = self.__inferece_obj.infer(input_data_path, out_data_target, out_name, result_type, infer_region,
                                                       **kwargs)
                    out_return = self.__get_return(out_return, out_data_target, result_dataset_name)
        return out_return

    @__tempDirTool
    def object_extract_infer(self, input_data, out_data, out_dataset_name, return_bbox=False, infer_region=None,
                             **kwargs):
        """
        遥感影像数据对象提取
        支持 tif、img (Erdas Image)等影像文件，分类结果为矢量文件
        支持SuperMap SDX下的影像数据集，分类结果为矢量

        :param input_data: 待推理的数据
        :type  input_data: str or Dataset
        :param out_data: 输出文件（或数据源）路径
        :type  out_data: str or Datasource or DatasourceConnectionInfo
        :param out_dataset_name: 输出文件（或数据集）名称
        :type  out_dataset_name: str
        :param score_thresh: 类别分数的阈值
        :type  score_thresh: float
        :param nms_thresh: nms的阈值
        :type  nms_thresh: float
        :param return_bbox: 是否返回对象的最小外接矩形
        :type  return_bbox: bool
        :type infer_region: vector or bounds or list(bounds or str)
        :param infer_region: 指定推理范围，输入矢量面或角点坐标, 默认None
        :return: 数据集名称
        """
        input_data_list = self.__get_input_data_list(input_data,infer_region)
        infer_region_dataset = self.__get_input_region_dataset(infer_region)
        out_data_target = self.__get_out_data(out_data)
        out_return = []
        if self.__imagery_in_type is _ImageryInType.SINGLEFILE or self.__imagery_in_type is _ImageryInType.DATASETIMAGE:
            # 单张影像推理
            if not isinstance(infer_region_dataset, list):
                result_dataset_name = self.__inferece_obj.infer(input_data_list[0], out_data_target, out_dataset_name, return_bbox,
                                                   infer_region_dataset, **kwargs)
            out_return = self.__get_return(out_return, out_data_target, result_dataset_name)
        elif self.__imagery_in_type is _ImageryInType.DATASETMOSAIC:
            # 镶嵌数据集，将多张推理结果（*.tif）保存在结果数据源所在目录
            if os.path.splitext(out_data_target)[-1] in self._ds_ext:
                for input_data_path in input_data_list:
                    out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name
                    if infer_region_dataset:
                        if bounds_transform_coord(rasterio.open(input_data_path), infer_region_dataset) == None:
                            continue
                    result_dataset_name = self.__inferece_obj.infer(input_data_path, out_data_target, out_name, return_bbox, infer_region_dataset,
                                                       **kwargs)
                    out_return = self.__get_return(out_return, out_data_target, result_dataset_name)
            else:
                raise TypeError('\'input_data\' is a DatasetMosaic, but \'out_data\' is not a Datasource.')

        else:
            # 多张影像，将多张结果根据 'out_dataset_name + _ +原始文件名'形式保存在结果数据源所在目录或结果目录
            if os.path.splitext(out_data_target)[-1] in self._ds_ext:
                print('Input data is multiple imageries, results will be saved in directory: {}'.format(out_data))
                if isinstance(infer_region_dataset, list):
                    for input_data_path, region in zip(input_data_list, infer_region_dataset):
                        out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name
                        result_dataset_name = self.__inferece_obj.infer(input_data_path, out_data_target, out_name, return_bbox,
                                                           region, **kwargs)
                        out_return = self.__get_return(out_return, out_data_target, result_dataset_name)
                else:
                    for input_data_path in input_data_list:
                        out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name
                        result_dataset_name = self.__inferece_obj.infer(input_data_path, out_data_target, out_name, return_bbox,
                                                           infer_region_dataset,
                                                           **kwargs)
                        out_return = self.__get_return(out_return, out_data_target, result_dataset_name)
            else:
                raise ValueError('The extension of output is wrong, please check it!')
        return out_return

    @__tempDirTool
    def prompt_segmentation_infer(self, input_data, prompt_type, input_prompt_data,
                                  out_data, out_dataset_name,
                                  tile_size=1024, offset=0,
                                  sample_method=None,
                                  **kwargs):
        """
        基于SAM模型遥感影像数据对象提取
        支持 tif、img (Erdas Image)等影像文件，分类结果为矢量文件
        支持SuperMap SDX下的影像数据集，分类结果为矢量

        :param input_data: 待推理的数据
        :type  input_data: DatasetImage
        :param prompt_type: 输入暂时只支持面数据集polygon,无提示noprompt
        :type  prompt_type: str
        :param input_prompt_data: 输入矢量提示数据源
        :type  input_prompt_data: 'polygon'提示为DatasetVector，'noprompt'提示为None
        :param out_data: 输出文件（Udbx）路径
        :type  out_data: str or Datasource
        :param out_dataset_name: 输出数据集名称
        :type  out_dataset_name: str
        :param tile_size: 切块大小, 默认值为1024
        :type  tile_size: int
        :param offset: 切块重叠度, 默认值为0
        :type  offset: int
        :param sample_method: 采样点策略，polygon默认SAMSamplePointsEnum.HOMOGENEOUS，noprompt默认SAMSamplePointsEnum.UNIFORM
        :type  sample_method: 枚举类SAMSamplePointsEnum
        :return: 数据集名称
        """
        infer_region = None
        input_data_list = self.__get_input_data_list(input_data,infer_region)
        prompt_dataset = self.__get_input_region_dataset(input_prompt_data)
        out_data_target = self.__get_out_data(out_data)
        out_return = []
        if input_data_list != []:
            input_data = input_data_list[0]
        else:
            raise ValueError("Input Data is None")
        if isinstance(input_data, str):
            input_data_name = input_data
        elif isinstance(input_data, DatasetImage):
            input_data_name = input_data.name
        # 仅支持单张影像推理
        if self.__imagery_in_type is _ImageryInType.SINGLEFILE or self.__imagery_in_type is _ImageryInType.DATASETIMAGE:
            if not isinstance(infer_region, list):
                result_dataset_name = self.__inferece_obj.infer(input_data_list[0], prompt_dataset, out_data_target, out_dataset_name,
                                                   prompt_type, tile_size, offset, sample_method,
                                                   input_data_name=input_data_name, **kwargs)
                out_return = self.__get_return(out_return, out_data_target, result_dataset_name)
            else:
                print('result is None!')
        else:
            raise TypeError('Only supports single image inference.')
        return out_return

    @__tempDirTool
    def super_resolution_infer(self, input_data, out_data, out_dataset_name, **kwargs):
        '''
        :param input_data: 待推理数据
        :param output_path: 输出文件夹路径或数据源路径
        :param out_dataset_name: 输出数据名称
        :param tile_size: 切块大小, 默认值为512
        :return: 数据集名称
        '''
        infer_region = None
        input_data_list = self.__get_input_data_list(input_data,infer_region)
        out_data_target = self.__get_out_data(out_data)
        out_return = []
        output_type = 'File'
        if os.path.splitext(out_data_target)[-1] in self._ds_ext:
            output_type = 'Datasource'
            out_data_str = self.tmp_data_dir
        else:
            out_data_str = out_data_target
        if self.__imagery_in_type is _ImageryInType.SINGLEFILE or self.__imagery_in_type is _ImageryInType.DATASETIMAGE:
            # 单张影像，与11.0版本及其历史版本逻辑相同
            result_dataset_name = self.__inferece_obj.infer(input_data_list[0], out_data_str, out_dataset_name, **kwargs)
            out_return = self.__get_return(out_return, out_data_target, result_dataset_name)
        elif self.__imagery_in_type is _ImageryInType.DATASETMOSAIC:
            # 镶嵌数据集，将多张推理结果（*.tif）保存在结果数据源所在目录
            if output_type == 'Datasource':
                out_data_str = os.path.dirname(out_data_target)
            for input_data_path in input_data_list:

                out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name
                result_dataset_name = self.__inferece_obj.infer(input_data_path, out_data_str, out_name, **kwargs)
                out_return = self.__get_return(out_return, out_data_str, result_dataset_name)
        else:
            # 多张影像，将多张结果根据 'out_dataset_name + _ +原始文件名'形式保存在结果数据源所在目录或结果目录
            for input_data_path in input_data_list:
                out_name = os.path.splitext(os.path.basename(input_data_path))[0] + '_' + out_dataset_name
                result_dataset_name = self.__inferece_obj.infer(input_data_path, out_data_str, out_name,**kwargs)
                out_return = self.__get_return(out_return, out_data_str, result_dataset_name)

        if output_type == 'Datasource' and self.__imagery_in_type is _ImageryInType.DATASETMOSAIC:
            ds = get_output_datasource(out_data_target)
            conn_info = DatasourceConnectionInfo(out_return[0], EngineType.IMAGEPLUGINS)
            ds_result = open_datasource(conn_info)
            dt_ms = ds.create_mosaic_dataset(out_dataset_name, ds_result.prj_coordsys, adjust_name=True)
            dt_ms.add_files(out_return)
            out_return.clear()
            out_return.append(os.path.join(out_data, dt_ms.name))
            dt_ms.close()
            ds_result.close()
        if output_type == 'Datasource' and self.__imagery_in_type is not _ImageryInType.DATASETMOSAIC:
            from iobjectspy import MultiBandImportMode,import_tif
            out_data_list_datadset = []
            for i in out_return:
                dst_name = os.path.splitext(os.path.basename(i))[0]
                dt = import_tif(os.path.abspath(i), output=out_data, out_dataset_name=dst_name,multi_band_mode=MultiBandImportMode.MULTIBAND)
                if isinstance(out_data_target,Datasource):
                    out_data_list_datadset.append(os.path.join(out_data_target.connection_info.server,dt[0]))
                else:
                    out_data_list_datadset.append(os.path.join(out_data_target, dt[0]))
            out_return = out_data_list_datadset
        return out_return

    def object_classify_infer(self, input_data, input_region, field_name='class_type', **kwargs):
        '''
        影像对象分类
        支持tif影像数据，对应的影像区域矢量数据集

        :param input_data: 待推理的数据
        :type  input_data: str
        :param input_region: 对应的矢量面数据集
        :type  input_region: DatasetVector
        :param field_name: 输出类别的字段名称
        :type  field_name: str
        :return: 数据集名称

        '''
        if isinstance(input_region, DatasetVector):
            TypeError(f'input_corres_region must be DatasetVector, but got {type(input_region)}')
        if not _is_image_file(input_data):
            # 单张影像文件
            TypeError(f'Infer Data Type must be Single Imagery File.')
        result = self.__inferece_obj.infer(input_data, input_region, field_name, **kwargs)
        return result

    def __get_dataset_to_tmp_tif_path(self, input_data):
        temp_tif_path = os.path.join(self.tmp_data_dir,
                                     self.__func_class.lower() + str(round(time.time() * 1000)) + '.tif')
        conversion.export_to_tif(input_data, temp_tif_path)
        log_info('Tmp Imagery is Saved in: {}'.format(temp_tif_path))
        return temp_tif_path

    def __get_out_data(self, out_data):
        if isinstance(out_data, Datasource):
            if out_data.connection_info.server == ':memory:':
                return out_data
            else:
                return out_data.connection_info.server
        elif isinstance(out_data, str):
            if out_data.startswith("--server"):
                connection_info = {param.split('=')[0]: param.split('=')[1].strip() for param in
                                   [i for i in out_data.split('--') if i != '']}
                return connection_info.get("server")
            else:
                return out_data
        else:
            raise TypeError('Input out_data type:{} is not supporter!'.format(out_data.type))

    def __get_input_data_list(self, input_data, infer_region):
        infer_list = []
        if isinstance(input_data, DatasetImage):
            # 单张影像数据集对象
            self.__imagery_in_type = _ImageryInType.DATASETIMAGE
            log_info('Infer Data Type: DatasetImage.')
            infer_list.append(self.__get_dataset_to_tmp_tif_path(input_data))
            if isinstance(infer_region, list):
                raise TypeError('Inference region should be dataset or bounds.')

        elif isinstance(input_data, DatasetMosaic):
            # 镶嵌数据集对象
            self.__imagery_in_type = _ImageryInType.DATASETMOSAIC
            log_info('Infer Data Type: DatasetMosaic.')
            infer_list = input_data.list_files()
            if isinstance(infer_region, list):
                raise TypeError('Inference region should be dataset or bounds.')

        elif isinstance(input_data, list):
            # 影像文件路径list对象
            self.__imagery_in_type = _ImageryInType.FILELIST
            log_info('Infer Data Type: Imagery File List.')
            infer_list = input_data
            if isinstance(infer_region, list):
                if len(infer_region) != len(input_data):
                    raise IndexError('The number of infer regions is inconsistent with the number of input images!')

        elif isinstance(input_data, str):
            if isinstance(infer_region, list):
                raise TypeError('Inference region should be dataset or bounds.')
            if os.path.isdir(input_data):
                # 含有影像文件的目录
                self.__imagery_in_type = _ImageryInType.FILEDIR
                log_info('Infer Data Type: Imagery File Directory.')
                infer_list = get_pic_path_from_dir(input_data, True, self._img_ext)

            elif _is_image_file(input_data):
                # 单张影像文件
                self.__imagery_in_type = _ImageryInType.SINGLEFILE
                log_info('Infer Data Type: Single Imagery File.')
                infer_list.append(input_data)
            elif input_data.startswith('--'):
                #连接信息字符串
                connection_info = {param.split('=')[0]: param.split('=')[1].strip() for param in
                                   [i for i in input_data.split('--') if i != '']}
                ds = open_datasource(connection_info.get("server"))
                dt = ds[connection_info.get("dataset")]
                if isinstance(dt, DatasetMosaic):
                    #镶嵌数据集
                    self.__imagery_in_type = _ImageryInType.DATASETMOSAIC
                    infer_list = dt.list_files()
                elif isinstance(dt, DatasetImage):
                    # 单张数据集连接信息
                    self.__imagery_in_type = _ImageryInType.DATASETIMAGE
                    infer_list.append(self.__get_dataset_to_tmp_tif_path(dt))
            elif input_data.endswith(".txt"):
                self.__imagery_in_type = _ImageryInType.FILELIST
                with open(input_data, 'r', encoding='utf-8') as f:
                    lines = f.readlines()
                # 去除每行末尾的换行符
                infer_list = [line.strip() for line in lines]
            elif input_data.endswith(".csv"):
                self.__imagery_in_type = _ImageryInType.FILELIST
                import csv
                # 打开CSV文件
                with open(input_data, 'r', encoding='utf-8') as f:
                    csv_reader = csv.reader(f)
                    # 读取每一行并存储到列表中
                    infer_list = [row[0] for row in csv_reader if row]
            else:
                # 字符串形式输入的数据集形式，支持单张影像数据集和镶嵌数据集
                #example: D://img.udbx/data
                try:
                    input_data = _get_dataset_readonly(input_data)
                except Exception:
                    traceback.print_exc()
                    raise TypeError('Input Data Type is not Supported!')

                if isinstance(input_data, DatasetMosaic):
                    self.__imagery_in_type = _ImageryInType.DATASETMOSAIC
                    log_info('Infer Data Type: DatasetMosaic.')
                    infer_list = input_data.list_files()

                elif isinstance(input_data, DatasetImage):
                    self.__imagery_in_type = _ImageryInType.DATASETIMAGE
                    log_info('Infer Data Type: DatasetImage.')
                    infer_list.append(self.__get_dataset_to_tmp_tif_path(input_data))
                else:
                    raise TypeError('Input Data Type is not Supported!')
        else:
            raise TypeError('Input Data Type is not Supported!')

        return infer_list

    def __get_input_region_dataset(self,region):
        #将获取到的各种格式的数据集输入转换成数据集对象为唯一输出
        valid_types = (str, list, Dataset, Rectangle, type(None))
        if not any(isinstance(region, t) for t in valid_types):
            TypeError(f'input region_dataset must not be any of {valid_types}, but got {type(region)}')
        if isinstance(region,str):
            if region.startswith('--server'):
                connection_info = {param.split('=')[0]: param.split('=')[1].strip() for param in
                                   [i for i in region.split('--') if i != '']}

                return open_datasource(connection_info.get("server"))[connection_info.get("dataset")]
            else:
              return _get_dataset_readonly(region)
        else:
            return region

    def __get_return(self,return_list,out_path,result_dataset_name):
        if result_dataset_name != None:
            if isinstance(out_path, str):
                return_list.append(os.path.abspath(os.path.join(out_path, result_dataset_name)))
            else:
                return_list.append(result_dataset_name)
        return return_list



class PictureInference:
    def __init__(self, model_path, gpus=[0], batch_size=1, **kwargs):
        """
        图片数据模型推理功能入口

        :param model_path: 模型存储路径
        :type  model_path: str

        """
        check_lic()
        self.config = get_config_from_yaml(model_path)
        self.model_path = model_path
        self.kwargs = kwargs
        self.__func_class = ''.join([x.capitalize() for x in self.config.model_type.split('_')])
        if self.__func_class == 'ObjectDetection':
            from ._inference_collector.object_detection_infer import ObjectDetection
        elif self.__func_class == 'BinaryClassification':
            from ._inference_collector.binary_classification_infer import BinaryClassification
        elif self.__func_class == 'MultiClassification':
            from ._inference_collector.multi_classification_infer import MultiClassification
        elif self.__func_class == 'SceneClassification':
            from ._inference_collector.scene_classification_infer import SceneClassification
        elif self.__func_class == 'ImageClassification':
            from ._inference_collector.image_classification_infer import ImageClassification
        elif self.__func_class == 'ObjectExtraction':
            from ._inference_collector.object_extraction_infer import ObjectExtraction
        self.__inferece_obj = eval(self.__func_class)(self.model_path, gpus, batch_size, **kwargs)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def close(self):
        """
        清空已加载的模型
        """
        self.__inferece_obj.close_model()

    def __tempDirTool(method):
        # 装饰器：推理是否成功完成都可以清理temp文件夹，避免在用户C盘产生冗余文件
        def wrapper(self,*args, **kwargs):
            tmp_dir = get_out_data_dir(kwargs.get('out_data'))
            if tmp_dir is not None:
                if not os.path.exists(tmp_dir):
                    os.makedirs(tmp_dir)
            self.tmp_data_dir = os.path.abspath(tempfile.mkdtemp(prefix='tempSupermapMl_', dir=tmp_dir))
            os.environ[
                'SuperMapML_TempDir'] = self.tmp_data_dir  # 下层代码中需要用到temp文件夹时采用os.os.environ.get("SuperMapML_TempDir")方式获取temp文件路径
            log_info('ImageryInference class tmp directory is: \' {} \''.format(self.tmp_data_dir))
            try:
                return method(self, *args, **kwargs)
            except Exception as e:
                raise e
            finally:
                os.environ.pop('SuperMapML_TempDir')  # 清理temp文件夹路径环境变量
                try:
                    shutil.rmtree(self.tmp_data_dir)
                    print("Successfully cleared temporary folder:{}".format(self.tmp_data_dir))
                except Exception as e:
                    print("Clearing temporary folder:{} failed,please check the folder".format(self.tmp_data_dir))
                    raise e

        return wrapper

    @__tempDirTool
    def object_detect_infer(self, input_data, out_data, out_dataset_name, category_name):
        """
        图片目标检测

        | 支持 jpg、png等图像文件，检测结果为xml

        :param input_data: 待推理的数据
        :type  input_data: str or Dataset
        :param out_data: 输出文件（或数据源）路径
        :type  out_data: str or Datasource or DatasourceConnectionInfo
        :param out_dataset_name: 输出文件（或数据集）名称
        :type  out_dataset_name: str
        :param category_name: 目标检测类别，支持多类别检测
        :type  category_name: list[str] or str
        :return: None
        """
        input_data_tmp = self.__before_infer(input_data)
        result = self.__inferece_obj.infer_pic(input_data_tmp, out_data, out_dataset_name, category_name)
        return result

    @__tempDirTool
    def picture_classify_infer(self, input_data, out_data, out_dataset_name, **kwargs):
        """
        图片分类
        支持jpg、png等图像文件，分类结果为xml

        :param input_data: 待推理的数据
        :type  input_data: str or Dataset
        :param out_data: 输出文件（或数据源）路径
        :type  out_data: str or Datasource or DatasourceConnectionInfo
        :param out_dataset_name: 输出文件（或数据集）名称
        :type  out_dataset_name: str
        :param result_type: 结果返回类型，支持矢量面和栅格: 'region' or 'grid'
        :type result_type: str
        :return: 数据集名字
        """
        # todo not supported input preprocess
        # input_data_tmp = self.__before_infer(input_data)
        result = self.__inferece_obj.infer(input_data, out_data, out_dataset_name, **kwargs)

        return result

    @__tempDirTool
    def object_extract_infer(self, input_data, out_visual_result, out_txt_result):
        """
        基于图片的实例分割
        支持jpg、png等图像文件，分类结果为mask（png或者jpg）和txt描述文件
        :param input_data: 待推理的数据
        :type  input_data: str or Dataset
        :param out_visual_result: 输出检测图像结果路径
        :type  out_visual_result: str
        :param out_txt_result: 输出检测txt结果路径
        :type  out_txt_result: str
        :return: None
        """
        image_path_list = self.__before_infer(input_data)
        result = self.__inferece_obj.infer_pic(image_path_list, out_visual_result, out_txt_result)

        return result

    def __get_tmp_input_data_path(self, input_data):
        if isinstance(input_data, str):
            if os.path.isdir(input_data):
                self.__is_del_tmp_file = False
            elif _is_image_file(input_data):
                self.__is_del_tmp_file = False
        else:
            self.__is_del_tmp_file = True
            input_data = _get_dataset_readonly(input_data)
            temp_tif_path = os.path.join(self.tmp_data_dir,
                                         self.__func_class.lower() + str(round(time.time() * 1000)) + '.tif')
            conversion.export_to_tif(input_data, temp_tif_path)
            input_data = temp_tif_path

        return input_data

    def __before_infer(self, input_data):
        input_data = self.__get_tmp_input_data_path(input_data)
        image_path_list = self.__get_image_path(input_data)

        return image_path_list

    def __get_image_path(self, input_data, get_all_dir=False, suffix=None):
        """
        判断输入是单个文件还是文件夹;
        设置参数判断是否读取嵌套的子文件目录;
        通过后缀来过滤图片，将他们的完整路径都保存到一个列表;

        :param input_data: 输入数据的路径
        :type input_data: str
        :param get_all_dir: 是否推理输入路径下所有子目录内图片
        :type get_all_dir: bool
        :param suffix: 指定待推理图片的后缀，并以此来过滤文件夹下数据
        :type suffix: list

        :return image_path_list: 所有待推理图片的完整路径
        :type image_path_list: list
        """
        image_path_list = []

        if not os.path.exists(input_data):
            raise ValueError("The input path doesn't exist, please check the  path {}".format(input_data))

        # 指定推理图片的后缀
        if suffix is None:
            suffix = ["jpg", "tif", "png", "jpeg", "JPG", "TIF", "PNG", "JPEG"]

        # 判断输入是单个文件还是文件夹
        if os.path.isdir(input_data):
            image_path_list = get_pic_path_from_dir(input_data, get_all_dir, suffix)
        else:
            image_path_list.append(input_data)

        return image_path_list
