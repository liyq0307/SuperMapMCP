# !/usr/bin/env python3
# coding=utf-8
import os, json, shutil, random
from collections import OrderedDict
from tqdm import tqdm
import rasterio
import cv2
import numpy as np
from iobjectspy import Rectangle
from iobjectspy._logger import log_info, log_error
from iobjectspy.ml.toolkit._create_training_data_util import _save_img, get_tile_start_index, _get_input_feature, \
    _get_bandnum
from iobjectspy.ml.toolkit._toolkit import save_config_to_yaml, get_config_from_yaml


class CreateObjectDetectionData(object):
    def __init__(self, input_data, input_label, label_class_field, output_path, output_name, training_data_format,
                 tile_format='jpg', tile_size_x=1024, tile_size_y=1024, tile_offset_x=512, tile_offset_y=512,
                 tile_start_index=0,
                 save_nolabel_tiles=False, **kwargs):
        self.input_data = input_data
        self.input_label = input_label
        self.label_class_field = label_class_field
        self.output_path = output_path
        self.output_name = output_name
        self.training_data_format = training_data_format
        self.tile_format = tile_format
        self.tile_size_x = tile_size_x
        self.tile_size_y = tile_size_y
        self.tile_offset_x = tile_offset_x
        self.tile_offset_y = tile_offset_y
        self.tile_start_index = tile_start_index
        self.save_nolabel_tiles = save_nolabel_tiles
        self.kwargs = kwargs

    def create_voc(self):
        output_path_img = os.path.join(self.output_path, self.output_name, 'Images')
        output_path_label = os.path.join(self.output_path, self.output_name, 'Annotations')
        output_path_main = os.path.join(self.output_path, self.output_name, 'ImageSets', 'Main')
        output_voc_sda = os.path.join(self.output_path, self.output_name, self.output_name + '.sda')
        if not os.path.exists(output_path_img):
            os.makedirs(output_path_img)
        if not os.path.exists(output_path_label):
            os.makedirs(output_path_label)
        if not os.path.exists(output_path_main):
            os.makedirs(output_path_main)
        # 获取训练数据记录数索引
        temp_tile_index, end_index = get_tile_start_index(self.tile_start_index, output_voc_sda)

        with rasterio.open(self.input_data) as ds:
            transf = ds.transform

            rectangle = self.kwargs.get("rectangle")
            if rectangle is None:
                rectangle = Rectangle(max(self.input_label.bounds.left, ds.bounds.left),
                                      max(self.input_label.bounds.bottom, ds.bounds.bottom),
                                      min(self.input_label.bounds.right, ds.bounds.right),
                                      min(self.input_label.bounds.top, ds.bounds.top))
            log_info('Training data boundary：'.format(rectangle))

            rectangle_ymin, rectangle_xmin = rasterio.transform.rowcol(transf, rectangle.left,
                                                                       rectangle.top)
            rectangle_ymax, rectangle_xmax = rasterio.transform.rowcol(transf, rectangle.right,
                                                                       rectangle.bottom)
            width_block_num = int((rectangle_xmax - rectangle_xmin) // self.tile_size_x)
            height_block_num = int((rectangle_ymax - rectangle_ymin) // self.tile_size_y)
            if self.tile_offset_x == 0 and self.tile_offset_y == 0:
                block_num = height_block_num * width_block_num
            elif self.tile_offset_x == 0 and self.tile_offset_y != 0:
                block_num = (2 * height_block_num - 1) * width_block_num
            elif self.tile_offset_x != 0 and self.tile_offset_y == 0:
                block_num = (2 * width_block_num - 1) * height_block_num
            else:
                block_num = height_block_num * width_block_num + (
                        height_block_num - 1) * width_block_num + height_block_num * (width_block_num - 1) + (
                                    height_block_num - 1) * (width_block_num - 1)
            #  total参数设置进度条的总长度为100
            pbar = tqdm(total=block_num)

            for i in range(height_block_num):
                for j in range(width_block_num):
                    # 通过矩形框与滑动窗口来计算矩形框的重叠部分,block_xmin是block像素框的x坐标的最小框
                    block_xmin = rectangle_xmin + j * self.tile_size_x
                    block_ymin = rectangle_ymin + i * self.tile_size_y
                    # coord_min保存地理坐标[left,top].coord_max保存地理坐标[right,bottom].
                    coord_min = rasterio.transform.xy(transf, int(block_ymin), int(block_xmin))
                    coord_max = rasterio.transform.xy(transf, int(block_ymin + self.tile_size_y),
                                                      int(block_xmin + self.tile_size_x))
                    # coord_offset_min保存偏移后的地理坐标[left,top].coord_offset_max保存偏移后地理坐标[right,bottom].
                    coord_offset_min = rasterio.transform.xy(transf, int(block_ymin + self.tile_offset_y),
                                                             int(block_xmin + self.tile_offset_x))
                    coord_offset_max = rasterio.transform.xy(transf,
                                                             int(block_ymin + self.tile_offset_y + self.tile_size_y),
                                                             int(block_xmin + self.tile_offset_x + self.tile_size_x))

                    tile_box = Rectangle(coord_min[0],
                                         coord_min[1],
                                         coord_max[0],
                                         coord_max[1])
                    # 根据tile的bounds查询recordSet
                    recordset = self.input_label.query_with_bounds(tile_box, cursor_type='STATIC')
                    temp_input_label = recordset.get_features()
                    transf_tile = rasterio.transform.from_bounds(coord_min[0], coord_max[1],
                                                                 coord_max[0], coord_min[1],
                                                                 self.tile_size_x, self.tile_size_y)
                    temp_tile_index = self._save_images_labels(temp_input_label, ds, block_xmin, block_ymin,
                                                               transf_tile, temp_tile_index)
                    recordset.close()
                    #  每次更新进度条的长度为1
                    pbar.update(1)

                    if self.tile_offset_x != 0:
                        if j != (width_block_num - 1):
                            # x方向偏移
                            tile_box = Rectangle(coord_offset_min[0],
                                                 coord_min[1],
                                                 coord_offset_max[0],
                                                 coord_max[1])
                            recordset = self.input_label.query_with_bounds(tile_box, cursor_type='STATIC')

                            temp_input_label = recordset.get_features()
                            transf_tile = rasterio.transform.from_bounds(coord_offset_min[0],
                                                                         coord_max[1],
                                                                         coord_offset_max[0],
                                                                         coord_min[1],
                                                                         self.tile_size_x, self.tile_size_y)
                            temp_tile_index = self._save_images_labels(temp_input_label, ds,
                                                                       block_xmin + self.tile_offset_x,
                                                                       block_ymin,
                                                                       transf_tile, temp_tile_index)
                            recordset.close()
                            #  每次更新进度条的长度为1
                            pbar.update(1)

                    if self.tile_offset_y != 0:
                        if i != (height_block_num - 1):
                            # y方向偏移
                            tile_box = Rectangle(coord_min[0],
                                                 coord_offset_min[1],
                                                 coord_max[0],
                                                 coord_offset_max[1])
                            recordset = self.input_label.query_with_bounds(tile_box, cursor_type='STATIC')
                            temp_input_label = recordset.get_features()
                            transf_tile = rasterio.transform.from_bounds(coord_min[0],
                                                                         coord_offset_max[1],
                                                                         coord_max[0],
                                                                         coord_offset_min[1],
                                                                         self.tile_size_x, self.tile_size_y)
                            temp_tile_index = self._save_images_labels(temp_input_label, ds, block_xmin,
                                                                       block_ymin + self.tile_offset_y,
                                                                       transf_tile, temp_tile_index)
                            recordset.close()
                            #  每次更新进度条的长度为1
                            pbar.update(1)

                    if self.tile_offset_x != 0 and self.tile_offset_y != 0:
                        if (i != (height_block_num - 1)) & (j != (width_block_num - 1)):
                            # 右下方向偏移
                            tile_box = Rectangle(coord_offset_min[0],
                                                 coord_offset_min[1],
                                                 coord_offset_max[0],
                                                 coord_offset_max[1])
                            recordset = self.input_label.query_with_bounds(tile_box, cursor_type='STATIC')
                            temp_input_label = recordset.get_features()
                            transf_tile = rasterio.transform.from_bounds(coord_offset_min[0],
                                                                         coord_offset_max[1],
                                                                         coord_offset_max[0],
                                                                         coord_offset_min[1],
                                                                         self.tile_size_x, self.tile_size_y)
                            temp_tile_index = self._save_images_labels(temp_input_label, ds,
                                                                       block_xmin + self.tile_offset_x,
                                                                       block_ymin + self.tile_offset_y,
                                                                       transf_tile, temp_tile_index)
                            recordset.close()
                            #  每次更新进度条的长度为1
                            pbar.update(1)


            #  关闭占用的资源
            pbar.close()
            temp_input_label = _get_input_feature(self.input_label)
            # 构建目标检测训练数据配置文件
            try:
                config = get_config_from_yaml(output_voc_sda)
                log_info(
                    'Get the number of pixels of each category and color table information from  {} '.format(
                        output_voc_sda))
                categorys = config.dataset.get('classes')
                for i in temp_input_label:
                    category = i.get_value(self.label_class_field)
                    # 获取数据集中category字段保存的类别
                    if category not in categorys:
                        categorys.append(category)
            except:
                categorys = []
                if self.label_class_field is None:
                    categorys.append('unspecified')
                else:
                    try:
                        for i in temp_input_label:
                            category = i.get_value(self.label_class_field)
                            # 获取数据集中category字段保存的类别
                            if category not in categorys:
                                categorys.append(category)
                    except:
                        log_error(
                            'The category field is set and information cannot be queried from the　category field，KeyError：{} '.format(
                                self.label_class_field))
            input_bandnum = _get_bandnum(ds, self.tile_format)
            # 构建配置文件字典
            dic_sda = OrderedDict({
                'dataset': OrderedDict({"name": "example_oe",
                                        'classes': categorys,
                                        'image_count': temp_tile_index,
                                        "data_type": "oe",
                                        "input_bandnum": input_bandnum, "input_ext": ds.dtypes[0],
                                        "x_ext": self.input_data.split(".")[-1],
                                        "tile_size_x": self.tile_size_x,
                                        "tile_size_y": self.tile_size_y,
                                        "tile_offset_x": self.tile_offset_x,
                                        "tile_offset_y": self.tile_offset_y,
                                        "image_mean": [115.6545965, 117.62014299, 106.01483799],
                                        "image_std": [56.82521775, 53.46318049, 56.07113724]}),

            })
            save_config_to_yaml(dic_sda, output_voc_sda)

            # 保存索引文件
            self._save_index_file()
            print('train data saved to `{:s}`'.format(os.path.join(self.output_path, self.output_name)))

    def _get_features_box(self, temp_input_label, block_xmin, block_ymin, transf):
        """
        计算 features_box ,存储像素坐标以及类别信息

        """
        features_box = []
        block_xmax = block_xmin + self.tile_size_x
        block_ymax = block_ymin + self.tile_size_y
        for feature_index in temp_input_label:
            # category是feature的类别
            if self.label_class_field is None:
                category = 'unspecified'
            else:
                try:
                    category = feature_index.get_value(self.label_class_field)
                except:
                    log_error(
                        'The category field is set and information cannot be queried from the category　field，KeyError：{} '.format(
                            self.label_class_field))

            # 地理坐标的影像bbox计算
            feature_xmin_geo = feature_index.geometry.bounds.left
            feature_xmax_geo = feature_index.geometry.bounds.right

            feature_ymin_geo = feature_index.geometry.bounds.bottom
            feature_ymax_geo = feature_index.geometry.bounds.top
            # 地理坐标转换为像素坐标
            feature_ymax, feature_xmin = rasterio.transform.rowcol(transf, feature_xmin_geo,
                                                                   feature_ymin_geo)
            feature_ymin, feature_xmax = rasterio.transform.rowcol(transf, feature_xmax_geo,
                                                                   feature_ymax_geo)
            # feature_half_length_x指代像素框x方向边长的一半
            feature_half_length_x = abs(feature_xmax - feature_xmin) / 2
            feature_half_length_y = abs(feature_ymax - feature_ymin) / 2
            list_bbox = []
            # 所有需要提取标签的框,包括feature框有一半的范围在block中此时保存为0
            if (feature_xmin >= (block_xmin - feature_half_length_x)) & (
                    feature_xmax <= (block_xmax + feature_half_length_x)) & (
                    feature_ymin >= (block_ymin - feature_half_length_y)) & (
                    feature_ymax <= (block_ymax + feature_half_length_y)):

                if (feature_xmin - block_xmin) < 0:
                    xmin = 0
                else:
                    xmin = round(feature_xmin - block_xmin, 2)

                if (feature_ymin - block_ymin) < 0:
                    ymin = 0
                else:
                    ymin = round(feature_ymin - block_ymin, 2)

                if (block_xmax - feature_xmax) < 0:
                    xmax = block_xmax - block_xmin
                else:
                    xmax = round(feature_xmax - block_xmin, 2)
                if (block_ymax - feature_ymax) < 0:
                    ymax = block_ymax - block_ymin
                else:
                    ymax = round(feature_ymax - block_ymin, 2)
                if xmin < xmax - 2 and ymin < ymax - 2:
                    list_bbox.append(xmin)
                    list_bbox.append(ymin)
                    list_bbox.append(xmax)
                    list_bbox.append(ymax)

                    list_bbox.append(category)

                    list_bbox.append(0)
                    features_box.append(list_bbox)
        return features_box

    def _save_images_labels(self, temp_input_label, ds, block_xmin, block_ymin,
                            transf_tile, temp_tile_index):
        """
        计算 features_box ,存储像素坐标以及类别信息

        """
        block_xmax = block_xmin + self.tile_size_x
        block_ymax = block_ymin + self.tile_size_y
        height = ds.height
        width = ds.width
        tile_size_x = self.tile_size_x
        tile_size_y = self.tile_size_y
        if height <= block_ymax:
            tile_size_y = height - block_ymin
        if width <= block_xmax:
            tile_size_x = width - block_xmin

        # 给索引补0
        start_index_string = str(temp_tile_index).zfill(8)
        transf = ds.transform
        output_path_img = os.path.join(self.output_path, self.output_name, 'Images', start_index_string)
        output_path_label = os.path.join(self.output_path, self.output_name, 'Annotations')

        features_box = self._get_features_box(temp_input_label, block_xmin, block_ymin,
                                              transf)

        if self.save_nolabel_tiles == False:
            if features_box:
                # 保存tile文件（图像）
                _save_img(ds, self.tile_format,
                          block_xmin, block_ymin, tile_size_x, tile_size_y,
                          output_path_img, transf_tile, self.input_data)
                # 保存xml文件（标签）
                if self.tile_format == 'origin':
                    self._save_xml(output_path_label, features_box, tile_size_x, tile_size_y,
                                   start_index_string + '.' + self.input_data.split(".")[-1], ds.count)
                else:
                    self._save_xml(output_path_label, features_box, tile_size_x, tile_size_y,
                                   start_index_string + '.' + self.tile_format, ds.count)
                temp_tile_index = temp_tile_index + 1
        else:
            # 保存tile文件（图像）
            _save_img(ds, self.tile_format,
                      block_xmin, block_ymin, tile_size_x, tile_size_y,
                      output_path_img, transf_tile, self.input_data)
            # 保存xml文件（标签）
            if self.tile_format == 'origin':
                self._save_xml(output_path_label, features_box, tile_size_x, tile_size_y,
                               start_index_string + '.' + self.input_data.split(".")[-1], ds.count)
            else:
                self._save_xml(output_path_label, features_box, tile_size_x, tile_size_y,
                               start_index_string + '.' + self.tile_format, ds.count)
            temp_tile_index = temp_tile_index + 1

        return temp_tile_index

    def _save_xml(self, output_path_label, lists, width, height, pic_name, depth):
        """
        生成xml描述文件

        :param output_path_label: 输入标签文件存储路径
        :type output_path_label: str
        :param lists: 包含bbox，category，difficult信息
        :type lists: list
        :param width: 图像宽度
        :type width: Long
        :param height: 图像高度
        :type height: Long
        :param pic_name: 对应标签文件的图片名称
        :type pic_name: str
        :param tile_format: 切片的图像格式:TIFF,PNG,JPG
        :type tile_format: str

        """
        if self.tile_format == 'jpg' or self.tile_format == 'png':
            depth = 3
        from lxml.etree import Element, SubElement, tostring

        node_root = Element('annotation')

        node_folder = SubElement(node_root, 'folder')
        node_folder.text = 'VOC'

        node_filename = SubElement(node_root, 'filename')
        node_filename.text = pic_name

        node_size = SubElement(node_root, 'size')
        node_width = SubElement(node_size, 'width')
        node_width.text = '%s' % width

        node_height = SubElement(node_size, 'height')
        node_height.text = '%s' % height

        node_depth = SubElement(node_size, 'depth')
        node_depth.text = '%s' % depth

        node_segmented = SubElement(node_root, 'segmented')
        node_segmented.text = '%s' % 0

        for list in lists:
            node_object = SubElement(node_root, 'object')
            node_name = SubElement(node_object, 'name')
            node_name.text = str(list[4])
            node_difficult = SubElement(node_object, 'difficult')
            node_difficult.text = str(list[5])
            node_truncated = SubElement(node_object, 'truncated')
            node_truncated.text = str(0)
            node_bndbox = SubElement(node_object, 'bndbox')
            node_xmin = SubElement(node_bndbox, 'xmin')
            node_xmin.text = '%s' % list[0]
            node_ymin = SubElement(node_bndbox, 'ymin')
            node_ymin.text = '%s' % list[1]
            node_xmax = SubElement(node_bndbox, 'xmax')
            node_xmax.text = '%s' % list[2]
            node_ymax = SubElement(node_bndbox, 'ymax')
            node_ymax.text = '%s' % list[3]
        xml = tostring(node_root, pretty_print=True, encoding='UTF-8')

        save_xml = os.path.join(output_path_label, pic_name.split('.')[0] + '.xml')

        with open(save_xml, 'wb') as f:
            f.write(xml)

    def _save_index_file(self):
        """
        将数据划分为训练集、测试集、验证集

        """
        output_path_img = os.path.join(self.output_path, self.output_name, 'Images')
        output_path_main = os.path.join(self.output_path, self.output_name, 'ImageSets', 'Main')
        # 随机将数据分为train、val、test数据
        pic_names = os.listdir(output_path_img)
        # 分配训练数据验证数据的数组长度
        train_length = int((len(pic_names) / 5) * 4)
        val_length = int(len(pic_names) / 10)
        # 训练数据集、验证数据集、测试数据集数组
        list_train = pic_names[0:train_length]
        list_val = pic_names[train_length:train_length + val_length]
        list_test = pic_names[train_length + val_length:]
        list_trainval = list_train + list_val
        # 打开创建的文件
        train_txt = open(os.path.join(output_path_main, 'train.txt'), "w")
        val_txt = open(os.path.join(output_path_main, 'val.txt'), "w")
        test_txt = open(os.path.join(output_path_main, 'test.txt'), "w")
        trainval_txt = open(os.path.join(output_path_main, 'trainval.txt'), "w")

        for pic_name in list_train:
            label_name = pic_name.split('.')[0]
            train_txt.write(label_name + '\n')
        for pic_name in list_val:
            label_name = pic_name.split('.')[0]
            val_txt.write(label_name + '\n')
        for pic_name in list_test:
            label_name = pic_name.split('.')[0]
            test_txt.write(label_name + '\n')
        for pic_name in list_trainval:
            label_name = pic_name.split('.')[0]
            trainval_txt.write(label_name + '\n')

        # 关闭所有打开的文件
        train_txt.close()
        val_txt.close()
        test_txt.close()
        trainval_txt.close()


class CreateODObjectDetectionData(object):
    def __init__(self, input_data, input_label, label_class_field, output_path, output_name, training_data_format,
                 tile_format='jpg', tile_size_x=1024, tile_size_y=1024, tile_offset_x=512, tile_offset_y=512,
                 tile_start_index=0,
                 save_nolabel_tiles=False, **kwargs):
        self.input_data = input_data
        self.input_label = input_label
        self.label_class_field = label_class_field
        self.output_path = output_path
        self.output_name = output_name
        self.training_data_format = training_data_format
        self.tile_format = tile_format
        self.tile_size_x = tile_size_x
        self.tile_size_y = tile_size_y
        self.tile_offset_x = tile_offset_x
        self.tile_offset_y = tile_offset_y
        self.tile_start_index = tile_start_index
        self.save_nolabel_tiles = save_nolabel_tiles
        self.kwargs = kwargs

    def create_od(self):
        output_path_img = os.path.join(self.output_path, self.output_name, 'Images')
        output_path_train_label = os.path.join(self.output_path, self.output_name, 'Annotations_train')
        output_path_val_label = os.path.join(self.output_path, self.output_name, 'Annotations_val')
        output_sda = os.path.join(self.output_path, self.output_name, self.output_name + '.sda')
        if not os.path.exists(output_path_img):
            os.makedirs(output_path_img)
        if not os.path.exists(output_path_train_label):
            os.makedirs(output_path_train_label)
        if not os.path.exists(output_path_val_label):
            os.makedirs(output_path_val_label)
        # 获取训练数据记录数索引
        temp_tile_index, end_index = get_tile_start_index(self.tile_start_index, output_sda)

        with rasterio.open(self.input_data) as ds:
            transf = ds.transform

            rectangle = self.kwargs.get("rectangle")
            if rectangle is None:
                rectangle = Rectangle(max(self.input_label.bounds.left, ds.bounds.left),
                                      max(self.input_label.bounds.bottom, ds.bounds.bottom),
                                      min(self.input_label.bounds.right, ds.bounds.right),
                                      min(self.input_label.bounds.top, ds.bounds.top))
            log_info('Training data boundary：'.format(rectangle))

            rectangle_ymin, rectangle_xmin = rasterio.transform.rowcol(transf, rectangle.left,
                                                                       rectangle.top)
            rectangle_ymax, rectangle_xmax = rasterio.transform.rowcol(transf, rectangle.right,
                                                                       rectangle.bottom)
            width_block_num = int((rectangle_xmax - rectangle_xmin) // self.tile_size_x)
            height_block_num = int((rectangle_ymax - rectangle_ymin) // self.tile_size_y)
            if self.tile_offset_x == 0 and self.tile_offset_y == 0:
                block_num = height_block_num * width_block_num
            elif self.tile_offset_x == 0 and self.tile_offset_y != 0:
                block_num = (2 * height_block_num - 1) * width_block_num
            elif self.tile_offset_x != 0 and self.tile_offset_y == 0:
                block_num = (2 * width_block_num - 1) * height_block_num
            else:
                block_num = height_block_num * width_block_num + (
                        height_block_num - 1) * width_block_num + height_block_num * (width_block_num - 1) + (
                                    height_block_num - 1) * (width_block_num - 1)
            #  total参数设置进度条的总长度为100
            pbar = tqdm(total=block_num)

            for i in range(height_block_num):
                for j in range(width_block_num):
                    # 通过矩形框与滑动窗口来计算矩形框的重叠部分,block_xmin是block像素框的x坐标的最小框
                    block_xmin = rectangle_xmin + j * self.tile_size_x
                    block_ymin = rectangle_ymin + i * self.tile_size_y
                    # coord_min保存地理坐标[left,top].coord_max保存地理坐标[right,bottom].
                    coord_min = rasterio.transform.xy(transf, int(block_ymin), int(block_xmin))
                    coord_max = rasterio.transform.xy(transf, int(block_ymin + self.tile_size_y),
                                                      int(block_xmin + self.tile_size_x))
                    # coord_offset_min保存偏移后的地理坐标[left,top].coord_offset_max保存偏移后地理坐标[right,bottom].
                    coord_offset_min = rasterio.transform.xy(transf, int(block_ymin + self.tile_offset_y),
                                                             int(block_xmin + self.tile_offset_x))
                    coord_offset_max = rasterio.transform.xy(transf,
                                                             int(block_ymin + self.tile_offset_y + self.tile_size_y),
                                                             int(block_xmin + self.tile_offset_x + self.tile_size_x))

                    tile_box = Rectangle(coord_min[0],
                                         coord_min[1],
                                         coord_max[0],
                                         coord_max[1])
                    # 根据tile的bounds查询recordSet
                    recordset = self.input_label.query_with_bounds(tile_box, cursor_type='STATIC')
                    temp_input_label = recordset.get_features()
                    transf_tile = rasterio.transform.from_bounds(coord_min[0], coord_max[1],
                                                                 coord_max[0], coord_min[1],
                                                                 self.tile_size_x, self.tile_size_y)
                    temp_tile_index = self._save_images_labels_od(temp_input_label, ds, block_xmin, block_ymin,
                                                                 transf_tile, temp_tile_index)
                    recordset.close()
                    #  每次更新进度条的长度为1
                    pbar.update(1)

                    if self.tile_offset_x != 0:
                        if j != (width_block_num - 1):
                            # x方向偏移
                            tile_box = Rectangle(coord_offset_min[0],
                                                 coord_min[1],
                                                 coord_offset_max[0],
                                                 coord_max[1])
                            recordset = self.input_label.query_with_bounds(tile_box, cursor_type='STATIC')

                            temp_input_label = recordset.get_features()
                            transf_tile = rasterio.transform.from_bounds(coord_offset_min[0],
                                                                         coord_max[1],
                                                                         coord_offset_max[0],
                                                                         coord_min[1],
                                                                         self.tile_size_x, self.tile_size_y)
                            temp_tile_index = self._save_images_labels_od(temp_input_label, ds,
                                                                         block_xmin + self.tile_offset_x,
                                                                         block_ymin,
                                                                         transf_tile, temp_tile_index)
                            recordset.close()
                            #  每次更新进度条的长度为1
                            pbar.update(1)

                    if self.tile_offset_y != 0:
                        if i != (height_block_num - 1):
                            # y方向偏移
                            tile_box = Rectangle(coord_min[0],
                                                 coord_offset_min[1],
                                                 coord_max[0],
                                                 coord_offset_max[1])
                            recordset = self.input_label.query_with_bounds(tile_box, cursor_type='STATIC')
                            temp_input_label = recordset.get_features()
                            transf_tile = rasterio.transform.from_bounds(coord_min[0],
                                                                         coord_offset_max[1],
                                                                         coord_max[0],
                                                                         coord_offset_min[1],
                                                                         self.tile_size_x, self.tile_size_y)
                            temp_tile_index = self._save_images_labels_od(temp_input_label, ds, block_xmin,
                                                                         block_ymin + self.tile_offset_y,
                                                                         transf_tile, temp_tile_index)
                            recordset.close()
                            #  每次更新进度条的长度为1
                            pbar.update(1)

                    if self.tile_offset_x != 0 and self.tile_offset_y != 0:
                        if (i != (height_block_num - 1)) & (j != (width_block_num - 1)):
                            # 右下方向偏移
                            tile_box = Rectangle(coord_offset_min[0],
                                                 coord_offset_min[1],
                                                 coord_offset_max[0],
                                                 coord_offset_max[1])
                            recordset = self.input_label.query_with_bounds(tile_box, cursor_type='STATIC')
                            temp_input_label = recordset.get_features()
                            transf_tile = rasterio.transform.from_bounds(coord_offset_min[0],
                                                                         coord_offset_max[1],
                                                                         coord_offset_max[0],
                                                                         coord_offset_min[1],
                                                                         self.tile_size_x, self.tile_size_y)
                            temp_tile_index = self._save_images_labels_od(temp_input_label, ds,
                                                                         block_xmin + self.tile_offset_x,
                                                                         block_ymin + self.tile_offset_y,
                                                                         transf_tile, temp_tile_index)
                            recordset.close()
                            #  每次更新进度条的长度为1
                            pbar.update(1)

            #  关闭占用的资源
            pbar.close()
            temp_input_label = _get_input_feature(self.input_label)
            # 构建目标检测训练数据配置文件
            try:
                config = get_config_from_yaml(output_sda)
                log_info(
                    'Get the number of pixels of each category and color table information from  {} '.format(
                        output_sda))
                categorys = config.dataset.get('classes')
                for i in temp_input_label:
                    category = i.get_value(self.label_class_field)
                    # 获取数据集中category字段保存的类别
                    if category not in categorys:
                        categorys.append(category)
            except:
                categorys = []
                if self.label_class_field is None:
                    categorys.append('unspecified')
                else:
                    try:
                        for i in temp_input_label:
                            category = i.get_value(self.label_class_field)
                            # 获取数据集中category字段保存的类别
                            if category not in categorys:
                                categorys.append(category)
                    except:
                        log_error(
                            'The category field is set and information cannot be queried from the　category field，KeyError：{} '.format(
                                self.label_class_field))
            input_bandnum = _get_bandnum(ds, self.tile_format)
            if temp_tile_index < end_index:
                temp_tile_index = end_index
            # 构建配置文件字典
            dic_sda = OrderedDict({
                'dataset': OrderedDict({"name": "example_od",
                                        "data_type": "object_detection",
                                        'classes': categorys,
                                        'image_count': temp_tile_index,
                                        "input_bandnum": input_bandnum, "input_ext": ds.dtypes[0],
                                        "x_ext": self.input_data.split(".")[-1],
                                        "tile_size_x": self.tile_size_x,
                                        "tile_size_y": self.tile_size_y,
                                        "tile_offset_x": self.tile_offset_x,
                                        "tile_offset_y": self.tile_offset_y,
                                        "image_mean": [115.6545965, 117.62014299, 106.01483799],
                                        "image_std": [56.82521775, 53.46318049, 56.07113724]}),

            })
            save_config_to_yaml(dic_sda, output_sda)

            # 从train里面挑出来20%用于验证
            self._select_val_label(output_path_train_label, output_path_val_label)
            print('train data saved to `{:s}`'.format(os.path.join(self.output_path, self.output_name)))

    def _save_images_labels_od(self, temp_input_label, ds, block_xmin, block_ymin,
                              transf_tile, temp_tile_index):
        """
        计算 features_box ,存储像素坐标以及类别信息

        """
        block_xmax = block_xmin + self.tile_size_x
        block_ymax = block_ymin + self.tile_size_y
        height = ds.height
        width = ds.width
        tile_size_x = self.tile_size_x
        tile_size_y = self.tile_size_y
        if height <= block_ymax:
            tile_size_y = height - block_ymin
        if width <= block_xmax:
            tile_size_x = width - block_xmin

        # 给索引补0
        start_index_string = str(temp_tile_index).zfill(8)
        transf = ds.transform
        output_path_img = os.path.join(self.output_path, self.output_name, 'Images', start_index_string)
        output_path_train_label = os.path.join(self.output_path, self.output_name, 'Annotations_train')

        features_box = self._get_features_box_od(temp_input_label, block_xmin, block_ymin, transf)

        if features_box:
            # 保存tile文件（图像）
            _save_img(ds, self.tile_format,
                      block_xmin, block_ymin, tile_size_x, tile_size_y,
                      output_path_img, transf_tile, self.input_data)
            # 保存xml文件（标签）
            self._save_txt(output_path_train_label, features_box, start_index_string)
            temp_tile_index = temp_tile_index + 1
        else:
            if self.save_nolabel_tiles is True:
                _save_img(ds, self.tile_format,
                          block_xmin, block_ymin, tile_size_x, tile_size_y,
                          output_path_img, transf_tile, self.input_data)
                # 保存xml文件（标签）
                self._save_txt(output_path_train_label, features_box, start_index_string)
                temp_tile_index = temp_tile_index + 1

        return temp_tile_index

    def _get_features_box_od(self, temp_input_label, block_xmin, block_ymin, transf):
        """
        计算 features_box ,存储像素坐标以及类别信息

        """
        features_box = []
        block_xmax = block_xmin + self.tile_size_x
        block_ymax = block_ymin + self.tile_size_y
        for feature_index in temp_input_label:
            # category是feature的类别
            if self.label_class_field is None:
                category = 'unspecified'
            else:
                try:
                    category = feature_index.get_value(self.label_class_field)
                except:
                    log_error(
                        'The category field is set and information cannot be queried from the category　field，KeyError：{} '.format(
                            self.label_class_field))
            # 地理坐标的影像bbox计算
            feature_point_geo = self.parse_polygon(feature_index.geometry.to_geojson())
            points = feature_point_geo['coordinates'][0]
            for i in range(len(points)):
                y_tmp, x_tmp = rasterio.transform.rowcol(transf, points[i][0], points[i][1])
                points[i] = [y_tmp, x_tmp]
            cnt = np.array(points).astype(np.int64)
            rect = cv2.minAreaRect(cnt)   # 不管是几个点都通过cv.minAreaRect求最小外接矩形
            box = cv2.boxPoints(rect)     # cv2.boxPoints将获取到的最小外接矩形格式从长高中心点坐标旋转角度 转换成四点坐标
            y1, x1 = round(box[0][0]), round(box[0][1])
            y2, x2 = round(box[1][0]), round(box[1][1])
            y3, x3 = round(box[2][0]), round(box[2][1])
            y4, x4 = round(box[3][0]), round(box[3][1])
            # 判定是旋转框还是正框
            if y1 == y2 and x2 == x3 and y3 == y4 and x4 == x1:
                feature_xmax = max(x1, x2, x3, x4)
                feature_xmin = min(x1, x2, x3, x4)

                feature_ymax = max(y1, y2, y3, y4)
                feature_ymin = min(y1, y2, y3, y4)

                # feature_half_length_x指代像素框x方向边长的一半
                feature_half_length_x = abs(feature_xmax - feature_xmin) / 2
                feature_half_length_y = abs(feature_ymax - feature_ymin) / 2
                list_bbox = []
                # 所有需要提取标签的框,包括feature框有一半的范围在block中此时保存为0
                if (feature_xmin >= (block_xmin - feature_half_length_x)) & (
                        feature_xmax <= (block_xmax + feature_half_length_x)) & (
                        feature_ymin >= (block_ymin - feature_half_length_y)) & (
                        feature_ymax <= (block_ymax + feature_half_length_y)):

                    if (feature_xmin - block_xmin) < 0:
                        xmin = 0
                    else:
                        xmin = round(feature_xmin - block_xmin, 2)

                    if (feature_ymin - block_ymin) < 0:
                        ymin = 0
                    else:
                        ymin = round(feature_ymin - block_ymin, 2)

                    if (block_xmax - feature_xmax) < 0:
                        xmax = block_xmax - block_xmin
                    else:
                        xmax = round(feature_xmax - block_xmin, 2)
                    if (block_ymax - feature_ymax) < 0:
                        ymax = block_ymax - block_ymin
                    else:
                        ymax = round(feature_ymax - block_ymin, 2)
                    if xmin < xmax - 2 and ymin < ymax - 2:
                        list_bbox.append(xmin)
                        list_bbox.append(ymin)

                        list_bbox.append(xmax)
                        list_bbox.append(ymin)

                        list_bbox.append(xmax)
                        list_bbox.append(ymax)

                        list_bbox.append(xmin)
                        list_bbox.append(ymax)

                        list_bbox.append(category)

                        list_bbox.append(0)
                        features_box.append(list_bbox)
            else:
                list_bbox = []
                if block_xmin <= min(x1,x2,x3,x4) and max(x1,x2,x3,x4) <= block_xmax and block_ymin <= min(y1,y2,y3,y4) and max(y1,y2,y3,y4) <= block_ymax: #判断四点是否都在block内
                    x1 = int(x1 - block_xmin)
                    x2 = int(x2 - block_xmin)
                    x3 = int(x3 - block_xmin)
                    x4 = int(x4 - block_xmin)

                    y1 = int(y1 - block_ymin)
                    y2 = int(y2 - block_ymin)
                    y3 = int(y3 - block_ymin)
                    y4 = int(y4 - block_ymin)

                    list_bbox.append(x1)
                    list_bbox.append(y1)
                    list_bbox.append(x2)
                    list_bbox.append(y2)
                    list_bbox.append(x3)
                    list_bbox.append(y3)
                    list_bbox.append(x4)
                    list_bbox.append(y4)

                    list_bbox.append(category)

                    list_bbox.append(0)
                    features_box.append(list_bbox)
                else:
                    box = [(y1, x1), (y2, x2), (y3, x3), (y4, x4)]      # 和block相交的原矩形
                    internal_points = [i for i in box if block_ymin <= i[0] <= block_ymax and block_xmin <= i[1] <= block_xmax]     #原矩形在block内部的点
                    if len(internal_points) > 1:
                        if len(internal_points) == 3:
                            dis_l = []
                            # 排除掉离边缘最近的那个点
                            for i in internal_points:
                                dis = min(abs(i[0] - block_ymin),abs(i[0] - block_ymax),abs(i[1] - block_xmin),abs(i[1] - block_xmax))
                                dis_l.append(dis)
                            idx = dis_l.index(min(dis_l))
                            internal_points.pop(idx)
                        # 留下在block内的两点
                        cnt_block = np.array([[block_ymin, block_xmin], [block_ymax, block_xmin], [block_ymax, block_xmax], [block_ymin, block_xmax]]).astype(np.int64)
                        reck_block = cv2.minAreaRect(cnt_block) #将block转换成cv能算两个矩形交点的格式
                        vertices = cv2.rotatedRectangleIntersection(rect, reck_block)[1]
                        if vertices is not None:
                            _vertices = [i[0] for i in vertices.tolist()]
                            vertices = [[round(i[0]),round(i[1])] for i in _vertices]
                            max_ext_rec = self._get_max_ext_rectangle(internal_points,vertices)
                            if max_ext_rec is not None:
                                if self._polygon_area(max_ext_rec) >= 0.5 * self._polygon_area(box):
                                    y1,x1 = max_ext_rec[0][0],max_ext_rec[0][1]
                                    y2, x2 = max_ext_rec[1][0], max_ext_rec[1][1]
                                    y3, x3 = max_ext_rec[2][0], max_ext_rec[2][1]
                                    y4, x4 = max_ext_rec[3][0], max_ext_rec[3][1]

                                    x1 = int(x1 - block_xmin)
                                    x2 = int(x2 - block_xmin)
                                    x3 = int(x3 - block_xmin)
                                    x4 = int(x4 - block_xmin)

                                    y1 = int(y1 - block_ymin)
                                    y2 = int(y2 - block_ymin)
                                    y3 = int(y3 - block_ymin)
                                    y4 = int(y4 - block_ymin)

                                    list_bbox.append(x1)
                                    list_bbox.append(y1)
                                    list_bbox.append(x2)
                                    list_bbox.append(y2)
                                    list_bbox.append(x3)
                                    list_bbox.append(y3)
                                    list_bbox.append(x4)
                                    list_bbox.append(y4)

                                    list_bbox.append(category)

                                    list_bbox.append(0)
                                    features_box.append(list_bbox)

        return features_box

    def _get_max_ext_rectangle(self,internal_points,vertices):
        from copy import deepcopy
        import math
        points = []
        area_l = []
        vertices_tmp = deepcopy(vertices)
        # 将已经确定在block内部的两点和其他点分开，然后去找矩形的第三点
        for i in internal_points:
            for j in range(len(vertices)):
                if abs(i[0] - vertices[j][0]) < 0.1 and abs(i[1] - vertices[j][1]) < 0.1:
                    points.append(vertices[j])
                    vertices_tmp.pop(vertices_tmp.index(vertices[j]))
        y1, x1 = internal_points[0][0], internal_points[0][1]
        y2, x2 = internal_points[1][0], internal_points[1][1]
        if len(vertices_tmp) == 0:
            return None
        else:
            #通过已经确定的两点和其他点组合成三角形，以最小面积的三角形找和block边缘的交点（第三点）
            for i in range(len(vertices_tmp)):
                y3, x3 = vertices_tmp[i][0], vertices_tmp[i][1]
                area_l.append(abs(y1*(x2 - x3) + y2*(x3 - x1) + y3*(x1 - x2)) / 2)
            index = area_l.index(min(area_l))
            y3, x3 = vertices_tmp[index][0],vertices_tmp[index][1]
            # 下面目的是找直角顶点，通过斜边最长的定律找，然后通过矩形三点坐标确定最后一点坐标
            line12 = math.pow((x2 - x1),2) + math.pow((y2 - y1),2)
            line23 = math.pow((x3 - x2),2) + math.pow((y3 - y2),2)
            line13 = math.pow((x3 - x1),2) + math.pow((y3 - y1),2)
            if line12 == max(line12,line13,line23):
                x4 = x1 + x2 - x3
                y4 = y1 + y2 - y3
                return [(y3, x3), (y2, x2), (y4, x4), (y1, x1)]
            elif line23 == max(line12,line13,line23):
                x4 = x2 + x3 - x1
                y4 = y2 + y3 - y1
                return [(y1, x1), (y2, x2), (y4, x4), (y3, x3)]
            elif line13 == max(line12,line13,line23):
                x4 = x1 + x3 - x2
                y4 = y1 + y3 - y2
                return [(y2, x2), (y1, x1), (y4, x4), (y3, x3)]
            else:
                return None

    def _polygon_area(self,points:list):
        """
        使用鞋带公式计算多边形的面积。
        参数:
        points -- 多边形顶点的列表，格式为 [(x1, y1), (x2, y2), ...]
        返回:
        多边形的面积
        """
        n = len(points)
        area = 0
        for i in range(n):
            x1, y1 = points[i]
            x2, y2 = points[(i + 1) % n]  # 循环到第一个点
            area += x1 * y2 - y1 * x2
        return abs(area) / 2.0

    def _save_txt(self, path, bbox, index):

        # 生成文件名
        filename = f"{path}/{index}.txt"

        # 打开文件并写入bbox的内容
        with open(filename, 'w', encoding='utf-8') as file:
            for item in bbox:
                line = ' '.join(map(str, item))
                file.write(f"{line}\n")

    def _select_val_label(self, source_dir, target_dir, percentage=20):
        source_files = os.listdir(source_dir)
        target_files = os.listdir(target_dir)
        for i in target_files:
            shutil.move(os.path.join(target_dir,i),os.path.join(source_dir,i))
        # 计算要复制的文件数量
        num_files_to_copy = int(len(source_files) * (percentage / 100))
        # 随机选择要复制的文件
        files_to_copy = random.sample(source_files, num_files_to_copy)

        # 复制选定的文件到目标文件夹
        for file_name in files_to_copy:
            source_path = os.path.join(source_dir, file_name)
            target_path = os.path.join(target_dir, file_name)
            shutil.move(source_path, target_path)

    def parse_polygon(self, str_result):
        dict_result = json.loads(str_result)
        return dict_result