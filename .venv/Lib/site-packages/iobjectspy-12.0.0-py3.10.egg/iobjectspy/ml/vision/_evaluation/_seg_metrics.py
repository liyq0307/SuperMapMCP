# !/usr/bin/env python3
# coding=utf-8

import numpy as np
import rasterio

from iobjectspy import clip_raster
from iobjectspy._logger import log_warning
from iobjectspy.data import DatasetGrid, DatasetVector, Datasource
from iobjectspy.ml.toolkit._toolkit import _is_image_file
from iobjectspy.ml.utils import datasetraster_to_numpy_array
from ._base_utils import get_tp_fp_tn_fn_matrix, _confusion_matrix, get_tp_fp_tn_fn_matrix_vector, _get_unique_values, \
    _confusion_matrix_vector

eplison = 1e-12


def _convert_legal_input(inference_data, ground_truth_data, true_field_name=None, predict_field_name=None,
                         compute_type=None,
                         class_name_value=None):
    """
    对指标运算数据进行预处理，支持影像和影像数据计算，矢量和矢量数据计算

   :param inference_data: 真实标签数据文件路径，支持图像文件 和 DatasetGrid,DatasetVector(面)
    :param ground_truth_data: 预测标签数据文件路径，支持图像文件 和 DatasetGrid，DatasetVector(面)
    :param true_field_name: 真实数据类别字段名，输入为矢量数据时，应输入类别字段名
    :param predict_field_name: 预测数据类别字段名，输入为矢量数据时，应输入类别字段名

    :return: inference_data,ground_truth_data, file_type, compute_type, labels_dict,field_name_not_exist 处理完的预测数据、真实数据、文件类型、计算类型、标签字典，查询字段是否存在
    """
    # file_type
    # TODO:image还未实现可选 影像文件对影像文件 ,grid,vector
    file_type = 'image'
    # field_name_not_exist field_name 不存在
    field_name_not_exist = False
    labels = []
    # 读取真实标签，获取文件格式
    if _is_image_file(ground_truth_data) and _is_image_file(inference_data):
        ground_truth_data = rasterio.open(ground_truth_data).read()
        inference_data = rasterio.open(inference_data).read()
        # 获取计算类型
        if compute_type == None:
            labels = [i for i in range(max(ground_truth_data.max(), inference_data.max()) + 1)]
            if max(np.max(inference_data), np.max(ground_truth_data)) > 1:
                compute_type = 'multi'

    elif isinstance(ground_truth_data, DatasetGrid) and isinstance(inference_data, DatasetGrid):
        # 获取ground_truth与inference_data的交集bound
        bounds = ground_truth_data.bounds.intersect(inference_data.bounds)
        # 基于bound裁剪栅格数据集
        temp_ds = Datasource.create(':memory:')
        ground_truth_data = clip_raster(ground_truth_data, bounds, is_exact_clip=True, out_data=temp_ds,
                                        out_dataset_name='temp_ground_truth')
        inference_data = clip_raster(inference_data, bounds, is_exact_clip=True, out_data=temp_ds,
                                     out_dataset_name='temp_inference')
        # # 获取类别信息
        # labels = [i for i in range(max(int(ground_truth_data.max_value), int(inference_data.max_value)) + 1)]
        # del labels[0]
        # 将栅格数据转成numpy
        ground_truth_data = datasetraster_to_numpy_array(ground_truth_data)
        inference_data = datasetraster_to_numpy_array(inference_data)
        temp_ds.close()
        # 获取类别信息
        ground_truth_labels = np.unique(ground_truth_data).tolist()
        inference_labels = np.unique(inference_data).tolist()
        labels.extend(ground_truth_labels)
        labels.extend(inference_labels)
        labels = list(set(labels))
        # del labels[0]
        # 文件类型
        file_type = 'grid'
        # 获取计算类型
        if compute_type == None:
            if max(np.max(inference_data), np.max(ground_truth_data)) > 1:
                compute_type = 'multi'
        # 若计算二元分类则将除背景类的其他类别都转换成1
        if compute_type == 'binary':
            for i in labels:
                if i != 0.0:
                    ground_truth_data[ground_truth_data == i] = 1.0
                    inference_data[inference_data == i] = 1.0
            labels = [1]

    elif isinstance(ground_truth_data, DatasetVector) and isinstance(inference_data, DatasetVector):
        if true_field_name is None:
            true_field_name = 'value'
        if predict_field_name is None:
            predict_field_name = 'value'
        try:
            labels = _get_unique_values(ground_truth_data, true_field_name)
            labels.extend(_get_unique_values(inference_data, predict_field_name))
            labels = list(set(labels))
        except:
            labels = [1]
            field_name_not_exist = True
            log_warning('ground_truth_data: {}  or inference_data: {} is not exist  '.format(
                true_field_name, predict_field_name))

        # 文件类型
        file_type = 'vector'
        # 计算类型
        if compute_type == None and len(labels) > 1:
            compute_type = 'multi'

        if compute_type == 'binary':
            labels = [1]
            field_name_not_exist = True

    else:
        raise ValueError(
            'input_data ground_truth_data or inference_data should be image file or DatasetGrid or DatasetVector')

    # 构建类别字典，用于记录混淆矩阵行列号对应的类别
    labels_dict = {}

    if 0 in labels:
        for i, element in enumerate(labels):
            labels_dict[i] = element
    else:
        labels_dict[0] = 0
        for i, element in enumerate(labels):
            labels_dict[i + 1] = element

    if isinstance(labels_dict[1], str):
        labels_dict[0] = 'background'

    return inference_data, ground_truth_data, file_type, compute_type, labels_dict, field_name_not_exist


def _seg_all(inference_data, ground_truth_data, true_field_name=None, predict_field_name=None, compute_type=None,
             class_name_value=None,
             average='macro'):
    """
    基于输入的真实标签数据和预测标签数据计算结果的iou, pixel_acc, f1, dice, kappa, confusion_matrix，支持影像和影像数据计算，矢量和矢量数据计算

    :param inference_data: 真实标签数据文件路径，支持图像文件 和 DatasetGrid,DatasetVector(面)
    :param ground_truth_data: 预测标签数据文件路径，支持图像文件 和 DatasetGrid，DatasetVector(面)
    :param true_field_name: 真实数据类别字段名，输入为矢量数据时，应输入类别字段名
    :param predict_field_name: 预测数据类别字段名，输入为矢量数据时，应输入类别字段名
    :param average: 平均方法，micro或者macro，micro不区分类别计算所有像素或区域的指标，macro分类计算出指标后然后进行平均
    :return: 计算结果
    """

    y_pred, y_true, file_type, compute_type, labels, field_name_not_exist = _convert_legal_input(inference_data,
                                                                                                 ground_truth_data,
                                                                                                 true_field_name,
                                                                                                 predict_field_name,
                                                                                                 compute_type,
                                                                                                 class_name_value)
    if file_type == 'image':
        tp, fp, tn, fn, confusion_matrix = get_tp_fp_tn_fn_matrix(y_true, y_pred, labels)
        # confusion_matrix
        # confusion_matrix = _confusion_matrix(y_true.flatten(), y_pred.flatten(), labels=labels)
    elif file_type == 'grid':

        tp, fp, tn, fn, confusion_matrix = get_tp_fp_tn_fn_matrix(y_true, y_pred, labels)
        # confusion_matrix
        # confusion_matrix = _confusion_matrix(y_true.flatten(), y_pred.flatten(), labels=labels)
    elif file_type == 'vector':
        tp, fp, tn, fn, confusion_matrix = get_tp_fp_tn_fn_matrix_vector(y_true, y_pred, true_field_name,
                                                                         predict_field_name, labels,
                                                                         compute_type, field_name_not_exist)
        # confusion_matrix
        # confusion_matrix = _confusion_matrix_vector(y_true, y_pred, true_field_name, predict_field_name, labels,
        #                                             compute_type, field_name_not_exist)

    # binary
    temp_iou_dict = {}
    temp_pixel_acc_dict = {}
    temp_f1_dict = {}
    # temp_dice_dict = {}
    temp_kappa_dict = {}
    if compute_type == 'binary':
        # kappa
        count_sum = np.sum(tp[0:] + fp[0:])
        po = np.sum(tp[0:]) / (count_sum + eplison)
        pe = np.sum((tp[0:] + fp[0:]) * (tp[0:] + fn[0:])) / (count_sum * count_sum + eplison)
        temp_kappa_dict['ALL_Classes'] = (po - pe) / (1 - pe + eplison)
        # iou
        intersection = tp[1]
        union = tp[1] + fp[1] + fn[1]
        temp_iou_dict['ALL_Classes'] = intersection / (union + eplison)
        # pixel_acc
        temp_pixel_acc_dict['ALL_Classes'] = tp[1] / (tp[1] + fp[1] + eplison)
        # f1
        acc = tp[1] / (tp[1] + fp[1] + eplison)
        recall = tp[1] / (tp[1] + fn[1] + eplison)
        temp_f1_dict['ALL_Classes'] = 2 * acc * recall / (acc + recall + eplison)
        # dice
        # intersection = tp[1]
        # union = tp[1] + fp[1] + fn[1]
        # temp_dice_dict['ALL_Classes'] = 2 * intersection / (union + intersection + eplison)

    # multi—class
    if compute_type == 'multi':
        count_sum = np.sum(tp[0:] + fp[0:])
        po = np.sum(tp[0:]) / (count_sum + eplison)
        pe = np.sum((tp[0:] + fp[0:]) * (tp[0:] + fn[0:])) / (count_sum * count_sum + eplison)
        temp_kappa_dict['ALL_Classes'] = (po - pe) / (1 - pe + eplison)

        # IoU 与 mIoU
        inter = tp
        union = tp + fn + fp
        s = inter / (union + eplison)
        for i in labels:
            temp_iou_dict[labels[i]] = s[i]
        temp_iou_dict['ALL_Classes'] = np.average(inter[0:] / (union[0:] + eplison))

        # PA 与 mPA
        s = tp / (tp + fp + eplison)
        for i in labels:
            temp_pixel_acc_dict[labels[i]] = s[i]
        temp_pixel_acc_dict['ALL_Classes'] = np.average(tp[0:] / (tp[0:] + fp[0:] + eplison))

        # F1
        acc = tp / (tp + fp + eplison)
        recall = tp / (tp + fn + eplison)
        s = 2 * acc * recall / (acc + recall + eplison)
        for i in labels:
            temp_f1_dict[labels[i]] = s[i]
        temp_f1_dict['ALL_Classes'] = np.average(2 * acc[0:] * recall[0:] / (acc[0:] + recall[0:] + eplison))
        # dice
        # intersection = tp
        # union = tp + fn + fp
        # temp_dice_dict['ALL_Classes'] = np.average(2 * intersection[1:] / (union[1:] + intersection[1:] + eplison))
        # s = 2 * intersection / (union + intersection + eplison)
        #
        # for i in labels:
        #     if i == 0:
        #         pass
        #     else:
        #         temp_dice_dict[labels[i]] = s[i]

    return temp_pixel_acc_dict, temp_iou_dict, temp_f1_dict, temp_kappa_dict, confusion_matrix


def _seg_iou(inference_data, ground_truth_data, true_field_name=None, predict_field_name=None, compute_type=None,
             class_name_value=None,
             average='macro'):
    """
    基于输入的真实标签数据和预测标签数据计算结果的IOU得分，支持影像和影像数据计算，矢量和矢量数据计算

    :param inference_data: 真实标签数据文件路径，支持图像文件 和 DatasetGrid,DatasetVector(面)
    :param ground_truth_data: 预测标签数据文件路径，支持图像文件 和 DatasetGrid，DatasetVector(面)
    :param true_field_name: 真实数据类别字段名，输入为矢量数据时，应输入类别字段名
    :param predict_field_name: 预测数据类别字段名，输入为矢量数据时，应输入类别字段名
    :param average: 平均方法，micro或者macro，micro不区分类别计算所有像素或区域的指标，macro分类计算出指标后然后进行平均
    :return: 计算结果
    """

    y_pred, y_true, file_type, compute_type, labels, field_name_not_exist = _convert_legal_input(inference_data,
                                                                                                 ground_truth_data,
                                                                                                 true_field_name,
                                                                                                 predict_field_name,
                                                                                                 compute_type,
                                                                                                 class_name_value)

    if file_type == 'image':
        tp, fp, tn, fn, _ = get_tp_fp_tn_fn_matrix(y_true, y_pred, labels)
    elif file_type == 'vector':
        tp, fp, tn, fn, _ = get_tp_fp_tn_fn_matrix_vector(y_true, y_pred, true_field_name, predict_field_name, labels,
                                                          compute_type, field_name_not_exist)

    temp_iou_dict = {}
    # binary
    if compute_type == 'binary':
        intersection = tp[1]
        union = tp[1] + fp[1] + fn[1]
        temp_iou_dict['ALL_Classes'] = intersection / (union + eplison)
        return temp_iou_dict
    # multi—class
    if compute_type == 'multi':
        inter = tp
        union = tp + fn + fp
        temp_iou_dict['ALL_Classes'] = np.average(inter[0:] / (union[0:] + eplison))
        s = inter / (union + eplison)

        for i in labels:
            temp_iou_dict[labels[i]] = s[i]
        return temp_iou_dict


def _seg_pixel_acc(inference_data, ground_truth_data, true_field_name=None, predict_field_name=None,
                   compute_type=None,
                   class_name_value=None,
                   average='macro'):
    """
    基于输入的真实标签数据和预测标签数据计算结果的像素精度，支持影像和影像数据计算，矢量和矢量数据计算

    :param inference_data: 真实标签数据文件路径，支持图像文件 和 DatasetGrid,DatasetVector(面)
    :param ground_truth_data: 预测标签数据文件路径，支持图像文件 和 DatasetGrid，DatasetVector(面)
    :param true_field_name: 真实数据类别字段名，输入为矢量数据时，应输入类别字段名
    :param predict_field_name: 预测数据类别字段名，输入为矢量数据时，应输入类别字段名
    :param average: 平均方法，micro或者macro，micro不区分类别计算所有像素或区域的指标，macro分类计算出指标后然后进行平均
    :return: 计算结果
    """

    y_pred, y_true, file_type, compute_type, labels, field_name_not_exist = _convert_legal_input(inference_data,
                                                                                                 ground_truth_data,
                                                                                                 true_field_name,
                                                                                                 predict_field_name,
                                                                                                 compute_type,
                                                                                                 class_name_value)
    if file_type == 'image':
        tp, fp, tn, fn, _ = get_tp_fp_tn_fn_matrix(y_true, y_pred, labels)
    elif file_type == 'vector':
        tp, fp, tn, fn, _ = get_tp_fp_tn_fn_matrix_vector(y_true, y_pred, true_field_name, predict_field_name, labels,
                                                          compute_type, field_name_not_exist)
    temp_pixel_acc_dict = {}
    # binary
    if compute_type == 'binary':
        temp_pixel_acc_dict['ALL_Classes'] = tp[1] / (tp[1] + fp[1] + eplison)
        return temp_pixel_acc_dict
    # multi—class
    if compute_type == 'multi':
        temp_pixel_acc_dict['ALL_Classes'] = np.average(tp[0:] / (tp[0:] + fp[0:] + eplison))
        s = tp / (tp + fp + eplison)
        for i in labels:
            temp_pixel_acc_dict[labels[i]] = s[i]
        return temp_pixel_acc_dict


def _seg_f1(inference_data, ground_truth_data, true_field_name=None, predict_field_name=None, compute_type=None,
            class_name_value=None,
            average='macro'):
    """
        基于输入的真实标签数据和预测标签数据计算结果的f1得分，支持影像和影像数据计算，矢量和矢量数据计算

    :param inference_data: 真实标签数据文件路径，支持图像文件 和 DatasetGrid,DatasetVector(面)
    :param ground_truth_data: 预测标签数据文件路径，支持图像文件 和 DatasetGrid，DatasetVector(面)
    :param true_field_name: 真实数据类别字段名，输入为矢量数据时，应输入类别字段名
    :param predict_field_name: 预测数据类别字段名，输入为矢量数据时，应输入类别字段名
    :param average: 平均方法，micro或者macro，micro不区分类别计算所有像素或区域的指标，macro分类计算出指标后然后进行平均
    :return: 计算结果
    """

    y_pred, y_true, file_type, compute_type, labels, field_name_not_exist = _convert_legal_input(inference_data,
                                                                                                 ground_truth_data,
                                                                                                 true_field_name,
                                                                                                 predict_field_name,
                                                                                                 compute_type,
                                                                                                 class_name_value)

    if file_type == 'image':
        tp, fp, tn, fn, _ = get_tp_fp_tn_fn_matrix(y_true, y_pred, labels)
    elif file_type == 'vector':
        tp, fp, tn, fn, _ = get_tp_fp_tn_fn_matrix_vector(y_true, y_pred, true_field_name, predict_field_name, labels,
                                                          compute_type, field_name_not_exist)

    temp_f1_dict = {}
    # binary
    if compute_type == 'binary':
        acc = tp[1] / (tp[1] + fp[1] + eplison)
        recall = tp[1] / (tp[1] + fn[1] + eplison)
        temp_f1_dict['ALL_Classes'] = 2 * acc * recall / (acc + recall + eplison)
        return temp_f1_dict
    # multi—class
    if compute_type == 'multi':
        acc = tp / (tp + fp + eplison)
        recall = tp / (tp + fn + eplison)
        s = 2 * acc * recall / (acc + recall + eplison)
        for i, element in enumerate(labels):
            temp_f1_dict[element] = s[i]
        temp_f1_dict['ALL_Classes'] = np.average(2 * acc[0:] * recall[0:] / (acc[0:] + recall[0:] + eplison))
        return temp_f1_dict


# def _seg_dice(inference_data, ground_truth_data, true_field_name=None, predict_field_name=None, compute_type=None,
#               class_name_value=None,
#               average='macro'):
#     """
#         基于输入的真实标签数据和预测标签数据计算结果的dice得分，支持影像和影像数据计算，矢量和矢量数据计算
#
#     :param inference_data: 真实标签数据文件路径，支持图像文件 和 DatasetGrid,DatasetVector(面)
#     :param ground_truth_data: 预测标签数据文件路径，支持图像文件 和 DatasetGrid，DatasetVector(面)
#     :param true_field_name: 真实数据类别字段名，输入为矢量数据时，应输入类别字段名
#     :param predict_field_name: 预测数据类别字段名，输入为矢量数据时，应输入类别字段名
#     :param average: 平均方法，micro或者macro，micro不区分类别计算所有像素或区域的指标，macro分类计算出指标后然后进行平均
#     :return: 计算结果
#     """
#
#     y_pred, y_true, file_type, compute_type, labels, field_name_not_exist = _convert_legal_input(inference_data,
#                                                                                                  ground_truth_data,
#                                                                                                  true_field_name,
#                                                                                                  predict_field_name,
#                                                                                                  compute_type,
#                                                                                                  class_name_value)
#     if file_type == 'image':
#         tp, fp, tn, fn,_ = get_tp_fp_tn_fn_matrix(y_true, y_pred, labels)
#     elif file_type == 'vector':
#         tp, fp, tn, fn,_ = get_tp_fp_tn_fn_matrix_vector(y_true, y_pred, true_field_name, predict_field_name, labels,
#                                                        compute_type, field_name_not_exist)
#
#     temp_dice_dict = {}
#     # binary
#     if compute_type == 'binary':
#         intersection = tp[1]
#         union = tp[1] + fp[1] + fn[1]
#         temp_dice_dict['ALL_Classes'] = 2 * intersection / (union + intersection + eplison)
#         return temp_dice_dict
#     # multi—class
#     if compute_type == 'multi':
#         intersection = tp
#         union = tp + fn + fp
#         temp_dice_dict['ALL_Classes'] = np.average(2 * intersection[1:] / (union[1:] + intersection[1:] + eplison))
#         s = 2 * intersection / (union + intersection + eplison)
#         for i, element in enumerate(labels):
#             if i == 0:
#                 pass
#             else:
#                 temp_dice_dict[element] = s[i]
#         return temp_dice_dict


def _seg_kappa(inference_data, ground_truth_data, true_field_name=None, predict_field_name=None, compute_type=None,
               class_name_value=None):
    """
    基于输入的真实标签数据和预测标签数据计算结果的kapa得分，支持影像和影像数据计算，矢量和矢量数据计算

    :param inference_data: 真实标签数据文件路径，支持图像文件 和 DatasetGrid,DatasetVector(面)
    :param ground_truth_data: 预测标签数据文件路径，支持图像文件 和 DatasetGrid，DatasetVector(面)
    :param true_field_name: 真实数据类别字段名，输入为矢量数据时，应输入类别字段名
    :param predict_field_name: 预测数据类别字段名，输入为矢量数据时，应输入类别字段名
    :return: 计算结果
    """

    y_pred, y_true, file_type, compute_type, labels, field_name_not_exist = _convert_legal_input(inference_data,
                                                                                                 ground_truth_data,
                                                                                                 true_field_name,
                                                                                                 predict_field_name,
                                                                                                 compute_type,
                                                                                                 class_name_value)

    if file_type == 'image':
        tp, fp, tn, fn, _ = get_tp_fp_tn_fn_matrix(y_true, y_pred, labels)
    elif file_type == 'vector':
        tp, fp, tn, fn, _ = get_tp_fp_tn_fn_matrix_vector(y_true, y_pred, true_field_name, predict_field_name, labels,
                                                          compute_type, field_name_not_exist)
    temp_kappa_dict = {}
    if compute_type == 'binary':
        count_sum = np.sum(tp[0:] + fp[0:])
        po = np.sum(tp[0:]) / (count_sum + eplison)
        pe = np.sum((tp[0:]) * (tp[0:] + fn[0:])) / (count_sum * count_sum + eplison)
        temp_kappa_dict['ALL_Classes'] = (po - pe) / (1 - pe + eplison)
    if compute_type == 'multi':
        count_sum = np.sum(tp[0:] + fp[0:])
        po = np.sum(tp[0:]) / (count_sum + eplison)
        pe = np.sum((tp[0:]) * (tp[0:] + fn[0:])) / (count_sum * count_sum + eplison)
        temp_kappa_dict['ALL_Classes'] = (po - pe) / (1 - pe + eplison)
    return temp_kappa_dict


def _seg_confusion_matrix(inference_data, ground_truth_data, true_field_name=None, predict_field_name=None,
                          compute_type=None,
                          class_name_value=None):
    """
        基于输入的真实标签数据和预测标签数据计算结果的混淆矩阵，支持影像和影像数据计算，矢量和矢量数据计算

    :param inference_data: 真实标签数据文件路径，支持图像文件 和 DatasetGrid,DatasetVector(面)
    :param ground_truth_data: 预测标签数据文件路径，支持图像文件 和 DatasetGrid，DatasetVector(面)
    :param true_field_name: 真实数据类别字段名，输入为矢量数据时，应输入类别字段名
    :param predict_field_name: 预测数据类别字段名，输入为矢量数据时，应输入类别字段名
    :param average: 平均方法，micro或者macro，micro不区分类别计算所有像素或区域的指标，macro分类计算出指标后然后进行平均
    :return: 计算结果,二维的list
    :rtype: numpy.array
    """

    y_pred, y_true, file_type, compute_type, labels, field_name_not_exist = _convert_legal_input(inference_data,
                                                                                                 ground_truth_data,
                                                                                                 true_field_name,
                                                                                                 predict_field_name,
                                                                                                 compute_type,
                                                                                                 class_name_value)

    if file_type == 'image':
        return _confusion_matrix(y_true.flatten(), y_pred.flatten(), labels=labels)
    elif file_type == 'vector':
        return _confusion_matrix_vector(y_true, y_pred, true_field_name, predict_field_name, labels, compute_type,
                                        field_name_not_exist)
