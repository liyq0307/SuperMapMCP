import os
import tempfile
import time
import traceback
from enum import Enum, unique
import shutil
from iobjectspy import DatasetVector
from iobjectspy import conversion, DatasetImage, DatasetMosaic
from iobjectspy._jsuperpy._utils import check_lic
from iobjectspy._logger import log_info
from ._dataprepare_collector import create_binary_classification_data
from ._dataprepare_collector import create_general_change_detection_data
from ._dataprepare_collector import create_multi_classification_data
from ._dataprepare_collector import create_scene_classification_data
from ._dataprepare_collector import create_voc_data, create_object_extraction_data, create_object_detection_data
from ..toolkit._toolkit import _is_image_file, _get_dataset_readonly, get_pic_path_from_dir, del_dir
from ..toolkit._toolkit import get_input_dataset,get_out_data_dir


@unique
class _ImageryInType(Enum):
    SINGLEFILE = 1
    FILELIST = 2
    FILEDIR = 3
    DATASETIMAGE = 4
    DATASETMOSAIC = 5


class DataPreparation:
    """
    图像数据准备流程入口

    """

    @staticmethod
    def create_training_data(input_data, input_label, label_class_field, output_path, output_name,
                             training_data_format,
                             tile_format='jpg', tile_size_x=1024, tile_size_y=1024, tile_offset_x=512,
                             tile_offset_y=512, tile_start_index=0, save_nolabel_tiles=False, input_compare_data=None,
                             **kwargs):
        """
         训练数据生成

         | 将整幅影像数据和与其匹配的矢量标注数据切分为指定大小的瓦片，用于深度学习训练。
         | 生成的训练数据一般包括图片、标注、以及相关元信息，其中切分后的图片和标注文件名一一对应。

         :param input_data: 输入的影像数据，支持影像文件
         :type input_data: str
         :param input_label: 输入的矢量标注数据，支持矢量数据集
         :type input_label: str ot DatasetVector
         :param label_class_field: 矢量标注数据的类型字段，如指定None则认定全部标注为同一类型
         :type label_class_field: str or None
         :param output_path: 输出的训练数据存储路径
         :type output_path: str
         :param output_name: 输出的训练数据名称
         :type output_name: str
         :param training_data_format: 输出的训练数据格式，支持 VOC, Object_D, VOC_MASK，MULTI_C, BINARY_C, SCENE_C，
                                        Object_E，GENERAL_CHANGE_DET
         :type training_data_format: str
         :param tile_format: 影像瓦片格式，支持 tif, jpg, png, origin
         :type tile_format: str
         :param tile_size_x: x方向瓦片大小
         :type tile_size_x: int
         :param tile_size_y: y方向瓦片大小
         :type tile_size_y: int
         :param tile_offset_x: x方向瓦片偏移量
         :type tile_offset_x: int
         :param tile_offset_y: y方向瓦片偏移量
         :type tile_offset_y: int
         :param tile_start_index: 瓦片命名起始索引值，默认为0，当调用该接口处理多幅影像时可设置为-1
         :type tile_start_index: int
         :param save_nolabel_tiles: 是否保存无标签覆盖的瓦片，对象提取和目标检测该参数不生效
         :type save_nolabel_tiles: bool
         :param input_compare_data: 变化检测对比影像
         :return: None


        VOC格式：
          | ./VOC
          | ./VOC/Annotations/000000001.xml 目标标签
          | ./VOC/Images/000000001.jpg 影像瓦片
          | ./VOC/ImageSets/Main/train.txt, val.txt, test.txt, trainval.txt 训练集瓦片名称、验证集瓦片名称、测试集瓦片名称、训练集与验证集瓦片名称
          | ./VOC/VOC.sda 训练数据配置文件

        Object_D格式：
          | ./Object_D
          | ./Object_D/Annotations_train/000000001.txt 训练集标签
          | ./Object_D/Annotations_val/000000010.txt 验证集标签
          | ./Object_D/Images/000000001.tif 影像瓦片
          | ./Object_D/Object_D.sda 训练数据配置文件

         MULTI_C格式：
          | ./MULTI_C
          | ./MULTI_C/Images/00000000.tif 影像瓦片
          | ./MULTI_C/Masks/00000000.png 标签瓦片
          | ./MULTI_C/MULTI_C.sda 训练数据配置文件

         BINARY_C格式：
          | ./BINARY_C
          | ./BINARY_C/Images/00000000.tif 影像瓦片
          | ./BINARY_C/Masks/00000000.png 标签瓦片
          | ./BINARY_C/BINARY_C.sda 训练数据配置文件

         SCENE_C格式：
          | ./SCENE_C
          | ./SCENE_C/0/00000000.tif 影像瓦片
          | ./SCENE_C/1/00000000.png 影像瓦片
          | ./SCENE_C/2/00000000.tif 影像瓦片
          | ....
          | ./SCENE_C/scene_classification.csv 保存影像文件路径与类别映射关系
          | ./SCENE_C/SCENE_C.sda 训练数据配置文件

         Object_E格式：
          | ./Object_E
          | ./Object_E/Annotations/000000001.xml 目标标签
          | ./Object_E/Images/000000001.tif 影像瓦片
          | ./Object_E/ImageSets/Main/train.txt, val.txt, test.txt, trainval.txt 训练集瓦片名称、验证集瓦片名称、测试集瓦片名称、训练集与验证集瓦片名称
          | ./Object_E/SegmentaionObject/000000001.png Mask标签瓦片
          | ./Object_E/Object_E.sda 训练数据配置文件

         GENERAL_CHANGE_DET格式：
          | ./GENERAL_CHANGE_DET
          | ./GENERAL_CHANGE_DET/Images1/00000000.tif 影像瓦片
          | ./GENERAL_CHANGE_DET/Images2/00000000.tif 影像瓦片
          | ./GENERAL_CHANGE_DET/Masks/00000000.png 标签瓦片
          | ./GENERAL_CHANGE_DET/GENERAL_CHANGE_DET.sda 训练数据配置文件

         """

        _DataPreparation().create_training_data(input_data, input_label, label_class_field, output_path, output_name,
                                                training_data_format,
                                                tile_format=tile_format, tile_size_x=tile_size_x,
                                                tile_size_y=tile_size_y,
                                                tile_offset_x=tile_offset_x,
                                                tile_offset_y=tile_offset_y, tile_start_index=tile_start_index,
                                                save_nolabel_tiles=save_nolabel_tiles,
                                                input_compare_data=input_compare_data,
                                                **kwargs)


class _DataPreparation:
    def __init__(self):
        self.__imagery_in_type = _ImageryInType.SINGLEFILE

    def __tempDirTool(method):
        # 装饰器：对temp文件夹进行管理，避免在用户磁盘产生冗余文件
        def wrapper(self,*args, **kwargs):
            tmp_dir = get_out_data_dir(args[3])
            if tmp_dir is not None:
                if not os.path.exists(tmp_dir):
                    os.makedirs(tmp_dir)
            self.tmp_data_dir = os.path.abspath(tempfile.mkdtemp(prefix='tempSupermapMl_',dir=tmp_dir))
            log_info('ImageryInference class tmp directory is: \' {} \''.format(self.tmp_data_dir))
            try:
                return method(self,*args, **kwargs)
            except Exception as e:
                raise e
            finally:
                try:
                    shutil.rmtree(self.tmp_data_dir)
                    print("Successfully cleared temporary folder:{}".format(self.tmp_data_dir))
                except Exception as e:
                    print("Clearing temporary folder:{} failed,please check the folder".format(self.tmp_data_dir))
                    raise e
        return wrapper

    @__tempDirTool
    def create_training_data(self, input_data, input_label, label_class_field, output_path, output_name,
                             training_data_format,
                             tile_format='jpg', tile_size_x=1024, tile_size_y=1024, tile_offset_x=512,
                             tile_offset_y=512, tile_start_index=0, save_nolabel_tiles=False, input_compare_data=None,
                             **kwargs):
        check_lic()
        # 判断输出文件夹是否有内容
        # outpath = os.path.join(output_path, output_name)
        # if (os.path.exists(outpath)) & (tile_start_index != -1):
        #     files = os.listdir(outpath)
        #     if files:
        #         raise TypeError('`{:s}` is not empty or tile_start_index is not -1'.format(outpath))
        # 检查输出路径格式是否正确
        if not isinstance(output_path, str):
            raise TypeError('output_path must be str')
        # 检查输出训练数据格式是否正确
        if not isinstance(training_data_format, str):
            raise TypeError('training_data_format must be str')
        # 从输入路径获取输入数据列表并进行检查
        if training_data_format == 'GENERAL_CHANGE_DET':
            input_data_list = self.__get_input_data_list(input_data)
            input_compare_data_list = self.__get_input_data_list(input_compare_data)
            # 检查列表中的输入compare数据文件格式是否相同
            self.__check_data_format(input_compare_data_list)
        else:
            input_data_list = self.__get_input_data_list(input_data)
        # 检查列表中的输入数据文件格式是否相同
        self.__check_data_format(input_data_list)
        # 获取标签数据并进行检查
        _source_input_label_list = self.__get_input_label_list(input_label)

        if self.__imagery_in_type is _ImageryInType.SINGLEFILE or self.__imagery_in_type is _ImageryInType.DATASETIMAGE:
            # 单张影像数据或单张影像数据集
            _source_input_label = get_input_dataset(_source_input_label_list[0])

            if training_data_format == 'VOC':
                # create_voc_data(input_data_list[0], _source_input_label, label_class_field, output_path, output_name,
                #                 training_data_format,
                #                 tile_format, tile_size_x, tile_size_y, tile_offset_x, tile_offset_y, tile_start_index,
                #                 False, **kwargs)
                # import warnings
                # warnings.warn('The VOC training data format bas been abandoned and the Object_D is used by default!',
                #               UserWarning)
                create_voc_data(input_data_list[0], _source_input_label, label_class_field, output_path, output_name,
                               training_data_format,
                               tile_format, tile_size_x, tile_size_y, tile_offset_x, tile_offset_y, tile_start_index,
                               False, **kwargs)
            elif training_data_format == 'Object_D':
                create_object_detection_data(input_data_list[0], _source_input_label, label_class_field, output_path, output_name,
                                training_data_format,
                                tile_format, tile_size_x, tile_size_y, tile_offset_x, tile_offset_y, tile_start_index,
                                save_nolabel_tiles, **kwargs)
            elif training_data_format == 'VOC_MASK':
                import warnings
                warnings.warn('The VOC_MASK training data format bas been abandoned and the Object_E is used by default!',
                              UserWarning)
                create_object_extraction_data(input_data_list[0], _source_input_label, label_class_field, output_path,
                                     output_name,
                                     training_data_format,
                                     tile_format, tile_size_x, tile_size_y, tile_offset_x, tile_offset_y,
                                     tile_start_index,
                                     False, **kwargs)
            elif training_data_format == 'Object_E':
                create_object_extraction_data(input_data_list[0], _source_input_label, label_class_field, output_path,
                                     output_name,
                                     training_data_format,
                                     tile_format, tile_size_x, tile_size_y, tile_offset_x, tile_offset_y,
                                     tile_start_index,
                                     save_nolabel_tiles, **kwargs)
            elif training_data_format == 'MULTI_C':
                create_multi_classification_data(input_data_list[0], _source_input_label, label_class_field,
                                                 output_path,
                                                 output_name,
                                                 training_data_format,
                                                 tile_format, tile_size_x, tile_size_y, tile_offset_x, tile_offset_y,
                                                 tile_start_index,
                                                 save_nolabel_tiles, **kwargs)
            elif training_data_format == 'BINARY_C':
                create_binary_classification_data(input_data_list[0], _source_input_label, label_class_field,
                                                  output_path,
                                                  output_name,
                                                  training_data_format,
                                                  tile_format, tile_size_x, tile_size_y, tile_offset_x, tile_offset_y,
                                                  tile_start_index,
                                                  save_nolabel_tiles, **kwargs)
            elif training_data_format == 'SCENE_C':
                create_scene_classification_data(input_data_list[0], _source_input_label, label_class_field,
                                                 output_path,
                                                 output_name,
                                                 training_data_format,
                                                 tile_format, tile_size_x, tile_size_y, tile_offset_x, tile_offset_y,
                                                 tile_start_index,
                                                 save_nolabel_tiles, **kwargs)
            elif training_data_format == 'GENERAL_CHANGE_DET':
                create_general_change_detection_data(input_data_list[0], input_compare_data_list[0], _source_input_label,
                                                     label_class_field, output_path,
                                                     output_name,
                                                     training_data_format,
                                                     tile_format, tile_size_x, tile_size_y, tile_offset_x,
                                                     tile_offset_y,
                                                     tile_start_index,
                                                     save_nolabel_tiles, **kwargs)
            else:
                raise Exception('{} Format not supported'.format(training_data_format))

        elif self.__imagery_in_type is _ImageryInType.DATASETMOSAIC:
            # 输入镶嵌数据集
            _source_input_label = get_input_dataset(_source_input_label_list[0])
            for i in range(len(input_data_list)):
                input_data_path = input_data_list[i]
                if not os.path.exists(input_data_path):
                    raise ValueError('input_data does not exist')
                if training_data_format == 'GENERAL_CHANGE_DET':
                    input_compare_data_path = os.path.join(os.path.dirname(input_compare_data_list[0]),
                                                           os.path.basename(input_data_path))
                    if not os.path.exists(input_compare_data_path):
                        raise ValueError('input_compare_data does not exist')

                if i != 0:
                    tile_start_index = -1
                if training_data_format == 'VOC':
                    # create_voc_data(input_data_list[0], _source_input_label, label_class_field, output_path, output_name,
                    #                 training_data_format,
                    #                 tile_format, tile_size_x, tile_size_y, tile_offset_x, tile_offset_y, tile_start_index,
                    #                 False, **kwargs)
                    import warnings
                    warnings.warn('The VOC training data format bas been abandoned and the Object_D is used by default!',
                                  UserWarning)
                    create_object_detection_data(input_data_path, _source_input_label, label_class_field, output_path, output_name,
                                   training_data_format,
                                   tile_format, tile_size_x, tile_size_y, tile_offset_x, tile_offset_y,
                                   tile_start_index,
                                   False, **kwargs)
                elif training_data_format == 'Object_D':
                    create_object_detection_data(input_data_path, _source_input_label, label_class_field, output_path, output_name,
                                   training_data_format,
                                   tile_format, tile_size_x, tile_size_y, tile_offset_x, tile_offset_y,
                                   tile_start_index,
                                   False, **kwargs)
                elif training_data_format == 'VOC_MASK':
                    import warnings
                    warnings.warn(
                        'The VOC_MASK training data format bas been abandoned and the Object_E is used by default!',
                        UserWarning)
                    create_object_extraction_data(input_data_path, _source_input_label, label_class_field, output_path,
                                         output_name,
                                         training_data_format,
                                         tile_format, tile_size_x, tile_size_y, tile_offset_x, tile_offset_y,
                                         tile_start_index,
                                         False, **kwargs)
                elif training_data_format == 'Object_E':
                    create_object_extraction_data(input_data_path, _source_input_label, label_class_field, output_path,
                                         output_name,
                                         training_data_format,
                                         tile_format, tile_size_x, tile_size_y, tile_offset_x, tile_offset_y,
                                         tile_start_index,
                                         save_nolabel_tiles, **kwargs)
                elif training_data_format == 'MULTI_C':
                    create_multi_classification_data(input_data_path, _source_input_label, label_class_field,
                                                     output_path,
                                                     output_name,
                                                     training_data_format,
                                                     tile_format, tile_size_x, tile_size_y, tile_offset_x,
                                                     tile_offset_y,
                                                     tile_start_index,
                                                     save_nolabel_tiles, **kwargs)
                elif training_data_format == 'BINARY_C':
                    create_binary_classification_data(input_data_path, _source_input_label, label_class_field,
                                                      output_path,
                                                      output_name,
                                                      training_data_format,
                                                      tile_format, tile_size_x, tile_size_y, tile_offset_x,
                                                      tile_offset_y,
                                                      tile_start_index,
                                                      save_nolabel_tiles, **kwargs)
                elif training_data_format == 'SCENE_C':
                    create_scene_classification_data(input_data_path, _source_input_label, label_class_field,
                                                     output_path,
                                                     output_name,
                                                     training_data_format,
                                                     tile_format, tile_size_x, tile_size_y, tile_offset_x,
                                                     tile_offset_y,
                                                     tile_start_index,
                                                     save_nolabel_tiles, **kwargs)
                elif training_data_format == 'GENERAL_CHANGE_DET':
                    create_general_change_detection_data(input_data_path, input_compare_data_path, _source_input_label,
                                                         label_class_field, output_path,
                                                         output_name,
                                                         training_data_format,
                                                         tile_format, tile_size_x, tile_size_y, tile_offset_x,
                                                         tile_offset_y,
                                                         tile_start_index,
                                                         save_nolabel_tiles, **kwargs)

        else:
            # 多张影像文件夹
            lable_list_lenth = len(_source_input_label_list)
            for i in range(len(input_data_list)):
                input_data_path = input_data_list[i]
                if training_data_format == 'GENERAL_CHANGE_DET':
                    input_compare_data_path = input_compare_data_list[i]
                    if not os.path.exists(input_compare_data_path):
                        raise ValueError('input_compare_data does not exist')
                if lable_list_lenth == 1:
                    _source_input_label = get_input_dataset(_source_input_label_list[0])
                    if _source_input_label is None:
                        raise ValueError('source input_data is None')
                    if not isinstance(_source_input_label, DatasetVector):
                        raise ValueError('source input_data must be DatasetVector')
                elif lable_list_lenth > 1 and lable_list_lenth == len(input_data_list):
                    _source_input_label = get_input_dataset(_source_input_label_list[i])
                    if _source_input_label is None:
                        raise ValueError('source input_data is None')
                    if not isinstance(_source_input_label, DatasetVector):
                        raise ValueError('source input_data must be DatasetVector')
                else:
                    raise ValueError('input_label does not exist')
                if not os.path.exists(input_data_path):
                    raise ValueError('input_data does not exist')

                if i != 0:
                    tile_start_index = -1
                if training_data_format == 'VOC':
                    # create_voc_data(input_data_list[0], _source_input_label, label_class_field, output_path, output_name,
                    #                 training_data_format,
                    #                 tile_format, tile_size_x, tile_size_y, tile_offset_x, tile_offset_y, tile_start_index,
                    #                 False, **kwargs)
                    import warnings
                    warnings.warn('The VOC training data format bas been abandoned and the Object_D is used by default!',
                                  UserWarning)
                    create_object_detection_data(input_data_path, _source_input_label, label_class_field, output_path, output_name,
                                   training_data_format,
                                   tile_format, tile_size_x, tile_size_y, tile_offset_x, tile_offset_y,
                                   tile_start_index,
                                   False, **kwargs)
                elif training_data_format == 'Object_D':
                    create_object_detection_data(input_data_path, _source_input_label, label_class_field, output_path, output_name,
                                   training_data_format,
                                   tile_format, tile_size_x, tile_size_y, tile_offset_x, tile_offset_y,
                                   tile_start_index,
                                   False, **kwargs)
                elif training_data_format == 'VOC_MASK':
                    import warnings
                    warnings.warn(
                        'The VOC_MASK training data format bas been abandoned and the Object_E is used by default!',
                        UserWarning)
                    create_object_extraction_data(input_data_path, _source_input_label, label_class_field, output_path,
                                         output_name,
                                         training_data_format,
                                         tile_format, tile_size_x, tile_size_y, tile_offset_x, tile_offset_y,
                                         tile_start_index,
                                         False, **kwargs)
                elif training_data_format == 'Object_E':
                    create_object_extraction_data(input_data_path, _source_input_label, label_class_field, output_path,
                                         output_name,
                                         training_data_format,
                                         tile_format, tile_size_x, tile_size_y, tile_offset_x, tile_offset_y,
                                         tile_start_index,
                                         save_nolabel_tiles, **kwargs)
                elif training_data_format == 'MULTI_C':
                    create_multi_classification_data(input_data_path, _source_input_label, label_class_field,
                                                     output_path,
                                                     output_name,
                                                     training_data_format,
                                                     tile_format, tile_size_x, tile_size_y, tile_offset_x,
                                                     tile_offset_y,
                                                     tile_start_index,
                                                     save_nolabel_tiles, **kwargs)
                elif training_data_format == 'BINARY_C':
                    create_binary_classification_data(input_data_path, _source_input_label, label_class_field,
                                                      output_path,
                                                      output_name,
                                                      training_data_format,
                                                      tile_format, tile_size_x, tile_size_y, tile_offset_x,
                                                      tile_offset_y,
                                                      tile_start_index,
                                                      save_nolabel_tiles, **kwargs)
                elif training_data_format == 'SCENE_C':
                    create_scene_classification_data(input_data_path, _source_input_label, label_class_field,
                                                     output_path,
                                                     output_name,
                                                     training_data_format,
                                                     tile_format, tile_size_x, tile_size_y, tile_offset_x,
                                                     tile_offset_y,
                                                     tile_start_index,
                                                     save_nolabel_tiles, **kwargs)
                elif training_data_format == 'GENERAL_CHANGE_DET':
                    create_general_change_detection_data(input_data_path, input_compare_data_path, _source_input_label,
                                                         label_class_field, output_path,
                                                         output_name,
                                                         training_data_format,
                                                         tile_format, tile_size_x, tile_size_y, tile_offset_x,
                                                         tile_offset_y,
                                                         tile_start_index,
                                                         save_nolabel_tiles, **kwargs)

        print("The create training data have done!")

    def __get_input_data_list(self, input_data):

        data_list = []
        if isinstance(input_data, DatasetImage):
            # 单张影像数据集对象
            self.__imagery_in_type = _ImageryInType.DATASETIMAGE
            log_info('Input Data Type: DatasetImage.')
            data_list.append(self.__get_dataset_to_tmp_tif_path(input_data))

        elif isinstance(input_data, DatasetMosaic):
            # 镶嵌数据集对象
            self.__imagery_in_type = _ImageryInType.DATASETMOSAIC
            log_info('Input Data Type: DatasetMosaic.')
            data_list = input_data.list_files()

        elif isinstance(input_data, list):
            # 影像文件路径list对象
            self.__imagery_in_type = _ImageryInType.FILELIST
            log_info('Input Data Type: Imagery File List.')
            data_list = input_data

        elif isinstance(input_data, str):
            if os.path.isdir(input_data):
                # 含有影像文件的目录
                self.__imagery_in_type = _ImageryInType.FILEDIR
                log_info('Input Data Type: Imagery File Directory.')
                suffix = ['.tif', '.TIF', '.tiff', '.TIFF', '.img', '.IMG']
                data_list = get_pic_path_from_dir(input_data, True, suffix)
                data_list.sort()

            elif _is_image_file(input_data):
                # 单张影像文件
                self.__imagery_in_type = _ImageryInType.SINGLEFILE
                log_info('Input Data Type: Single Imagery File.')
                data_list.append(input_data)

            else:
                # 字符串形式输入的数据集形式，支持单张影像数据集和镶嵌数据集
                try:
                    input_data = _get_dataset_readonly(input_data)
                except Exception:
                    traceback.print_exc()
                    raise TypeError('Input Data Type is not Supported or not exist!')

                if isinstance(input_data, DatasetMosaic):
                    self.__imagery_in_type = _ImageryInType.DATASETMOSAIC
                    log_info('Input Data Type: DatasetMosaic.')
                    data_list = input_data.list_files()

                elif isinstance(input_data, DatasetImage):
                    self.__imagery_in_type = _ImageryInType.DATASETIMAGE
                    log_info('Input Data Type: DatasetImage.')
                    data_list.append(self.__get_dataset_to_tmp_tif_path(input_data))
                else:
                    raise TypeError('Input Data Type is not Supported!')
        else:
            raise TypeError('Input Data Type is not Supported or not exist!')

        return data_list

    def __get_input_label_list(self, input_data):
        data_list = []
        if isinstance(input_data, DatasetVector) or isinstance(input_data, str):
            # 单张矢量数据集对象
            log_info('Input Label Data Type: DatasetVector.')
            data_list.append(input_data)

        elif isinstance(input_data, list):
            # 矢量文件路径list对象
            log_info('Input Label Data Type: DatasetVector List.')
            data_list = input_data
        else:
            raise TypeError('Input Data Type is not Supported or not exist!')
        return data_list

    def __get_dataset_to_tmp_tif_path(self, input_data):
        temp_tif_path = os.path.join(self.tmp_data_dir, str(round(time.time() * 1000)) + '.tif')
        conversion.export_to_tif(input_data, temp_tif_path)
        log_info('Tmp Imagery is Saved in: {}'.format(temp_tif_path))
        return temp_tif_path

    def __check_data_format(self, input_data_list):
        # 检查输入的多个影像数据格式是否相同
        __format = os.path.splitext(input_data_list[0])[-1]
        for i in input_data_list:
            if not i.endswith(__format):
                raise ValueError('Input Data Format must be Same!')
