import os
import torch
import rasterio
from rasterio.windows import Window
from rasterio import Affine
from torch.utils.data import DataLoader
from tqdm import tqdm
from ...toolkit._toolkit import get_config_from_yaml
from .._models.super_resolution.inference.srInferDataset import SrInferDataset
from .._models.device_utils import Device_type


class SuperResolution:
    def __init__(self,
                 model_path,
                 gpus=[0],
                 batch_size=1,
                 ):
        self.batch_size = batch_size
        self.gpus = gpus
        self.out_file_list = []
        self.config = get_config_from_yaml(model_path)
        self.model_path = os.path.join(os.path.dirname(model_path),self.config.generator)
        self.scale = self.config.scale
        self.upSampler = None

        self.is_multi_gpu = False
        Device_type.setup()
        if len(self.gpus) > 1:
            if -1 in self.gpus:
                raise ValueError("Please ensure you do not use CPU and GPU devices simultaneously for inference.")
            self.device = torch.device(f'{Device_type._device}:{self.gpus[0]}')
            if len(self.gpus) > batch_size:
                self.batch_size = len(self.gpus)
            self.is_multi_gpu = True
        elif len(self.gpus) == 1 and self.gpus[0] != -1:
            self.device = torch.device(f'{Device_type._device}:{self.gpus[0]}')
        elif len(self.gpus) == 1 and self.gpus[0] == -1:
            Device_type.setup('cpu')
            self.device = torch.device('cpu')
        else:
            self.device = Device_type.get_device()

        self.__load_model()

    def infer(self, input_data, output_path, out_dataset_name, offset=0,**kwargs):
        '''
        :param input_data: 输入影像数据
        :param output_path: 输出文件夹路径
        :param out_dataset_name: 输出文件名称
        :param tile_size: 切块大小
        :param offset:重叠度，暂时未完成
        :return: 完成超分后影像
        '''
        tile_size = kwargs.pop('tile_size',512)
        if tile_size < 128:
            raise ValueError("The tile_size must be > 128")
        print("\nFileName：{}\n".format(os.path.basename(input_data)))
        extension = os.path.basename(input_data).rsplit('.', 1)[1]
        out_dataset_name = ''.join((out_dataset_name, '.', extension))
        with rasterio.open(input_data) as oImg:
            meta = self.__update_meta(oImg.meta)
            windows = self.__get_sliding_windows(oImg, tile_size, offset)
            with rasterio.open(os.path.join(output_path, out_dataset_name), 'w', **meta) as dst:
                dataset = SrInferDataset(oImg, windows)
                dataLoader = DataLoader(dataset, batch_size=self.batch_size, num_workers=0)
                for i, idx in tqdm(dataLoader):
                    out_tile = self.upSampler.infer(i)
                    index = idx.cpu().numpy()
                    self.__write_blocks(dst, out_tile, windows, index)
        Device_type.empty_cache()
        return os.path.join(output_path, out_dataset_name)

    def _real_esrgan_pytorch_load_model(self):
        '''
        :return: 实例化RealESRGANer对象
        '''
        from .._models.super_resolution.inference.realesrganer import RealESRGANer
        from basicsr.archs.rrdbnet_arch import RRDBNet
        model = RRDBNet(num_in_ch=3, num_out_ch=3, num_feat=64, num_block=23, num_grow_ch=32, scale=self.scale)
        self.upSampler = RealESRGANer(
            scale=self.scale,
            model_path=self.model_path,
            gpus=self.gpus,
            model=model,
            device=self.device,
            is_multi_gpu=self.is_multi_gpu
        )

    @staticmethod
    def __get_sliding_windows(img, tile_size, offset):
        """
        获取栅格数据滑块推理的window列表
        :param Img: rasterio.open打开后的影像数据
        :return: 所有划分好的window的list
        """
        # 求高宽切片数量
        colNum = int(
            img.width // tile_size if img.width % tile_size == 0 else img.width // tile_size + 1)
        rowNum = int(
            img.height // tile_size if img.height % tile_size == 0 else img.height // tile_size + 1)

        _x, _y = 0, 0
        _windowsList = []
        for i in range(rowNum):
            if i != rowNum - 1:
                for j in range(colNum):
                    if j != colNum - 1:
                        _window = Window(_x, _y, tile_size, tile_size)
                        _windowsList.append(_window)
                        _x += tile_size
                    else:
                        _window = Window(img.width - tile_size, _y, tile_size,
                                         tile_size)
                        _windowsList.append(_window)
                        _x = 0
                        _y += tile_size
            else:
                for j in range(colNum):
                    if j != colNum - 1:
                        _window = Window(_x, img.height - tile_size, tile_size,tile_size)
                        _windowsList.append(_window)
                        _x += tile_size
                    else:
                        _window = Window(img.width - tile_size,img.height - tile_size, tile_size,tile_size)
                        _windowsList.append(_window)
                        _x = 0
                        _y += tile_size
        return _windowsList

    def __update_meta(self, meta):
        """
        输入超分前影像的meta进行相应倍数的处理，主要是坐标系和仿射矩阵
        :param meta: rasterio读取到的影像meta信息
        :return: 处理成超分后影像的metaa
        """
        # crs = CRS(
        #     datum='WGS84',
        #     no_defs=True,
        #     proj='utm',
        #     zone=11,
        #     units='m'
        # )
        transform = Affine(a=meta["transform"].a / self.scale, b=meta["transform"].b, c=meta["transform"].c,
                           d=meta["transform"].d, e=meta["transform"].e / self.scale, f=meta["transform"].f)
        _meta = {
            "driver": meta["driver"],
            "dtype": meta["dtype"],
            "nodata": meta["nodata"],
            "width": meta["width"] * self.scale,
            "height": meta["height"] * self.scale,
            "count": meta["count"],
            "crs": meta["crs"],
            "transform": transform,
            "compress": 'lzw'
        }
        #推理产生大tif（大于4g）结果文件时，可能会因为创建的不是BIGTIFF而导致在LZW压缩时导致rasterio出错
        if _meta["width"] * _meta["height"] > 1e8 and _meta["driver"] == 'GTiff':
            _meta["BIGTIFF"] = "YES"
        return _meta

    def __write_blocks(self, dst, array, windows, index):
        '''
        :param dst: rasterio.open打开以后的目标影像文件源
        :param array: block,numpy.array格式
        :param windows: 滑窗
        :param index: 滑窗索引
        :return:
        '''
        for i in range(array.shape[0]):
            tile = array[i]
            window = windows[index[i]]
            dst.write(tile, window=Window(window.col_off * self.scale, window.row_off * self.scale,
                                          window.width * self.scale, window.height * self.scale))

    def __load_model(self):
        """
        根据func_str拼接字符串自动执行各个网络的模型加载函数
        :return:
        """
        func_str = 'self._' + self.config.development_kit + '_' + self.config.framework + '_load_model'
        return eval(func_str)()
