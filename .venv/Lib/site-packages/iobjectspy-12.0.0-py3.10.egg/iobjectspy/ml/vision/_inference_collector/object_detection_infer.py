# !/usr/bin/env python3
# coding=utf-8
import os
import re

import yaml
from dotmap import DotMap
from iobjectspy import  DatasetImage, DatasetMosaic
from ...toolkit._toolkit import get_config_from_yaml


class ObjectDetection:
    def __init__(self, model_path, gpus, batch_size, **kwargs):
        self.config = model_path
        self.nms_thresh = kwargs.get('nms_thresh')
        self.score_thresh = kwargs.get('score_thresh')
        self.model_path = os.path.abspath(os.path.join(model_path, os.path.pardir))
        self.gpus=gpus
        self.batch_size=batch_size
        self.load_model()

    def load_model(self):
        func_config = get_config_from_yaml(self.config)
        if func_config.development_kit == 'mmdet':
            from .._models.object_detection._torch_models.inference_mmdet import MmdetEstimation
            self.estimation = MmdetEstimation(self.model_path, self.config,
                                              self.nms_thresh, self.score_thresh, self.gpus)
        elif func_config.development_kit == 'mmrotate':
            from .._models.object_detection._torch_models.inference_mmrotate import MmrotateEstimation
            self.estimation = MmrotateEstimation(self.model_path, self.config,
                                                 self.nms_thresh, self.score_thresh, self.gpus)
        else:
            raise NotImplementedError('Not support! Please use the SuperMap iObjects Python 11i(2023) V11.1.1 and earlier version!')

    def infer(self, input_data, out_data, out_dataset_name, category_name,infer_region):
        """
        根据func_str拼接字符串自动执行各个网络的函数
        :return:
        """
        func_config = get_config_from_yaml(self.config)
        if func_config.development_kit:
            func_str = 'self.' + func_config.development_kit + '_' + func_config.framework
        else:
            func_str = 'self.' + func_config.model_architecture + '_' + func_config.framework
        print("The Object Detection have started!")
        return eval(func_str)(input_data, out_data, out_dataset_name, category_name,infer_region)

    def infer_pic(self, input_data, out_data, out_dataset_name, category_name):
        """
        根据func_str拼接字符串自动执行各个网络的函数
        :return:
        """
        func_config = get_config_from_yaml(self.config)
        if func_config.development_kit:
            func_str = 'self.' + func_config.development_kit + '_' + func_config.framework + '_pic'
        else:
            raise NotImplementedError("Not implemented, please use another algorithm!")
        return eval(func_str)(input_data, out_data, out_dataset_name, category_name)

    def mmdet_pytorch(self, input_data, out_data, out_dataset_name, category_name, infer_region):
        if category_name is None:
            # 获取类别信息yaml
            with open(self.config,encoding='utf-8') as f:
                config_dict = yaml.load(f, Loader=yaml.FullLoader)
            config = DotMap(config_dict)
            # 模型中支持的所有类别
            category_name = config.get("model").get("categorys")
            category_name = [str(i) for i in category_name]

        else:
            regex = ",|£¬"
            category_name = re.split(regex, category_name)

        if not isinstance(self.model_path, str):
            raise TypeError('model_path must be str ')
        elif not os.path.exists(self.model_path):
            raise Exception('model_path does not exist ')

        if not isinstance(out_dataset_name, str):
            raise TypeError('out_dataset_name must be str ')

        # if isinstance(input_data, str):
        #     result = self.estimation.estimation_img(input_data, out_data, out_dataset_name, category_name)
        #
        # else:
        #     raise TypeError('input_data must be str or Dataset')
        result = self.estimation.estimation_img(input_data, out_data, out_dataset_name, category_name, infer_region)
        if isinstance(input_data, DatasetImage) or isinstance(input_data, DatasetMosaic):
            src_data = input_data.name
        else:
            src_data = os.path.basename(input_data).split('.')[0]

        if isinstance(result, str):
            print('The results of image \'{}\' have been saved to \'{}\'!'.format(src_data,
                                                                                  os.path.basename(result).split(
                                                                                      '.')[0]))
        else:
            print('Inference have done!')
        return result

    def mmdet_pytorch_pic(self, input_data, out_data, out_dataset_name, category_name):
        if category_name is None:
            # 获取类别信息yaml
            with open(self.config,encoding='utf-8') as f:
                config_dict = yaml.load(f, Loader=yaml.FullLoader)
            config = DotMap(config_dict)
            # 模型中支持的所有类别

            category_name = config.get("model").get("categorys")
            category_name = [str(i) for i in category_name]

        else:
            regex = ",|£¬"
            category_name = re.split(regex, category_name)

        if not isinstance(self.model_path, str):
            raise TypeError('model_path must be str ')
        elif not os.path.exists(self.model_path):
            raise Exception('model_path does not exist ')

        if not isinstance(out_data, str):
            raise TypeError('out_data must be str ')
        if not isinstance(out_dataset_name, str):
            raise TypeError('out_dataset_name must be str ')

        result = self.estimation.estimation_pic(input_data, out_data, out_dataset_name, category_name)

        return result

    def mmrotate_pytorch(self, input_data, out_data, out_dataset_name, category_name, infer_region):
        if category_name is None:
            # 获取类别信息yaml
            with open(self.config,encoding='utf-8') as f:
                config_dict = yaml.load(f, Loader=yaml.FullLoader)
            config = DotMap(config_dict)
            # 模型中支持的所有类别
            category_name = config.get("model").get("categorys")
            category_name = [str(i) for i in category_name]

        else:
            regex = ",|£¬"
            category_name = re.split(regex, category_name)

        if not isinstance(self.model_path, str):
            raise TypeError('model_path must be str ')
        elif not os.path.exists(self.model_path):
            raise Exception('model_path does not exist ')

        if not isinstance(out_dataset_name, str):
            raise TypeError('out_dataset_name must be str ')

        # if isinstance(input_data, str):
        #     result = self.estimation.estimation_img(input_data, out_data, out_dataset_name, category_name)
        #
        # else:
        #     raise TypeError('input_data must be str or Dataset')
        result = self.estimation.estimation_img(input_data, out_data, out_dataset_name, category_name, infer_region)
        if isinstance(input_data, DatasetImage) or isinstance(input_data, DatasetMosaic):
            src_data = input_data.name
        else:
            src_data = os.path.basename(input_data).split('.')[0]

        if isinstance(result, str):
            print('The results of image \'{}\' have been saved to \'{}\'!'.format(src_data,
                                                                                  os.path.basename(result).split(
                                                                                      '.')[0]))
        else:
            print('Inference have done!')
        return result

    def mmrotate_pytorch_pic(self, input_data, out_data, out_dataset_name, category_name):
        if category_name is None:
            # 获取类别信息yaml
            with open(self.config,encoding='utf-8') as f:
                config_dict = yaml.load(f, Loader=yaml.FullLoader)
            config = DotMap(config_dict)
            # 模型中支持的所有类别

            category_name = config.get("model").get("categorys")
            category_name = [str(i) for i in category_name]

        else:
            regex = ",|£¬"
            category_name = re.split(regex, category_name)

        if not isinstance(self.model_path, str):
            raise TypeError('model_path must be str ')
        elif not os.path.exists(self.model_path):
            raise Exception('model_path does not exist ')

        if not isinstance(out_data, str):
            raise TypeError('out_data must be str ')
        if not isinstance(out_dataset_name, str):
            raise TypeError('out_dataset_name must be str ')

        result = self.estimation.estimation_pic(input_data, out_data, out_dataset_name, category_name)

        return result

    def close_model(self):
        self.estimation.close_model()


class ObjectDetectionWithTile:
    def __init__(self, model_path):
        """
        使用numpy进行目标检测,输入为图像数组和输出为feature
        :param model_path: 模型路径
        :param config: 配置文件路径
        :param kwargs:
        """
        config = model_path
        self.config = get_config_from_yaml(model_path)
        self.model_path = os.path.abspath(os.path.join(model_path, os.path.pardir))
        pass
        # self.estimate = ObjectDetectionEstimation(self.model_path, self.config, nms_thresh, score_thresh)
        # run_prediction = ObjectDetectionEstimation(self.model_path, self.config, nms_thresh, score_thresh)
        # result = run_prediction.estimation_pic(input_data, out_data, out_dataset_name, category_name)

    def infer_tile(self, image_data,
                   category_name,
                   nms_thresh,
                   score_thresh):
        func_str = 'self.' + self.config.model_architecture + '_' + self.config.framework + '_tile'

        # return eval(func_str)(input_data, out_data, out_dataset_name, category_name)

    def close_model(self):
        self.estimate.close_model()
